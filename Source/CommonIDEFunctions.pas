(**

  This module contains common code that can be used within each of the IDE
  imlpementations (Delphi and VB).

  @Author  David Hoyle
  @Date    12 Apr 2009
  @Version 1.0

**)
Unit CommonIDEFunctions;

Interface

Uses
  SysUtils, Windows, Classes, BaselanguageModule;

Type
  {$INCLUDE '..\..\..\Library\CompilerDefinitions.inc'}

  (** This is a procedure to returns the success of the parse in the thread. **)
  TParserNotify = Procedure(boolSuccessfulParse : Boolean) Of Object;
  (** This is a procedure to allow the thread to get information from the
      calling IDE. **)
  TEditorInformation = Procedure(var strFileName : String;
    var boolModified : Boolean; MemoryStream : TMemoryStream) Of Object;
  (** This is a procedure to allow the thread to render the module in the
      calling IDEs main thread. **)
  TRenderDocumentTree = Procedure(Module : TBaseLanguageModule) Of Object;
  (** This is a procedure to allow the thread to display an error message in
      the calling IDEs main thread. **)
  TThreadExceptionMsg = Procedure(strExceptionMsg : String) Of Object;

  (** This class defines a thread in which the parsing of the code and
      rendering of the module explorer is done. **)
  TBrowseAndDocItThread = class(TThread)
  {$IFDEF D2005} Strict {$ENDIF} Private
    FModule: TBaseLanguageModule;
    FMemoryStream : TMemoryStream;
    FFileName: String;
    FType    : String;
    FModified: Boolean;
    FSuccessfulParseProc : TParserNotify;
    FRenderDocumentTree: TRenderDocumentTree;
    FThreadExceptionMsg: TThreadExceptionMsg;
    Procedure SetName;
  {$IFDEF D2005} Strict {$ENDIF} Protected
    Procedure Execute; Override;
    Procedure RenderModuleExplorer;
    Procedure ShowException;
  Public
    Constructor CreateBrowseAndDocItThread(
      SuccessfulParseProc : TParserNotify;
      EditorInfo : TEditorInformation;
      RenderDocumentTree : TRenderDocumentTree;
      ThreadExceptionMsg : TThreadExceptionMsg);
    Destructor Destroy; Override;
  End;

  (** This record defines information for use in naming threads. **)
  TThreadNameInfo = record
    FType: LongWord;     // must be 0x1000
    FName: PChar;        // pointer to name (in user address space)
    FThreadID: LongWord; // thread ID (-1 indicates caller thread)
    FFlags: LongWord;    // reserved for future use, must be zero
  end;

  (** An enumerate to define the type of comment output that can be generated by
      WriteComment. **)
  TCommentType = (ctPascalBlock, ctPascalBrace, ctCPPBlock, ctCPPLine, ctVBLine);

  Function FindFunction(iLine : Integer; Container : TElementContainer;
    ContainerClass : TGenericFunctionClass) : TGenericFunction;
  Function Description(Func : TGenericFunction; iIndent : Integer;
    boolPadOut : Boolean; var CursorAdjust : TPoint) : String;
  Function Indent(strText : String; iIndent : Integer) : String;
  Function OutputTag(iIndent : Integer; Tag : TTag) : String;
  Function WriteComment(Func : TGenericFunction; CommentType : TCommentType;
    iIndent : Integer; boolPadOut : Boolean; var CursorDelta : TPoint) : String;
  Function FindIndentOfFirstTokenOnLine(Module : TBaseLanguageModule;
    iLine : Integer) : Integer;

Const
  (** A simple array for outputting a or an. **)
  strAOrAn : Array[False..True] Of String = ('a', 'an');
  (** An array of parameter modifier phases. **)
  strModifier : Array[pamNone..pamOut] Of String = ('', ' as a reference',
    ' as a constant', ' as an out parameter');
  (** A list of vowels. **)
  strVowels : Set Of Char = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];
  (** A constant array of outputs for the ArrayOf property. **)
  strArrayOf : Array[False..True] Of String = ('', 'Array Of ');

ResourceString
  (** This is a message for no methods to comment. **)
  strNoMethodFound = 'No method found on or above the current cursor position.';
  (** This is a message to confirm you wish to update the current comment. **)
  strMethodAlreadyExists = 'The method "%s" already has a comment. Do you' +
  ' want to update the comment with revised parameters and returns?';
  (** This is a message for no property to comment. **)
  strNoPropertyFound = 'No property found on or above the current cursor position.';
  (** This is a message to confirm you wish to update the current comment. **)
  strPropertyAlreadyExists = 'The property "%s" already has a comment. Do you' +
  ' want to continue?';

Implementation

uses
  DGHLibrary, ModuleDispatcher {$IFDEF EUREKALOG}, ExceptionLog {$ENDIF};

Const
  (** A constant to define the maximim width of a comment in the source code. **)
  iMaxCommentWidth : Integer = 80;
  (** A constant to define the with of the tag formatting in method / property
      comments. **)
  iTagWidth : Integer = 8;

(**

  This method recursively works throug the hierarchy of elements looking for the
  method which is closest to be on or just above the current cursor line.

  @precon  Container must be a valid TElementContainer instance.
  @postcon Recursively works throug the hierarchy of elements looking for the 
           method which is closest to be on or just above the current cursor 
           line.

  @param   iLine          as an Integer
  @param   Container      as a TElementContainer
  @param   ContainerClass as a TGenericFunctionClass
  @return  a TgenericFunction

**)
Function FindFunction(iLine : Integer; Container : TElementContainer;
  ContainerClass : TGenericFunctionClass) : TGenericFunction;

Var
  i : Integer;
  M : TGenericFunction;

  (**

    This procedure updates the result with the new method if it is less than
    iLine but more than the last method found.

    @precon  None.
    @postcon Updates the result with the new method if it is less than
             iLine but more than the last method found.

  **)
  Procedure CheckLine;

  Begin
    If M <> Nil Then
      If (M.Line <= iLine) Then
        Begin
          If Result = Nil Then
            Result := M
          Else
            If M.Line > Result.Line Then
              Result := M;
        End;
  End;

Begin
  Result := Nil;
  For i := 1 To Container.ElementCount Do
    Begin
      If Container.Elements[i] Is ContainerClass Then
        Begin
          M := Container.Elements[i] As TGenericFunction;
          CheckLine;
        End;
      If Container.Elements[i].ElementCount > 0 Then
        Begin
          M := FindFunction(iLine, Container.Elements[i], ContainerClass);
          CheckLine;
        End;
    End;
End;

(**

  This method returns a description for the method if it is a constructor,
  destructor, getter or setter method, else it returns an empty String.

  @precon  Method is a valid instance of a method declatation to be described.
  @postcon Returns a description of the method is applicable. CursorAdjust
           provide delta movements for the cursor from column 1 if the first
           line of the new comment.

  @param   Func        as a TGenericFunction
  @param   iIndent      as an Integer
  @param   boolPadOut   as a Boolean
  @param   CursorAdjust as a TPoint as a reference
  @return  a String      

**)
function Description(Func : TGenericFunction; iIndent : Integer;
  boolPadOut : Boolean; var CursorAdjust : TPoint) : String;

var
  i: Integer;
  boolCon: Boolean;
  strDescription : String;
  j: Integer;
  MD : TStringList;
  C: TComment;

begin
  CursorAdjust.X := 0;
  CursorAdjust.Y := 0;
  If Func.Comment = Nil Then
    Begin
      MD := BrowseAndDocItOptions.MethodDescriptions;
      For i := 0 To MD.Count - 1 Do
        If Like(MD.Names[i], Func.Identifier) Then
          Begin
            C := TComment.Create(MD.ValueFromIndex[i], 0, 0);
            Try
              strDescription := Indent(C.AsString(
                iMaxCommentWidth - iIndent - 2, True), iIndent + 2);
              If Pos('|', strDescription) > 0 Then
                For j := 1 To Length(strDescription) Do
                  Begin
                    If strDescription[j] = '|' Then
                      Begin
                        Delete(strDescription, j, 1);
                        Break;
                      End;
                    If strDescription[j] <> #10 Then
                      Inc(CursorAdjust.X);
                    If strDescription[j] = #13 Then
                      Begin
                        Inc(CursorAdjust.Y);
                        CursorAdjust.X := 0;
                      End;
                  End;
              Break;
            Finally
              C.Free;
            End;
          End;
      Result := Format('%s'#13#10, [strDescription]);
      If boolPadOut Then
        Result := Result + #13#10;
    End Else
    Begin
      Result := Format('%s'#13#10, [
        Indent(Func.Comment.AsString(iMaxCommentWidth - iIndent - 2, True),
        2 + iIndent)]);
      If boolPadOut Then
        Result := Result + #13#10;
      boolCon := False;
      i := Func.Comment.FindTag('precon');
      If i > -1 Then
        Begin
          Result := Result + OutputTag(2 + iIndent, Func.Comment.Tag[i]);
          boolCon := True;
        End;
      i := Func.Comment.FindTag('postcon');
      If i > -1 Then
        Begin
          Result := Result + OutputTag(2 + iIndent, Func.Comment.Tag[i]);
          boolCon := True;
        End;
      If boolCon Then
        If boolPadOut Then
          Result := Result + #13#10;
      boolCon := False;
      For i := 0 To Func.Comment.TagCount - 1 Do
        If Not IsKeyWord(Func.Comment.Tag[i].TagName, ['param', 'postcon', 'precon',
          'return']) Then
          Begin
            Result := Result + OutputTag(2 + iIndent, Func.Comment.Tag[i]);
            boolCon := True;
          End;
      If boolCon Then
        If boolPadOut Then
          Result := Result + #13#10;
    End;
  If strDescription = '' Then
    CursorAdjust.X := 2 + iIndent;
end;

(**

  This function indent the text for a description.

  @precon  None.
  @postcon Returns an indented version of the passed text.

  @param   strText as a String
  @param   iIndent as an Integer
  @return  a String

**)
Function Indent(strText : String; iIndent : Integer) : String;

Begin
  Result := StringOfChar(#32, iIndent) + StringReplace(strText, #13#10,
    #13#10 + StringOfChar(#32, iIndent), [rfReplaceAll]);
End;

(**


  This function returns the tag information indented and broken into line no
  wider than iMaxCommentWidth characters.

  @precon  Tag must be a valid comment tag.
  @postcon Returns the tag information indented and broken into line no wider
           than iMaxCommentWidth characters.

  @param   iIndent as an Integer
  @param   Tag     as a TTag
  @return  a String

**)
Function OutputTag(iIndent : Integer; Tag : TTag) : String;

Var
  str : String;
  i : Integer;

Begin
  Result := '';
  str := Format('%s@%-*s', [StringOfChar(#32, iIndent), iTagWidth, Tag.TagName]);
  For  i := 0 To Tag.TokenCount - 1 Do
    If Length(str + Tag.Tokens[i].Token) < iMaxCommentWidth Then
      str := str + Tag.Tokens[i].Token
    Else
      Begin
        Result := Result + str;
        str := #13#10 + StringOfChar(#32, iIndent + 9);
        If Tag.Tokens[i].Token <> #32 Then
          str := str + Tag.Tokens[i].Token;
      End;
  Result := Result + str + #13#10;
End;

(**

  This method writes the method comment to the active editor.

  @precon  Method is a valid instance of a method declaration to be commented.
  @postcon The full comment to be inserted at the cursor is returns with the 
           new cursor position in Cursor.

  @param   Func        as a TGenericFunction
  @param   CommentType as a TCommentType
  @param   iIndent     as an Integer
  @param   boolPadOut  as a Boolean
  @param   CursorDelta as a TPoint as a reference
  @return  a String

**)
Function WriteComment(Func : TGenericFunction;  CommentType : TCommentType;
  iIndent : Integer; boolPadOut : Boolean; var CursorDelta : TPoint) : String;

  (**

    This procedure adds text to the resulting comment string.

    @precon  None.
    @postcon Adds text to the resulting comment string.

    @param   strText as a String

  **)
  Procedure AddToComment(strText : String);

  Begin
    Result := Result + strText;
  End;

Var
  iLen : Integer;
  i : Integer;
  strType: String;
  P : TPoint;
  sl: TStringList;
  strInsert: String;
  boolExtraLine : Boolean;

begin
  CursorDelta.X := 0;
  CursorDelta.Y := 0;
  boolExtraLine := False;
  If CommentType In [ctPascalBlock..ctCPPBlock] Then
    AddToComment(StringOfChar(#32, iIndent));
  Case CommentType Of
    ctPascalBlock : AddToComment('(**'#13#10);
    ctPascalBrace : AddToComment('{:'#13#10);
    ctCPPBlock    : AddToComment('/**'#13#10);
  End;
  If boolPadOut Then
    AddToComment(#13#10);
  AddToComment(Description(Func, iIndent, boolPadOut, P));
  iLen := 0;
  boolExtraLine := boolExtraLine Or (Func.ParameterCount > 0);
  For i := 0 To Func.ParameterCount - 1 Do
    If iLen < Length(Func.Parameters[i].Identifier) Then
      iLen := Length(Func.Parameters[i].Identifier);
    For i := 0 To Func.ParameterCount - 1 Do
      Begin
        AddToComment(StringOfChar(#32, iIndent));
        AddToComment(Format('  @param   %-*s as ', [iLen,
          Func.Parameters[i].Identifier]));
        If Func.Parameters[i].ParamType <> Nil Then
          Begin
            strType := Func.Parameters[i].ParamType.AsString(False, False);
            AddToComment(Format('%s %s%s%s'#13#10, [
              strAOrAn[(strType[1] In strVowels) Or Func.Parameters[i].ArrayOf],
              strArrayOf[Func.Parameters[i].ArrayOf], strType,
              strModifier[Func.Parameters[i].ParamModifier]]));
          End;
      End;
  If Func.ReturnType <> Nil Then
    Begin
      boolExtraLine := boolExtraLine Or True;
      AddToComment(StringOfChar(#32, iIndent));
      AddToComment(Format('  @return  %s %s',
        [strAOrAn[Func.ReturnType.AsString(False, False)[1] In strVowels],
        Func.ReturnType.AsString(False, False)]));
      AddToComment(#13#10);
    End;
  // Block Footer
  If boolExtraLine Then
    If boolPadOut Then
      AddToComment(#13#10);
  If CommentType In [ctPascalBlock..ctCPPBlock] Then
    AddToComment(StringOfChar(#32, iIndent));
  Case CommentType Of
    ctPascalBlock : AddToComment('**)'#13#10);
    ctPascalBrace : AddToComment('}'#13#10);
    ctCPPBlock    : AddToComment('**/'#13#10);
  Else
    Case CommentType Of
      ctCPPLine: strInsert := '//:';
      ctVBLine : strInsert := ''':';
    Else
      strInsert := '';
    End;
    sl := TStringList.Create;
    Try
      sl.Text := Result;
      For i := 0 To sl.Count - 1 Do
        If sl[i] <> '' Then
          sl[i] := Copy(sl[i], 1, iIndent) + strInsert +
            Copy(sl[i], iIndent + 1, Length(sl[i]) - iIndent)
        Else
          sl[i] := StringOfChar(#32, iIndent) + strInsert;
      Result := sl.Text;
    Finally
      sl.Free;
    End;
  End;
  Inc(CursorDelta.X, P.X);
  Inc(CursorDelta.Y, 2 + P.Y);
  If CommentType In [ctVBLine] Then
    Inc(CursorDelta.X, 2);
  If CommentType In [ctCPPLine] Then
    Inc(CursorDelta.X, 3);
  If Not boolPadOut Then
    Dec(CursorDelta.Y);
  If CommentType In [ctVBLine, ctCPPLine] Then
    Dec(CursorDelta.Y);
end;

(**

  This function returns the column of the first token on the given line number,
  i.e. the indentation of the code.

  @precon  Module must be a valid instance of a module that is parsed.
  @postcon Returns the column of the first token on the given line number,
           i.e. the indentation of the code.

  @param   Module as a TBaseLanguageModule
  @param   iLine  as an Integer
  @return  an Integer

**)
Function FindIndentOfFirstTokenOnLine(Module : TBaseLanguageModule;
  iLine : Integer) : Integer;

Var
  iToken : Integer;

Begin
  Result := 1;
  For iToken := 0 To Module.TokenCount - 1 Do
    If Module.Tokens[iToken].Line = iLine Then
      Begin
        Result := Module.Tokens[iToken].Column;
        Break;
      End;
End;

{ TBrowseAndDocItThread }

(**

  This is a constructor for the TBrowseAndDocItThread class.

  @precon  None.
  @postcon Creates a suspended thread and sets up a stream with the contents of
           the active editor and then resumed the thread in order to parse 
           the contents.

  @param   SuccessfulParseProc as a TParserNotify
  @param   EditorInfo          as a TEditorInformation
  @param   RenderDocumentTree  as a TRenderDocumentTree
  @param   ThreadExceptionMsg  as a TThreadExceptionMsg

**)
constructor TBrowseAndDocItThread.CreateBrowseAndDocItThread(
  SuccessfulParseProc : TParserNotify;
  EditorInfo : TEditorInformation;
  RenderDocumentTree : TRenderDocumentTree;
  ThreadExceptionMsg : TThreadExceptionMsg);

begin
  Inherited Create(True);
  FreeOnTerminate := True; // Self Freeing...
  FSuccessfulParseProc := SuccessfulParseProc;
  FRenderDocumentTree := RenderDocumentTree;
  FThreadExceptionMsg := ThreadExceptionMsg;
  FMemoryStream := TMemoryStream.Create;
  If Assigned(EditorInfo) Then
    EditorInfo(FFileName, FModified, FMemoryStream);
  Resume;
end;

(**

  This is a destructor for the TBrowseAndDocItThread class.

  @precon  None.
  @postcon Frees the stream memory.

**)
destructor TBrowseAndDocItThread.Destroy;
begin
  FMemoryStream.Free;
  Inherited Destroy;
end;

(**

  This execute method parses the code of the active editor stored in the
  memory stream and render the information in the explorer module.

  @precon  FMemoryStream must be a valid stream of chars to parse.
  @postcon Parses the code of the active editor stored in the memory stream and
           render the information in the explorer module.

**)
procedure TBrowseAndDocItThread.Execute;

begin
  SetName;
  Try
    FType := 'Parsing';
    FModule := Dispatcher(FMemoryStream, FFileName, FModified, [moParse,
      moCheckForDocumentConflicts]);
    Try
      FType := 'Rendering';
      Synchronize(RenderModuleExplorer);
    Finally
      FModule.Free;
    End;
  Except
    On E : EParserAbort Do
      Exit;
    On E : Exception Do
      Begin
        {$IFDEF EUREKALOG}
        StandardEurekaNotify(GetLastExceptionObject, GetLastExceptionAddress);
        If Assigned(FSuccessfulParseProc) Then
          FSuccessfulParseProc(False);
        {$ELSE}
        FFileName := E.Message;
        Synchronize(ShowException);
        {$ENDIF}
      End;
  End;
end;

(**

  This method synchronizes with the main IDE thread and renders the module
  explorer.

  @precon  FModule must be a valid TBaseLanguageModule instance.
  @postcon Synchronizes with the main IDE thread and renders the module
           explorer.

**)
procedure TBrowseAndDocItThread.RenderModuleExplorer;

begin
  If Assigned(FRenderDocumentTree) Then
    FRenderDocumentTree(FModule);
  If Assigned(FSuccessfulParseProc) Then
    FSuccessfulParseProc(True);
end;

(**

  This is a setter method for the  property.

  @precon  None.
  @postcon Sets the name of the thread.

**)
procedure TBrowseAndDocItThread.SetName;

var
  ThreadNameInfo: TThreadNameInfo;

begin
  ThreadNameInfo.FType := $1000;
  ThreadNameInfo.FName := 'BrowseAndDocItThread';
  ThreadNameInfo.FThreadID := $FFFFFFFF;
  ThreadNameInfo.FFlags := 0;
  try
    RaiseException( $406D1388, 0, sizeof(ThreadNameInfo) div sizeof(LongWord),
      @ThreadNameInfo );
  except
  end;
end;

(**

  This method displays the raised exception message pass via the FFileName
  field.

  @precon  None.
  @postcon Displays the raised exception message pass via the FFileName
           field.

**)
procedure TBrowseAndDocItThread.ShowException;

Const
  strMsg = 'Exception in TBrowseAndDocItThread:'#13#10 +
    '  Type: %s'#13#10 +
    '  Exception: %s' ;
begin
  If Assigned(FThreadExceptionMsg) Then
    FThreadExceptionMsg(Format(strMsg, [FType, FFileName]));
  If Assigned(FSuccessfulParseProc) Then
    FSuccessfulParseProc(False);
end;

End.
