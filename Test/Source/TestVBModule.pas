unit TestVBModule;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, Classes, BaseLanguageModule, VBModule, Contnrs, SysUtils,
  Controls, Windows, TestBaseLanguageModule;

type
  // Test methods for class TVBParameter

  TestTVBParameter = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TVBMethod

  TestTVBMethod = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TVBConstant

  TestTVBConstant = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TVBVar

  TestTVBVar = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TVBProperty

  TestTVBProperty = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TVBRecordDecl

  TestTVBRecordDecl = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TVBTypeDecl

  TestTVBTypeDecl = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;

  TestTVBModule = Class(TExtendedTestCase)
  Strict Private
  Public
  Published
    Procedure TestVersion;
    Procedure TestAttributes;
    Procedure TestFunctions;
    Procedure TestOption;
    Procedure TestConsts;
    Procedure TestVars;
    Procedure TestSubs;
    Procedure TestDeclares;
    Procedure TestProperties;
    Procedure TestRecords;
    Procedure TestEnums;
    Procedure TestCombinations;
    Procedure TestFailure01;
  End;

implementation

Uses
  ModuleDispatcher;

procedure TestTVBParameter.TestAsString;

Var
  P : TVBParameter;
  ST : TVBTypeDecl;

begin
  ST := TVBTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    ST.AddToken('Double');
    P := TVBParameter.Create(pamNone, 'Identifier', False, ST, '', scNone, 10, 12);
    Try
      CheckEquals('Identifier As Double', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    ST.Free;
  End;
  ST := TVBTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    ST.AddToken('MSForms');
    ST.AddToken('.');
    ST.AddToken('Integer');
    P := TVBParameter.Create(pamVar, 'Identifier', False, ST, '', scNone, 10, 12);
    Try
      CheckEquals('ByRef Identifier As MSForms.Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    ST.Free;
  End;
  ST := TVBTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    ST.AddToken('Integer');
    P := TVBParameter.Create(pamConst, 'Identifier', False, ST, '', scNone, 10, 12);
    Try
      CheckEquals('ByVal Identifier As Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    ST.Free;
  End;
  ST := TVBTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    ST.AddToken('Integer');
    P := TVBParameter.Create(pamConst, 'Identifier', False, ST, '0', scNone, 10, 12);
    Try
      CheckEquals('ByVal Identifier As Integer = 0', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    ST.Free;
  End;
  ST := TVBTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    ST.AddToken('String');
    P := TVBParameter.Create(pamConst, 'Identifier', False, ST, '""', scNone, 10, 12);
    Try
      CheckEquals('ByVal Identifier As String = ""', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    ST.Free;
  End;
  ST := TVBTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    ST.AddToken('String');
    P := TVBParameter.Create(pamConst, 'Identifier', False, ST, '"Hello"', scNone, 10, 12);
    Try
      CheckEquals('ByVal Identifier As String = "Hello"', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    ST.Free;
  End;
end;

procedure TestTVBMethod.TestAsString;

Var
  M : TVBMethod;
  T: TVBTypeDecl;

begin
  M := TVBMethod.Create(mtProcedure, 'MyMethod', scPrivate, 10 ,12);
  Try
    CheckEquals('Sub MyMethod()', M.AsString(True, False));
    CheckEquals('Sub MyMethod('#13#10')', M.AsString(True, True));
  Finally
    M.Free;
  End;
  M := TVBMethod.Create(mtFunction, 'MyMethod', scPrivate, 10 ,12);
  Try
    M.ReturnType := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    M.ReturnType.AddToken('String');
    CheckEquals('Function MyMethod() As String', M.AsString(True, False));
    CheckEquals('Function MyMethod('#13#10') As String', M.AsString(True, True));
  Finally
    M.Free;
  End;
  M := TVBMethod.Create(mtFunction, 'MyMethod', scPrivate, 10 ,12);
  Try
    M.ReturnType := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    M.ReturnType.AddToken('MSForms');
    M.ReturnType.AddToken('.');
    M.ReturnType.AddToken('Integer');
    CheckEquals('Function MyMethod() As MSForms.Integer', M.AsString(True, False));
    CheckEquals('Function MyMethod('#13#10') As MSForms.Integer', M.AsString(true, True));
  Finally
    M.Free;
  End;
  M := TVBMethod.Create(mtFunction, 'MyMethod', scPrivate, 10 ,12);
  Try
    M.ReturnType := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('String');
      M.AddParameter(TVBParameter.Create(pamNone, 'Ident1', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    M.ReturnType.AddToken('MSForms');
    M.ReturnType.AddToken('.');
    M.ReturnType.AddToken('Integer');
    CheckEquals('Function MyMethod(Ident1 As String) As MSForms.Integer', M.AsString(True, False));
    CheckEquals('Function MyMethod('#13#10'  Ident1 As String'#13#10') As MSForms.Integer', M.AsString(True, True));
  Finally
    M.Free;
  End;
  M := TVBMethod.Create(mtFunction, 'MyMethod', scPrivate, 10 ,12);
  Try
    M.ReturnType := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('String');
      M.AddParameter(TVBParameter.Create(pamNone, 'Ident1', False, T, '"Hello"', scNone, 10, 12));
    Finally
      T.Free;
    End;
    M.ReturnType.AddToken('MSForms');
    M.ReturnType.AddToken('.');
    M.ReturnType.AddToken('Integer');
    CheckEquals('Function MyMethod(Ident1 As String = "Hello") As MSForms.Integer', M.AsString(True, False));
    CheckEquals('Function MyMethod('#13#10'  Ident1 As String = "Hello"'#13#10') As MSForms.Integer', M.AsString(True, True));
  Finally
    M.Free;
  End;
  M := TVBMethod.Create(mtFunction, 'MyMethod', scPrivate, 10 ,12);
  Try
    M.ReturnType := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('MSForms');
      T.AddToken('.');
      T.AddToken('Integer');
      M.AddParameter(TVBParameter.Create(pamVar, 'Ident1', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('Integer');
      M.AddParameter(TVBParameter.Create(pamConst, 'Ident2', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    M.ReturnType.AddToken('MSForms');
    M.ReturnType.AddToken('.');
    M.ReturnType.AddToken('Integer');
    CheckEquals('Function MyMethod(ByRef Ident1 As MSForms.Integer, ByVal Ident2 As Integer) As MSForms.Integer', M.AsString(True, False));
    CheckEquals('Function MyMethod('#13#10'  ByRef Ident1 As MSForms.Integer,'#13#10'  ByVal Ident2 As Integer'#13#10') As MSForms.Integer', M.AsString(True, True));
  Finally
    M.Free;
  End;
  M := TVBMethod.Create(mtFunction, 'MyMethod', scPrivate, 10 ,12);
  Try
    M.Ext := '"Kernal32"';
    M.ReturnType := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('String');
      M.AddParameter(TVBParameter.Create(pamNone, 'Ident1', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    M.ReturnType.AddToken('MSForms');
    M.ReturnType.AddToken('.');
    M.ReturnType.AddToken('Integer');
    CheckEquals('Function MyMethod Lib "Kernal32" (Ident1 As String) As MSForms.Integer', M.AsString(True, False));
    CheckEquals('Function MyMethod Lib "Kernal32" ('#13#10'  Ident1 As String'#13#10') As MSForms.Integer', M.AsString(True, True));
  Finally
    M.Free;
  End;
end;

procedure TestTVBConstant.TestAsString;

var
  C : TVBConstant;

begin
  C := TVBConstant.Create('Identifier', scPublic, 10, 12, iiPublicConstant, Nil);
  Try
    C.AddToken('Integer');
    CheckEquals('Identifier As Integer', C.AsString(True, False));
  Finally
    C.Free;
  End;
  C := TVBConstant.Create('Identifier', scPublic, 10, 12, iiPublicConstant, Nil);
  Try
    C.AddToken('MSForms');
    C.AddToken('.');
    C.AddToken('Integer');
    CheckEquals('Identifier As MSForms.Integer', C.AsString(True, False));
  Finally
    C.Free;
  End;
  C := TVBConstant.Create('Identifier', scPublic, 10, 12, iiPublicConstant, Nil);
  Try
    C.AddToken('MSForms');
    C.AddToken('.');
    C.AddToken('Integer');
    C.AddToken('=');
    C.AddToken('44');
    CheckEquals('Identifier As MSForms.Integer = 44', C.AsString(True, False));
  Finally
    C.Free;
  End;
end;

procedure TestTVBVar.TestAsString;

var
  V : TVBVar;

begin
  V := TVBVar.Create('Identifier', scPrivate, 10, 12, iiPublicVariable, Nil);
  Try
    V.AddToken('String');
    CheckEquals('Identifier As String', V.AsString(True, False));
  Finally
    V.Free;
  End;
  V := TVBVar.Create('Identifier', scPrivate, 10, 12, iiPublicVariable, Nil);
  Try
    V.AddToken('MSForms');
    V.AddToken('.');
    V.AddToken('String');
    CheckEquals('Identifier As MSForms.String', V.AsString(True, False));
  Finally
    V.Free;
  End;
  V := TVBVar.Create('Identifier', scPrivate, 10, 12, iiPublicVariable, Nil);
  Try
    V.AddToken('String');
    V.WithEvents := True;
    CheckEquals('WithEvents Identifier As String', V.AsString(True, False));
  Finally
    V.Free;
  End;
  V := TVBVar.Create('Identifier', scPrivate, 10, 12, iiPublicVariable, Nil);
  Try
    V.AddDimension('', '');
    V.AddToken('String');
    CheckEquals('Identifier() As String', V.AsString(True, False));
  Finally
    V.Free;
  End;
  V := TVBVar.Create('Identifier', scPrivate, 10, 12, iiPublicVariable, Nil);
  Try
    V.AddDimension('1', '10');
    V.AddToken('MSForms');
    V.AddToken('.');
    V.AddToken('String');
    CheckEquals('Identifier(1 to 10) As MSForms.String', V.AsString(True, False));
  Finally
    V.Free;
  End;
  V := TVBVar.Create('Identifier', scPrivate, 10, 12, iiPublicVariable, Nil);
  Try
    V.AddDimension('1', '2');
    V.AddDimension('0', '4');
    V.AddToken('String');
    CheckEquals('Identifier(1 to 2, 0 to 4) As String', V.AsString(True, False));
  Finally
    V.Free;
  End;
end;

procedure TestTVBProperty.TestAsString;

var
  P : TVBProperty;
  T : TVBTypeDecl;

begin
  P := TVBProperty.Create(ptLet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    CheckEquals('Property Let MyProperty()', P.AsString(True, False));
    CheckEquals('Property Let MyProperty('#13#10')', P.AsString(True, True));
  Finally
    P.Free;
  End;
  P := TVBProperty.Create(ptSet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    CheckEquals('Property Set MyProperty()', P.AsString(True, False));
    CheckEquals('Property Set MyProperty('#13#10')', P.AsString(True, True));
  Finally
    P.Free;
  End;
  P := TVBProperty.Create(ptGet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    P.TypeID := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    P.TypeID.AddToken('String');
    CheckEquals('Property Get MyProperty() As String', P.AsString(True, False));
    CheckEquals('Property Get MyProperty('#13#10') As String', P.AsString(True, True));
  Finally
    P.Free;
  End;
  P := TVBProperty.Create(ptGet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    P.TypeId := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    P.TypeId.AddToken('MSForms');
    P.TypeId.AddToken('.');
    P.TypeId.AddToken('Integer');
    CheckEquals('Property Get MyProperty() As MSForms.Integer', P.AsString(True, False));
    CheckEquals('Property Get MyProperty('#13#10') As MSForms.Integer', P.AsString(True, True));
  Finally
    P.Free;
  End;
  P := TVBProperty.Create(ptGet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    P.TypeId := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('String');
      P.AddParameter(TVBParameter.Create(pamNone, 'Ident1', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    P.TypeId.AddToken('MSForms');
    P.TypeId.AddToken('.');
    P.TypeId.AddToken('Integer');
    CheckEquals('Property Get MyProperty(Ident1 As String) As MSForms.Integer', P.AsString(True, False));
    CheckEquals('Property Get MyProperty('#13#10'  Ident1 As String'#13#10') As MSForms.Integer', P.AsString(True, True));
  Finally
    P.Free;
  End;
  P := TVBProperty.Create(ptGet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    P.TypeId := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('String');
      P.AddParameter(TVBParameter.Create(pamVar, 'Ident1', False, T, '""', scNone, 10, 12));
    Finally
      T.Free;
    End;
    P.TypeId.AddToken('MSForms');
    P.TypeId.AddToken('.');
    P.TypeId.AddToken('Integer');
    CheckEquals('Property Get MyProperty(ByRef Ident1 As String = "") As MSForms.Integer', P.AsString(True, False));
    CheckEquals('Property Get MyProperty('#13#10'  ByRef Ident1 As String = ""'#13#10') As MSForms.Integer', P.AsString(True, True));
  Finally
    P.Free;
  End;
  P := TVBProperty.Create(ptGet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    P.TypeId := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('MSForms');
      T.AddToken('.');
      T.AddToken('Integer');
      P.AddParameter(TVBParameter.Create(pamVar, 'Ident1', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('Integer');
      P.AddParameter(TVBParameter.Create(pamConst, 'Ident2', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    P.TypeId.AddToken('MSForms');
    P.TypeId.AddToken('.');
    P.TypeId.AddToken('Integer');
    CheckEquals('Property Get MyProperty(ByRef Ident1 As MSForms.Integer, ByVal Ident2 As Integer) As MSForms.Integer', P.AsString(True, False));
    CheckEquals('Property Get MyProperty('#13#10'  ByRef Ident1 As MSForms.Integer,'#13#10'  ByVal Ident2 As Integer'#13#10') As MSForms.Integer', P.AsString(True, True));
  Finally
    P.Free;
  End;
end;

procedure TestTVBRecordDecl.TestAsString;

Var
  R : TVBRecordDecl;

begin
  R := TVBRecordDecl.Create('Identifier', scProtected, 12, 13, iiPublicRecord, Nil);
  Try
    CheckEquals('Type Identifier', R.AsString(True, False));
  Finally
    R.Free;
  End;
end;

procedure TestTVBTypeDecl.TestAsString;

Var
  T : TVBTypeDecl;

begin
  T := TVBTypeDecl.Create('temp', scNone, 0, 0, iiNone, Nil);
  Try
    T.AddToken('MSForm');
    CheckEquals('MSForm', T.AsString(True, False));
  Finally
    T.Free;
  End;
  T := TVBTypeDecl.Create('temp', scNone, 0, 0, iiNone, Nil);
  Try
    T.AddToken('MSForm');
    T.AddToken('.');
    T.AddToken('Integer');
    CheckEquals('MSForm.Integer', T.AsString(True, False));
  Finally
    T.Free;
  End;
end;

{ TestTVBModule }

procedure TestTVBModule.TestAttributes;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Attribute VB_Name = "frmWireRunWizard"'#13#10 +
      'Attribute VB_GlobalNameSpace = False'#13#10 +
      'Attribute VB_Creatable = False'#13#10 +
      'Attribute VB_PredeclaredId = True'#13#10 +
      'Attribute VB_Exposed = False'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(5, M.HeadingCount(strAttributesLabel));
      CheckEquals(scNone, M.FindElement(strAttributesLabel).Elements[1].Scope);
      CheckEquals(scNone, M.FindElement(strAttributesLabel).Elements[2].Scope);
      CheckEquals(scNone, M.FindElement(strAttributesLabel).Elements[3].Scope);
      CheckEquals(scNone, M.FindElement(strAttributesLabel).Elements[4].Scope);
      CheckEquals(scNone, M.FindElement(strAttributesLabel).Elements[5].Scope);
      // Remember these are now sorted...
      CheckEquals('VB_Creatable = False', M.FindElement(strAttributesLabel).Elements[1].AsString(True, False));
      CheckEquals('VB_Exposed = False', M.FindElement(strAttributesLabel).Elements[2].AsString(True, False));
      CheckEquals('VB_GlobalNameSpace = False', M.FindElement(strAttributesLabel).Elements[3].AsString(True, False));
      CheckEquals('VB_Name = "frmWireRunWizard"', M.FindElement(strAttributesLabel).Elements[4].AsString(True, False));
      CheckEquals('VB_PredeclaredId = True', M.FindElement(strAttributesLabel).Elements[5].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestCombinations;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'VERSION 5.00'#13#10 +
      'Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} frmWireRunWizard'#13#10 +
      '   Caption         =   "Wire Run Wizard"'#13#10 +
      '   ClientHeight    =   4620'#13#10 +
      '   ClientLeft      =   45'#13#10 +
      '   ClientTop       =   435'#13#10 +
      '   ClientWidth     =   6180'#13#10 +
      '   OleObjectBlob   =   "frmWireRunWizard.frx":0000'#13#10 +
      '   StartUpPosition =   1  ''CenterOwner'#13#10 +
      'End'#13#10 +
      'Attribute VB_Name = "frmWireRunWizard"'#13#10 +
      'Attribute VB_GlobalNameSpace = False'#13#10 +
      'Attribute VB_Creatable = False'#13#10 +
      'Attribute VB_PredeclaredId = True'#13#10 +
      'Attribute VB_Exposed = False'#13#10 +
      ''#13#10 +
      ''''#13#10 +
      ''' Hello'#13#10 +
      ''' @Something Else'#13#10 +
      ''''#13#10 +
      'Option Explicit'#13#10 +
      'Option Compare Text'#13#10 +
      'Option Private Module'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.frm', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);

      CheckEquals(1, M.HeadingCount(strVersionLabel));
      CheckEquals(5, M.HeadingCount(strAttributesLabel));
      CheckEquals(3, M.HeadingCount(strOptionsLabel));

      CheckEquals(scNone, M.FindElement(strVersionLabel).Elements[1].Scope);
      CheckEquals(scNone, M.FindElement(strAttributesLabel).Elements[3].Scope);
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[2].Scope);

      CheckEquals('VB_GlobalNameSpace = False', M.FindElement(strAttributesLabel).Elements[3].AsString(True, False));
      CheckEquals('VERSION 5.00', M.FindElement(strVersionLabel).Elements[1].AsString(True, False));
      CheckEquals('ClientTop = 435', M.FindElement(strVersionLabel).Elements[1].Elements[4].AsString(True, False));
      CheckEquals('Explicit', M.FindElement(strOptionsLabel).Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      ''#13#10 +
      ''''#13#10 +
      ''' Hello'#13#10 +
      ''' @Something Else'#13#10 +
      ''''#13#10 +
      'Option Explicit'#13#10 +
      'Option Compare Text'#13#10 +
      'Option Private Module'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.frm', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);

      CheckEquals(0, M.HeadingCount(strVersionLabel));
      CheckEquals(0, M.HeadingCount(strAttributesLabel));
      CheckEquals(3, M.HeadingCount(strOptionsLabel));

      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[2].Scope);

      CheckEquals('Explicit', M.FindElement(strOptionsLabel).Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestConsts;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Const iLong As Long'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPublic, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals('iLong As Long', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Const iLong As Long'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPrivate, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals('iLong As Long', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Const iLong As Long'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPublic, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals('iLong As Long', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Const strText As String = "Hello"'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPublic, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals('strText As String = "Hello"', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Const iLong As Long = 123'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPrivate, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals('iLong As Long = 123', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Const iLong As Long = &HFF00'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPublic, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals('iLong As Long = &HFF00', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Const iLong1 As Long = &HFF00'#13#10 +
      'Private Const iLong2 As Long = 123'#13#10 +
      'Public Const iLong3 As Long'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(3, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPublic, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals(scPrivate, M.FindElement(strConstantsLabel).Elements[2].Scope);
      CheckEquals(scPublic, M.FindElement(strConstantsLabel).Elements[3].Scope);
      CheckEquals('iLong1 As Long = &HFF00', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
      CheckEquals('iLong2 As Long = 123', M.FindElement(strConstantsLabel).Elements[2].AsString(True, False));
      CheckEquals('iLong3 As Long', M.FindElement(strConstantsLabel).Elements[3].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestDeclares;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Declare Sub Test Lib "Kernal32" ()'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals('Sub Test Lib "Kernal32" ()', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Sub Test Lib "Kernal32" Alias "TestA" ()'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals('Sub Test Lib "Kernal32" Alias "TestA" ()', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Sub Test Lib "Kernal32" Alias "TestA" (i As Long)'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals('Sub Test Lib "Kernal32" Alias "TestA" (i As Long)', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Sub Test1 Lib "Kernal32" Alias "TestA" ()'#13#10 +
      'Private Declare Sub Test2 Lib "Kernal32" Alias "TestA" (i As Long)'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(2, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals(scPrivate, M.FindElement(strDeclaresLabel).Elements[2].Scope);
      CheckEquals('Sub Test1 Lib "Kernal32" Alias "TestA" ()', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
      CheckEquals('Sub Test2 Lib "Kernal32" Alias "TestA" (i As Long)', M.FindElement(strDeclaresLabel).Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Function Test Lib "Kernal32" () As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals('Function Test Lib "Kernal32" () As String', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Function Test Lib "Kernal32" Alias "TestA" () As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals('Function Test Lib "Kernal32" Alias "TestA" () As String', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Function Test Lib "Kernal32" Alias "TestA" (i As Long) As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals('Function Test Lib "Kernal32" Alias "TestA" (i As Long) As String', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Function Test1 Lib "Kernal32" Alias "TestA" () As Long'#13#10 +
      'Private Declare Function Test2 Lib "Kernal32" Alias "TestA" (i As Long) As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(2, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals(scPrivate, M.FindElement(strDeclaresLabel).Elements[2].Scope);
      CheckEquals('Function Test1 Lib "Kernal32" Alias "TestA" () As Long', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
      CheckEquals('Function Test2 Lib "Kernal32" Alias "TestA" (i As Long) As String', M.FindElement(strDeclaresLabel).Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestEnums;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Enum THello'#13#10 +
      '  FID = 1'#13#10 +
      '  FName = 2'#13#10 +
      'End Enum'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strTypesLabel));
      CheckEquals(scPublic, M.FindElement(strTypesLabel).Elements[1].Scope);
      CheckEquals('Enum THello', M.FindElement(strTypesLabel).Elements[1].AsString(True, False));
      CheckEquals('FID = 1', M.FindElement(strTypesLabel).Elements[1].Elements[1].AsString(True, False));
      CheckEquals('FName = 2', M.FindElement(strTypesLabel).Elements[1].Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Enum THello'#13#10 +
      '  FID'#13#10 +
      '  FName'#13#10 +
      'End Enum'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strTypesLabel));
      CheckEquals(scPrivate, M.FindElement(strTypesLabel).Elements[1].Scope);
      CheckEquals('Enum THello', M.FindElement(strTypesLabel).Elements[1].AsString(True, False));
      CheckEquals('FID', M.FindElement(strTypesLabel).Elements[1].Elements[1].AsString(True, False));
      CheckEquals('FName', M.FindElement(strTypesLabel).Elements[1].Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestFailure01;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

Begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Type RECT'#13#10 +
      '  ''Specifies the x-coordinate of the upper-left corner of the rectangle.'#13#10 +
      '  Left As Long'#13#10 +
      '  ''Specifies the y-coordinate of the upper-left corner of the rectangle.'#13#10 +
      '  Top As Long'#13#10 +
      '  ''Specifies the x-coordinate of the lower-right corner of the rectangle.'#13#10 +
      '  Right As Long'#13#10 +
      '  ''Specifies the y-coordinate of the lower-right corner of the rectangle.'#13#10 +
      '  Bottom As Long'#13#10 +
      'End Type'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strTypesLabel));
      CheckEquals(scPublic, M.FindElement(strTypesLabel).Elements[1].Scope);
      CheckEquals('Type RECT', M.FindElement(strTypesLabel).Elements[1].AsString(True, False));
      CheckEquals('Left As Long', M.FindElement(strTypesLabel).Elements[1].Elements[2].AsString(True, False));
      CheckEquals('Top As Long', M.FindElement(strTypesLabel).Elements[1].Elements[4].AsString(True, False));
      CheckEquals('Right As Long', M.FindElement(strTypesLabel).Elements[1].Elements[3].AsString(True, False));
      CheckEquals('Bottom As Long', M.FindElement(strTypesLabel).Elements[1].Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestFunctions;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Function Test() As Long'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Function Test() As Long', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Function Test(i as long) As Long'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPrivate, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Function Test(i As long) As Long', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Friend Function Test(i as long) As Long'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scFriend, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Function Test(i As long) As Long', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Function Test(Optional i as long = 0) As Long'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Function Test(Optional i As long = 0) As Long', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Function Test(i as msforms.long, str as String) As Long'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Function Test(i As msforms.long, str As String) As Long', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Function Test(ParamArray i as long) As MSForms.Integer'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Function Test(ParamArray i As long) As MSForms.Integer', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Function Test1(i as msforms.long, str as String) As Long'#13#10 +
      'End Function'#13#10 +
      'Private Function Test2(i as msforms.long) As Long'#13#10 +
      'End Function'#13#10 +
      'Function Test3(Optional i as Long = 0) As Long'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(3, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals(scPrivate, M.FindElement(strImplementedMethodsLabel).Elements[2].Scope);
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[3].Scope);
      CheckEquals('Function Test1(i As msforms.long, str As String) As Long', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
      CheckEquals('Function Test2(i As msforms.long) As Long', M.FindElement(strImplementedMethodsLabel).Elements[2].AsString(True, False));
      CheckEquals('Function Test3(Optional i As Long = 0) As Long', M.FindElement(strImplementedMethodsLabel).Elements[3].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestOption;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Option Base 1'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Base 1', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Base 0'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Base 0', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Compare Binary'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Compare Binary', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Compare Database'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Compare Database', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Compare Text'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Compare Text', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Explicit'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Explicit', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Private Module'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Private Module', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Explicit'#13#10 +
      'Option Compare Text'#13#10 +
      'Option Private Module'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(3, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[2].Scope);
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[3].Scope);
      CheckEquals('Compare Text', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
      CheckEquals('Explicit', M.FindElement(strOptionsLabel).Elements[2].AsString(True, False));
      CheckEquals('Private Module', M.FindElement(strOptionsLabel).Elements[3].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestProperties;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Property Get Test() As String'#13#10 +
      'End Property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strPropertiesLabel));
      CheckEquals(scPublic, M.FindElement(strPropertiesLabel).Elements[1].Scope);
      CheckEquals('Property Get Test() As String', M.FindElement(strPropertiesLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Property Let Test(i As Long)'#13#10 +
      'End Property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strPropertiesLabel));
      CheckEquals(scPrivate, M.FindElement(strPropertiesLabel).Elements[1].Scope);
      CheckEquals('Property Let Test(i As Long)', M.FindElement(strPropertiesLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Friend Property Let Test(i As Long)'#13#10 +
      'End Property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strPropertiesLabel));
      CheckEquals(scFriend, M.FindElement(strPropertiesLabel).Elements[1].Scope);
      CheckEquals('Property Let Test(i As Long)', M.FindElement(strPropertiesLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Property Set Test(Obj As TObject)'#13#10 +
      'End Property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strPropertiesLabel));
      CheckEquals(scPublic, M.FindElement(strPropertiesLabel).Elements[1].Scope);
      CheckEquals('Property Set Test(Obj As TObject)', M.FindElement(strPropertiesLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Property Let Test1(i As Long)'#13#10 +
      'End Property'#13#10 +
      'Public Property Set Test2(Obj As TObject)'#13#10 +
      'End Property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(2, M.HeadingCount(strPropertiesLabel));
      CheckEquals(scPrivate, M.FindElement(strPropertiesLabel).Elements[1].Scope);
      CheckEquals(scPublic, M.FindElement(strPropertiesLabel).Elements[2].Scope);
      CheckEquals('Property Let Test1(i As Long)', M.FindElement(strPropertiesLabel).Elements[1].AsString(True, False));
      CheckEquals('Property Set Test2(Obj As TObject)', M.FindElement(strPropertiesLabel).Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestRecords;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Type THello'#13#10 +
      '  FID As Long'#13#10 +
      '  FName As String'#13#10 +
      'End Type'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strTypesLabel));
      CheckEquals(scPublic, M.FindElement(strTypesLabel).Elements[1].Scope);
      CheckEquals('Type THello', M.FindElement(strTypesLabel).Elements[1].AsString(True, False));
      CheckEquals('FID As Long', M.FindElement(strTypesLabel).Elements[1].Elements[1].AsString(True, False));
      CheckEquals('FName As String', M.FindElement(strTypesLabel).Elements[1].Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Type THello'#13#10 +
      '  FID As Long'#13#10 +
      '  FName As String'#13#10 +
      'End Type'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strTypesLabel));
      CheckEquals(scPrivate, M.FindElement(strTypesLabel).Elements[1].Scope);
      CheckEquals('Type THello', M.FindElement(strTypesLabel).Elements[1].AsString(True, False));
      CheckEquals('FID As Long', M.FindElement(strTypesLabel).Elements[1].Elements[1].AsString(True, False));
      CheckEquals('FName As String', M.FindElement(strTypesLabel).Elements[1].Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestSubs;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Sub Test()'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Sub Test()', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Sub Test(i as long)'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPrivate, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Sub Test(i As long)', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Friend Sub Test(i as long)'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scFriend, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Sub Test(i As long)', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Sub Test(Optional i as long = 0)'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Sub Test(Optional i As long = 0)', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Sub Test(i as msforms.long, str as String)'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Sub Test(i As msforms.long, str As String)', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Sub Test(ParamArray i as long)'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Sub Test(ParamArray i As long)', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Sub Test1(i as msforms.long, str as String)'#13#10 +
      'End Sub'#13#10 +
      'Private Sub Test2(i as msforms.long)'#13#10 +
      'End Sub'#13#10 +
      'Sub Test3(Optional i as Long = 0)'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(3, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals(scPrivate, M.FindElement(strImplementedMethodsLabel).Elements[2].Scope);
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[3].Scope);
      CheckEquals('Sub Test1(i As msforms.long, str As String)', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
      CheckEquals('Sub Test2(i As msforms.long)', M.FindElement(strImplementedMethodsLabel).Elements[2].AsString(True, False));
      CheckEquals('Sub Test3(Optional i As Long = 0)', M.FindElement(strImplementedMethodsLabel).Elements[3].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestVars;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Dim strText As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText As String', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private strText As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPrivate, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText As String', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public strText As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText As String', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private strText() As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPrivate, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText() As String', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public strText(1 to 10) As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText(1 to 10) As String', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private strText(1 to 10, 1 to 2) As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPrivate, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText(1 to 10, 1 to 2) As String', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public strText(1 to 10, 1 to 2) As MSForms.Integer'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText(1 to 10, 1 to 2) As MSForms.Integer', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public WithEvents strText As Integer'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('WithEvents strText As Integer', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public strText1 As Integer'#13#10 +
      'Private strText2 As String'#13#10 +
      'Dim strText3 As Double'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(3, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals(scPrivate, M.FindElement(strVarsLabel).Elements[2].Scope);
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[3].Scope);
      CheckEquals('strText1 As Integer', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
      CheckEquals('strText2 As String', M.FindElement(strVarsLabel).Elements[2].AsString(True, False));
      CheckEquals('strText3 As Double', M.FindElement(strVarsLabel).Elements[3].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public strText1 As Integer, strText2 As String'#13#10 +
      'Dim strText3 As Double'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(3, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[2].Scope);
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[3].Scope);
      CheckEquals('strText1 As Integer', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
      CheckEquals('strText2 As String', M.FindElement(strVarsLabel).Elements[2].AsString(True, False));
      CheckEquals('strText3 As Double', M.FindElement(strVarsLabel).Elements[3].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestVersion;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'VERSION 1.0 CLASS'#13#10 +
      'BEGIN'#13#10 +
      '  Multiuse = -1  ''True'#13#10 +
      'END'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVersionLabel));
      CheckEquals(scNone, M.FindElement(strVersionLabel).Elements[1].Scope);
      CheckEquals('VERSION 1.0 CLASS', M.FindElement(strVersionLabel).Elements[1].AsString(True, False));
      CheckEquals('Multiuse = - 1', M.FindElement(strVersionLabel).Elements[1].Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'VERSION 5.00'#13#10 +
      'Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} frmWireRunWizard'#13#10 +
      '   Caption         =   "Wire Run Wizard"'#13#10 +
      '   ClientHeight    =   4620'#13#10 +
      '   ClientLeft      =   45'#13#10 +
      '   ClientTop       =   435'#13#10 +
      '   ClientWidth     =   6180'#13#10 +
      '   OleObjectBlob   =   "frmWireRunWizard.frx":0000'#13#10 +
      '   StartUpPosition =   1  ''CenterOwner'#13#10 +
      'End'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Frm', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVersionLabel));
      CheckEquals(scNone, M.FindElement(strVersionLabel).Elements[1].Scope);
      CheckEquals('VERSION 5.00', M.FindElement(strVersionLabel).Elements[1].AsString(True, False));
      CheckEquals('Caption = "Wire Run Wizard"', M.FindElement(strVersionLabel).Elements[1].Elements[1].AsString(True, False));
      CheckEquals('ClientHeight = 4620', M.FindElement(strVersionLabel).Elements[1].Elements[2].AsString(True, False));
      CheckEquals('ClientLeft = 45', M.FindElement(strVersionLabel).Elements[1].Elements[3].AsString(True, False));
      CheckEquals('ClientTop = 435', M.FindElement(strVersionLabel).Elements[1].Elements[4].AsString(True, False));
      CheckEquals('ClientWidth = 6180', M.FindElement(strVersionLabel).Elements[1].Elements[5].AsString(True, False));
      CheckEquals('OleObjectBlob = "frmWireRunWizard.frx" : 0000', M.FindElement(strVersionLabel).Elements[1].Elements[6].AsString(True, False));
      CheckEquals('StartUpPosition = 1', M.FindElement(strVersionLabel).Elements[1].Elements[7].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest('VB Module Tests', TestTVBParameter.Suite);
  RegisterTest('VB Module Tests', TestTVBMethod.Suite);
  RegisterTest('VB Module Tests', TestTVBConstant.Suite);
  RegisterTest('VB Module Tests', TestTVBVar.Suite);
  RegisterTest('VB Module Tests', TestTVBProperty.Suite);
  RegisterTest('VB Module Tests', TestTVBRecordDecl.Suite);
  RegisterTest('VB Module Tests', TestTVBTypeDecl.Suite);
  RegisterTest('VB Module Tests', TestTVBModule.Suite);
End.

