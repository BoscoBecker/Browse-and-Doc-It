unit TestVBModule;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, Classes, BaseLanguageModule, VBModule, Contnrs, SysUtils,
  Controls, Windows, TestBaseLanguageModule;

type
  // Test methods for class TVBParameter

  TestTVBParameter = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TVBMethod

  TestTVBMethod = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TVBConstant

  TestTVBConstant = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TVBVar

  TestTVBVar = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TVBProperty

  TestTVBProperty = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TVBRecordDecl

  TestTVBRecordDecl = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TVBTypeDecl

  TestTVBTypeDecl = class(TTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;

  TestTVBModule = Class(TExtendedTestCase)
  Strict Private
  Public
  Published
    Procedure TestVersion;
    Procedure TestAttributes;
    Procedure TestFunctions;
    Procedure TestOption;
    Procedure TestConsts;
    Procedure TestVars;
    Procedure TestSubs;
    Procedure TestDeclares;
    Procedure TestProperties;
    Procedure TestRecords;
    Procedure TestEnums;
    Procedure TestGetComment;
    Procedure TestCheckDocumentation;
    Procedure TestCombinations;
    Procedure TestDisablers;
    Procedure TestFailure01;
    Procedure TestFailure02;
    Procedure TestFailure03;
  End;

  //
  // Test Class for the TVBComment Class Methods.
  //
  TestTVBComment = Class(TTestCase)
  Strict Private
  Public
  Published
    Procedure TestCreateComment;
  End;

  //
  // Test Class for the TExceptionHandling Class Methods.
  //
  TestTExceptionHandling = Class(TExtendedTestCase)
  Strict Private
    FExceptionHandling : TExceptionHandling;
  Public
    Procedure SetUp; Override;
    Procedure TearDown; Override;
  Published
    Procedure TestGetHasErrorHnd;
    Procedure TestGetHasExit;
    Procedure TestGetHasPop;
    Procedure TestGetHasPush;
    Procedure TestGetPushName;
    Procedure TestGetPushParams;
    Procedure TestSetHasErrorHnd;
    Procedure TestSetHasExit;
    Procedure TestSetHasPop;
    Procedure TestSetHasPush;
    Procedure TestSetPushName;
  End;

  //
  // Test Class for the TVBEnumerateDecl Class Methods.
  //
  TestTVBEnumerateDecl = Class(TExtendedTestCase)
  Strict Private
    FVBEnumerateDecl : TVBEnumerateDecl;
  Public
    Procedure SetUp; Override;
    Procedure TearDown; Override;
  Published
    Procedure TestCreate;
    Procedure TestAsString;
  End;

  //
  // Test Class for the TVBEnumIdent Class Methods.
  //
  TestTVBEnumIdent = Class(TExtendedTestCase)
  Strict Private
    FVBEnumIdent : TVBEnumIdent;
  Public
    Procedure SetUp; Override;
    Procedure TearDown; Override;
  Published
    Procedure TestCreate;
    Procedure TestAsString;
  End;

  //
  // Test Class for the TVBField Class Methods.
  //
  TestTVBField = Class(TExtendedTestCase)
  Strict Private
    FVBField : TVBField;
  Public
    Procedure SetUp; Override;
    Procedure TearDown; Override;
  Published
    Procedure TestCreate;
    Procedure TestAsString;
  End;

  //
  // Test Class for the TVBOption Class Methods.
  //
  TestTVBOption = Class(TExtendedTestCase)
  Strict Private
    FVBOption : TVBOption;
  Public
    Procedure SetUp; Override;
    Procedure TearDown; Override;
  Published
    Procedure TestCreate;
    Procedure TestAsString;
  End;

  //
  // Test Class for the TVBVersion Class Methods.
  //
  TestTVBVersion = Class(TExtendedTestCase)
  Strict Private
    FVBVersion : TVBVersion;
  Public
    Procedure SetUp; Override;
    Procedure TearDown; Override;
  Published
    Procedure TestCreate;
    Procedure TestAsString;
  End;

  //
  // Test Class for the TVBAttribute Class Methods.
  //
  TestTVBAttribute = Class(TExtendedTestCase)
  Strict Private
    FVBAttribute : TVBAttribute;
  Public
    Procedure SetUp; Override;
    Procedure TearDown; Override;
  Published
    Procedure TestCreate;
    Procedure TestAsString;
  End;

implementation

Uses
  ModuleDispatcher;

procedure TestTVBParameter.TestAsString;

Var
  P : TVBParameter;
  ST : TVBTypeDecl;

begin
  ST := TVBTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    ST.AddToken('Double');
    P := TVBParameter.Create(pamNone, 'Identifier', False, ST, '', scNone, 10, 12);
    Try
      CheckEquals('Identifier As Double', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    ST.Free;
  End;
  ST := TVBTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    ST.AddToken('MSForms');
    ST.AddToken('.');
    ST.AddToken('Integer');
    P := TVBParameter.Create(pamVar, 'Identifier', False, ST, '', scNone, 10, 12);
    Try
      CheckEquals('ByRef Identifier As MSForms.Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    ST.Free;
  End;
  ST := TVBTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    ST.AddToken('Integer');
    P := TVBParameter.Create(pamConst, 'Identifier', False, ST, '', scNone, 10, 12);
    Try
      CheckEquals('ByVal Identifier As Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    ST.Free;
  End;
  ST := TVBTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    ST.AddToken('Integer');
    P := TVBParameter.Create(pamConst, 'Identifier', False, ST, '0', scNone, 10, 12);
    Try
      CheckEquals('ByVal Identifier As Integer = 0', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    ST.Free;
  End;
  ST := TVBTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    ST.AddToken('String');
    P := TVBParameter.Create(pamConst, 'Identifier', False, ST, '""', scNone, 10, 12);
    Try
      CheckEquals('ByVal Identifier As String = ""', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    ST.Free;
  End;
  ST := TVBTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    ST.AddToken('String');
    P := TVBParameter.Create(pamConst, 'Identifier', False, ST, '"Hello"', scNone, 10, 12);
    Try
      CheckEquals('ByVal Identifier As String = "Hello"', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    ST.Free;
  End;
end;

procedure TestTVBMethod.TestAsString;

Var
  M : TVBMethod;
  T: TVBTypeDecl;

begin
  M := TVBMethod.Create(mtProcedure, 'MyMethod', scPrivate, 10 ,12);
  Try
    CheckEquals('Sub MyMethod()', M.AsString(True, False));
    CheckEquals('Sub MyMethod('#13#10')', M.AsString(True, True));
  Finally
    M.Free;
  End;
  M := TVBMethod.Create(mtFunction, 'MyMethod', scPrivate, 10 ,12);
  Try
    M.ReturnType := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    M.ReturnType.AddToken('String');
    CheckEquals('Function MyMethod() As String', M.AsString(True, False));
    CheckEquals('Function MyMethod('#13#10') As String', M.AsString(True, True));
  Finally
    M.Free;
  End;
  M := TVBMethod.Create(mtFunction, 'MyMethod', scPrivate, 10 ,12);
  Try
    M.ReturnType := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    M.ReturnType.AddToken('MSForms');
    M.ReturnType.AddToken('.');
    M.ReturnType.AddToken('Integer');
    CheckEquals('Function MyMethod() As MSForms.Integer', M.AsString(True, False));
    CheckEquals('Function MyMethod('#13#10') As MSForms.Integer', M.AsString(true, True));
  Finally
    M.Free;
  End;
  M := TVBMethod.Create(mtFunction, 'MyMethod', scPrivate, 10 ,12);
  Try
    M.ReturnType := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('String');
      M.AddParameter(TVBParameter.Create(pamNone, 'Ident1', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    M.ReturnType.AddToken('MSForms');
    M.ReturnType.AddToken('.');
    M.ReturnType.AddToken('Integer');
    CheckEquals('Function MyMethod(Ident1 As String) As MSForms.Integer', M.AsString(True, False));
    CheckEquals('Function MyMethod('#13#10'  Ident1 As String'#13#10') As MSForms.Integer', M.AsString(True, True));
  Finally
    M.Free;
  End;
  M := TVBMethod.Create(mtFunction, 'MyMethod', scPrivate, 10 ,12);
  Try
    M.ReturnType := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('String');
      M.AddParameter(TVBParameter.Create(pamNone, 'Ident1', False, T, '"Hello"', scNone, 10, 12));
    Finally
      T.Free;
    End;
    M.ReturnType.AddToken('MSForms');
    M.ReturnType.AddToken('.');
    M.ReturnType.AddToken('Integer');
    CheckEquals('Function MyMethod(Ident1 As String = "Hello") As MSForms.Integer', M.AsString(True, False));
    CheckEquals('Function MyMethod('#13#10'  Ident1 As String = "Hello"'#13#10') As MSForms.Integer', M.AsString(True, True));
  Finally
    M.Free;
  End;
  M := TVBMethod.Create(mtFunction, 'MyMethod', scPrivate, 10 ,12);
  Try
    M.ReturnType := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('MSForms');
      T.AddToken('.');
      T.AddToken('Integer');
      M.AddParameter(TVBParameter.Create(pamVar, 'Ident1', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('Integer');
      M.AddParameter(TVBParameter.Create(pamConst, 'Ident2', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    M.ReturnType.AddToken('MSForms');
    M.ReturnType.AddToken('.');
    M.ReturnType.AddToken('Integer');
    CheckEquals('Function MyMethod(ByRef Ident1 As MSForms.Integer, ByVal Ident2 As Integer) As MSForms.Integer', M.AsString(True, False));
    CheckEquals('Function MyMethod('#13#10'  ByRef Ident1 As MSForms.Integer,'#13#10'  ByVal Ident2 As Integer'#13#10') As MSForms.Integer', M.AsString(True, True));
  Finally
    M.Free;
  End;
  M := TVBMethod.Create(mtFunction, 'MyMethod', scPrivate, 10 ,12);
  Try
    M.Ext := '"Kernal32"';
    M.ReturnType := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('String');
      M.AddParameter(TVBParameter.Create(pamNone, 'Ident1', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    M.ReturnType.AddToken('MSForms');
    M.ReturnType.AddToken('.');
    M.ReturnType.AddToken('Integer');
    CheckEquals('Function MyMethod Lib "Kernal32" (Ident1 As String) As MSForms.Integer', M.AsString(True, False));
    CheckEquals('Function MyMethod Lib "Kernal32" ('#13#10'  Ident1 As String'#13#10') As MSForms.Integer', M.AsString(True, True));
  Finally
    M.Free;
  End;
end;

procedure TestTVBConstant.TestAsString;

var
  C : TVBConstant;

begin
  C := TVBConstant.Create('Identifier', scPublic, 10, 12, iiPublicConstant, Nil);
  Try
    C.AddToken('Integer');
    CheckEquals('Identifier As Integer', C.AsString(True, False));
  Finally
    C.Free;
  End;
  C := TVBConstant.Create('Identifier', scPublic, 10, 12, iiPublicConstant, Nil);
  Try
    C.AddToken('MSForms');
    C.AddToken('.');
    C.AddToken('Integer');
    CheckEquals('Identifier As MSForms.Integer', C.AsString(True, False));
  Finally
    C.Free;
  End;
  C := TVBConstant.Create('Identifier', scPublic, 10, 12, iiPublicConstant, Nil);
  Try
    C.AddToken('MSForms');
    C.AddToken('.');
    C.AddToken('Integer');
    C.AddToken('=');
    C.AddToken('44');
    CheckEquals('Identifier As MSForms.Integer = 44', C.AsString(True, False));
  Finally
    C.Free;
  End;
end;

procedure TestTVBVar.TestAsString;

var
  V : TVBVar;

begin
  V := TVBVar.Create('Identifier', scPrivate, 10, 12, iiPublicVariable, Nil);
  Try
    V.AddToken('String');
    CheckEquals('Identifier As String', V.AsString(True, False));
  Finally
    V.Free;
  End;
  V := TVBVar.Create('Identifier', scPrivate, 10, 12, iiPublicVariable, Nil);
  Try
    V.AddToken('MSForms');
    V.AddToken('.');
    V.AddToken('String');
    CheckEquals('Identifier As MSForms.String', V.AsString(True, False));
  Finally
    V.Free;
  End;
  V := TVBVar.Create('Identifier', scPrivate, 10, 12, iiPublicVariable, Nil);
  Try
    V.AddToken('String');
    V.WithEvents := True;
    CheckEquals('WithEvents Identifier As String', V.AsString(True, False));
  Finally
    V.Free;
  End;
  V := TVBVar.Create('Identifier', scPrivate, 10, 12, iiPublicVariable, Nil);
  Try
    V.AddDimension('', '');
    V.AddToken('String');
    CheckEquals('Identifier() As String', V.AsString(True, False));
  Finally
    V.Free;
  End;
  V := TVBVar.Create('Identifier', scPrivate, 10, 12, iiPublicVariable, Nil);
  Try
    V.AddDimension('1', '10');
    V.AddToken('MSForms');
    V.AddToken('.');
    V.AddToken('String');
    CheckEquals('Identifier(1 to 10) As MSForms.String', V.AsString(True, False));
  Finally
    V.Free;
  End;
  V := TVBVar.Create('Identifier', scPrivate, 10, 12, iiPublicVariable, Nil);
  Try
    V.AddDimension('1', '2');
    V.AddDimension('0', '4');
    V.AddToken('String');
    CheckEquals('Identifier(1 to 2, 0 to 4) As String', V.AsString(True, False));
  Finally
    V.Free;
  End;
end;

procedure TestTVBProperty.TestAsString;

var
  P : TVBProperty;
  T : TVBTypeDecl;

begin
  P := TVBProperty.Create(ptLet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    CheckEquals('Property Let MyProperty()', P.AsString(True, False));
    CheckEquals('Property Let MyProperty('#13#10')', P.AsString(True, True));
  Finally
    P.Free;
  End;
  P := TVBProperty.Create(ptSet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    CheckEquals('Property Set MyProperty()', P.AsString(True, False));
    CheckEquals('Property Set MyProperty('#13#10')', P.AsString(True, True));
  Finally
    P.Free;
  End;
  P := TVBProperty.Create(ptGet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    P.TypeID := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    P.TypeID.AddToken('String');
    CheckEquals('Property Get MyProperty() As String', P.AsString(True, False));
    CheckEquals('Property Get MyProperty('#13#10') As String', P.AsString(True, True));
  Finally
    P.Free;
  End;
  P := TVBProperty.Create(ptGet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    P.TypeId := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    P.TypeId.AddToken('MSForms');
    P.TypeId.AddToken('.');
    P.TypeId.AddToken('Integer');
    CheckEquals('Property Get MyProperty() As MSForms.Integer', P.AsString(True, False));
    CheckEquals('Property Get MyProperty('#13#10') As MSForms.Integer', P.AsString(True, True));
  Finally
    P.Free;
  End;
  P := TVBProperty.Create(ptGet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    P.TypeId := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('String');
      P.AddParameter(TVBParameter.Create(pamNone, 'Ident1', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    P.TypeId.AddToken('MSForms');
    P.TypeId.AddToken('.');
    P.TypeId.AddToken('Integer');
    CheckEquals('Property Get MyProperty(Ident1 As String) As MSForms.Integer', P.AsString(True, False));
    CheckEquals('Property Get MyProperty('#13#10'  Ident1 As String'#13#10') As MSForms.Integer', P.AsString(True, True));
  Finally
    P.Free;
  End;
  P := TVBProperty.Create(ptGet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    P.TypeId := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('String');
      P.AddParameter(TVBParameter.Create(pamVar, 'Ident1', False, T, '""', scNone, 10, 12));
    Finally
      T.Free;
    End;
    P.TypeId.AddToken('MSForms');
    P.TypeId.AddToken('.');
    P.TypeId.AddToken('Integer');
    CheckEquals('Property Get MyProperty(ByRef Ident1 As String = "") As MSForms.Integer', P.AsString(True, False));
    CheckEquals('Property Get MyProperty('#13#10'  ByRef Ident1 As String = ""'#13#10') As MSForms.Integer', P.AsString(True, True));
  Finally
    P.Free;
  End;
  P := TVBProperty.Create(ptGet, 'MyProperty', scPrivate, 10 ,12,
    iiPublicProperty, Nil);
  Try
    P.TypeId := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('MSForms');
      T.AddToken('.');
      T.AddToken('Integer');
      P.AddParameter(TVBParameter.Create(pamVar, 'Ident1', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    T := TVBTypeDecl.Create('', scNone, 10, 12, iiNone, Nil);
    Try
      T.AddToken('Integer');
      P.AddParameter(TVBParameter.Create(pamConst, 'Ident2', False, T, '', scNone, 10, 12));
    Finally
      T.Free;
    End;
    P.TypeId.AddToken('MSForms');
    P.TypeId.AddToken('.');
    P.TypeId.AddToken('Integer');
    CheckEquals('Property Get MyProperty(ByRef Ident1 As MSForms.Integer, ByVal Ident2 As Integer) As MSForms.Integer', P.AsString(True, False));
    CheckEquals('Property Get MyProperty('#13#10'  ByRef Ident1 As MSForms.Integer,'#13#10'  ByVal Ident2 As Integer'#13#10') As MSForms.Integer', P.AsString(True, True));
  Finally
    P.Free;
  End;
end;

procedure TestTVBRecordDecl.TestAsString;

Var
  R : TVBRecordDecl;

begin
  R := TVBRecordDecl.Create('Identifier', scProtected, 12, 13, iiPublicRecord, Nil);
  Try
    CheckEquals('Type Identifier', R.AsString(True, False));
  Finally
    R.Free;
  End;
end;

procedure TestTVBTypeDecl.TestAsString;

Var
  T : TVBTypeDecl;

begin
  T := TVBTypeDecl.Create('temp', scNone, 0, 0, iiNone, Nil);
  Try
    T.AddToken('MSForm');
    CheckEquals('MSForm', T.AsString(True, False));
  Finally
    T.Free;
  End;
  T := TVBTypeDecl.Create('temp', scNone, 0, 0, iiNone, Nil);
  Try
    T.AddToken('MSForm');
    T.AddToken('.');
    T.AddToken('Integer');
    CheckEquals('MSForm.Integer', T.AsString(True, False));
  Finally
    T.Free;
  End;
end;

{ TestTVBModule }

procedure TestTVBModule.TestAttributes;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Attribute VB_Name = "frmWireRunWizard"'#13#10 +
      'Attribute VB_GlobalNameSpace = False'#13#10 +
      'Attribute VB_Creatable = False'#13#10 +
      'Attribute VB_PredeclaredId = True'#13#10 +
      'Attribute VB_Exposed = False'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(5, M.HeadingCount(strAttributesLabel));
      CheckEquals(scNone, M.FindElement(strAttributesLabel).Elements[1].Scope);
      CheckEquals(scNone, M.FindElement(strAttributesLabel).Elements[2].Scope);
      CheckEquals(scNone, M.FindElement(strAttributesLabel).Elements[3].Scope);
      CheckEquals(scNone, M.FindElement(strAttributesLabel).Elements[4].Scope);
      CheckEquals(scNone, M.FindElement(strAttributesLabel).Elements[5].Scope);
      // Remember these are now sorted...
      CheckEquals('VB_Creatable = False', M.FindElement(strAttributesLabel).Elements[1].AsString(True, False));
      CheckEquals('VB_Exposed = False', M.FindElement(strAttributesLabel).Elements[2].AsString(True, False));
      CheckEquals('VB_GlobalNameSpace = False', M.FindElement(strAttributesLabel).Elements[3].AsString(True, False));
      CheckEquals('VB_Name = "frmWireRunWizard"', M.FindElement(strAttributesLabel).Elements[4].AsString(True, False));
      CheckEquals('VB_PredeclaredId = True', M.FindElement(strAttributesLabel).Elements[5].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestCheckDocumentation;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      ''''#13#10 +
      ''' This is a module comment.'#13#10 +
      ''''#13#10 +
      ''' @author David Hoyle'#13#10 +
      ''' @version 1.0'#13#10 +
      ''' @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      Check(M.Comment = Nil, 'Module Comment is NOT NIL!');
    Finally
      M.Free;
    End;
    strCode :=
      ''':'#13#10 +
      ''' This is a module comment.'#13#10 +
      ''''#13#10 +
      ''' @author David Hoyle'#13#10 +
      ''' @version 1.0'#13#10 +
      ''' @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      Check(M.Comment <> Nil, 'Module Comment is NOT NIL!');
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals('1) This module has no document comment.', M.DocConflict(1));
      CheckEquals('', M.Comment.AsString(9999, True));
    Finally
      M.Free;
    End;
    strCode :=
      ''':'#13#10 +
      ''': This is a module comment.'#13#10 +
      ''''#13#10 +
      ''' @author David Hoyle'#13#10 +
      ''' @version 1.0'#13#10 +
      ''' @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      Check(M.Comment <> Nil, 'Module Comment is NOT NIL!');
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals('This is a module comment.', M.Comment.AsString(9999, True));
      CheckEquals('1) This module is missing a documentation date (''' + FormatDateTime('dd mmm yyyy', Now) + ''').', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''':'#13#10 +
      ''': This is a module comment.'#13#10 +
      ''':'#13#10 +
      ''' @author David Hoyle'#13#10 +
      ''' @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      Check(M.Comment <> Nil, 'Module Comment is NOT NIL!');
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals('This is a module comment.', M.Comment.AsString(9999, True));
      CheckEquals('1) This module is missing a documentation version.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''':'#13#10 +
      ''': This is a module comment.'#13#10 +
      ''':'#13#10 +
      ''' @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      Check(M.Comment <> Nil, 'Module Comment is NOT NIL!');
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals('This is a module comment.', M.Comment.AsString(9999, True));
      CheckEquals('1) This module is missing a documentation author.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''':'#13#10 +
      ''': This is a module comment.'#13#10 +
      ''':'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      Check(M.Comment <> Nil, 'Module Comment is NOT NIL!');
      CheckEquals(0, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      'private const iCAPACITY AS Long = 1'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals('1) Constant ''iCAPACITY'' is undocumented.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      ''' This is a standard comment.'#13#10 +
      'private const iCAPACITY AS Long = 1'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals('1) Constant ''iCAPACITY'' is undocumented.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      ''': This is a document comment.'#13#10 +
      'private const iCAPACITY AS Long = 1'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(0, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      'private iCAPACITY AS Long'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals('1) Variable ''iCAPACITY'' is undocumented.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      ''' This is a standard comment.'#13#10 +
      'private iCAPACITY AS Long'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals('1) Variable ''iCAPACITY'' is undocumented.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      ''': This is a document comment.'#13#10 +
      'private iCAPACITY AS Long'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(0, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      'private type TMyType'#13#10 +
      'end Type'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals('1) Type ''TMyType'' is undocumented.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      ''' This is a standard comment.'#13#10 +
      'private type TMyType'#13#10 +
      'end Type'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals('1) Type ''TMyType'' is undocumented.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      ''': This is a document comment.'#13#10 +
      'private type TMyType'#13#10 +
      'end Type'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(0, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      'private enum TMyType'#13#10 +
      'end enum'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals('1) Type ''TMyType'' is undocumented.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      ''' This is a standard comment.'#13#10 +
      'private enum TMyType'#13#10 +
      'end enum'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals('1) Type ''TMyType'' is undocumented.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      ''': This is a document comment.'#13#10 +
      'private enum TMyType'#13#10 +
      'end enum'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(0, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      'function MyFunction(iParam As Long) As Boolean'#13#10 +
      'end function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals('1) Method ''MyFunction'' has not been documented.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      ''' This is a standard comment.'#13#10 +
      ''' @precon  None.'#13#10 +
      ''' @Postcon None.'#13#10 +
      ''' @param  iParam as a Long'#13#10 +
      ''' @return a Boolean'#13#10 +
      'function MyFunction(iParam As Long) As Boolean'#13#10 +
      'end function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals('1) Method ''MyFunction'' has not been documented.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      ''': This is a standard comment.'#13#10 +
      ''': @precon  None.'#13#10 +
      ''': @postcon None.'#13#10 +
      ''': @param  iParam as a Long'#13#10 +
      ''': @return a Boolean'#13#10 +
      'function MyFunction(iParam As Long) As Boolean'#13#10 +
      'end function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(0, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      'property get MyProperty(iParam As Long) As Boolean'#13#10 +
      'end property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals('1) Property ''MyProperty'' has not been documented.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      ''' This is a standard comment.'#13#10 +
      ''' @precon  None.'#13#10 +
      ''' @Postcon None.'#13#10 +
      ''' @param  iParam as a Long'#13#10 +
      ''' @return a Boolean'#13#10 +
      'property get MyProperty(iParam As Long) As Boolean'#13#10 +
      'end property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(1, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals('1) Property ''MyProperty'' has not been documented.', M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      ''': This is a module comment.'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
      'option compare text'#13#10 +
      ''': This is a standard comment.'#13#10 +
      ''': @precon  None.'#13#10 +
      ''': @postcon None.'#13#10 +
      ''': @param  iParam as a Long'#13#10 +
      ''': @return a Boolean'#13#10 +
      'property get MyProperty(iParam As Long) As Boolean'#13#10 +
      'end property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(0, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestCombinations;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'VERSION 5.00'#13#10 +
      'Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} frmWireRunWizard'#13#10 +
      '   Caption         =   "Wire Run Wizard"'#13#10 +
      '   ClientHeight    =   4620'#13#10 +
      '   ClientLeft      =   45'#13#10 +
      '   ClientTop       =   435'#13#10 +
      '   ClientWidth     =   6180'#13#10 +
      '   OleObjectBlob   =   "frmWireRunWizard.frx":0000'#13#10 +
      '   StartUpPosition =   1  ''CenterOwner'#13#10 +
      'End'#13#10 +
      'Attribute VB_Name = "frmWireRunWizard"'#13#10 +
      'Attribute VB_GlobalNameSpace = False'#13#10 +
      'Attribute VB_Creatable = False'#13#10 +
      'Attribute VB_PredeclaredId = True'#13#10 +
      'Attribute VB_Exposed = False'#13#10 +
      ''#13#10 +
      ''':'#13#10 +
      ''': Hello'#13#10 +
      ''': @Something Else'#13#10 +
      ''':'#13#10 +
      'Option Explicit'#13#10 +
      'Option Compare Text'#13#10 +
      'Option Private Module'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.frm', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);

      CheckEquals(1, M.HeadingCount(strVersionLabel));
      CheckEquals(5, M.HeadingCount(strAttributesLabel));
      CheckEquals(3, M.HeadingCount(strOptionsLabel));

      CheckEquals(scNone, M.FindElement(strVersionLabel).Elements[1].Scope);
      CheckEquals(scNone, M.FindElement(strAttributesLabel).Elements[3].Scope);
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[2].Scope);

      CheckEquals('VB_GlobalNameSpace = False', M.FindElement(strAttributesLabel).Elements[3].AsString(True, False));
      CheckEquals('VERSION 5.00', M.FindElement(strVersionLabel).Elements[1].AsString(True, False));
      CheckEquals('ClientTop = 435', M.FindElement(strVersionLabel).Elements[1].Elements[1].Elements[4].AsString(True, False));
      CheckEquals('Explicit', M.FindElement(strOptionsLabel).Elements[2].AsString(True, False));
      Check(M.Comment <> Nil, 'Module Comment is NULL!');
    Finally
      M.Free;
    End;
    strCode :=
      ''#13#10 +
      ''''''#13#10 +
      ''''' Hello'#13#10 +
      ''''' @Something Else'#13#10 +
      ''''''#13#10 +
      'Option Explicit'#13#10 +
      'Option Compare Text'#13#10 +
      'Option Private Module'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.frm', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(0, M.HeadingCount(strVersionLabel));
      CheckEquals(0, M.HeadingCount(strAttributesLabel));
      CheckEquals(3, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[2].Scope);
      CheckEquals('Explicit', M.FindElement(strOptionsLabel).Elements[2].AsString(True, False));
      Check(M.Comment <> Nil, 'Module Comment is NULL!');
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestConsts;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Const iLong As Long'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPublic, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals('iLong As Long', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Const iLong As Long'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPrivate, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals('iLong As Long', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Const iLong As Long'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPublic, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals('iLong As Long', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Const strText As String = "Hello"'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPublic, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals('strText As String = "Hello"', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Const iLong As Long = 123'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPrivate, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals('iLong As Long = 123', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Const iLong As Long = &HFF00'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPublic, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals('iLong As Long = &HFF00', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Const iLong1 As Long = &HFF00'#13#10 +
      'Private Const iLong2 As Long = 123'#13#10 +
      'Public Const iLong3 As Long'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(3, M.HeadingCount(strConstantsLabel));
      CheckEquals(scPublic, M.FindElement(strConstantsLabel).Elements[1].Scope);
      CheckEquals(scPrivate, M.FindElement(strConstantsLabel).Elements[2].Scope);
      CheckEquals(scPublic, M.FindElement(strConstantsLabel).Elements[3].Scope);
      CheckEquals('iLong1 As Long = &HFF00', M.FindElement(strConstantsLabel).Elements[1].AsString(True, False));
      CheckEquals('iLong2 As Long = 123', M.FindElement(strConstantsLabel).Elements[2].AsString(True, False));
      CheckEquals('iLong3 As Long', M.FindElement(strConstantsLabel).Elements[3].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestDeclares;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Declare Sub Test Lib "Kernal32" ()'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals('Sub Test Lib "Kernal32" ()', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Sub Test Lib "Kernal32" Alias "TestA" ()'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals('Sub Test Lib "Kernal32" Alias "TestA" ()', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Sub Test Lib "Kernal32" Alias "TestA" (i As Long)'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals('Sub Test Lib "Kernal32" Alias "TestA" (i As Long)', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Sub Test1 Lib "Kernal32" Alias "TestA" ()'#13#10 +
      'Private Declare Sub Test2 Lib "Kernal32" Alias "TestA" (i As Long)'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(2, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals(scPrivate, M.FindElement(strDeclaresLabel).Elements[2].Scope);
      CheckEquals('Sub Test1 Lib "Kernal32" Alias "TestA" ()', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
      CheckEquals('Sub Test2 Lib "Kernal32" Alias "TestA" (i As Long)', M.FindElement(strDeclaresLabel).Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Function Test Lib "Kernal32" () As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals('Function Test Lib "Kernal32" () As String', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Function Test Lib "Kernal32" Alias "TestA" () As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals('Function Test Lib "Kernal32" Alias "TestA" () As String', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Function Test Lib "Kernal32" Alias "TestA" (i As Long) As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals('Function Test Lib "Kernal32" Alias "TestA" (i As Long) As String', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Declare Function Test1 Lib "Kernal32" Alias "TestA" () As Long'#13#10 +
      'Private Declare Function Test2 Lib "Kernal32" Alias "TestA" (i As Long) As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(2, M.HeadingCount(strDeclaresLabel));
      CheckEquals(scPublic, M.FindElement(strDeclaresLabel).Elements[1].Scope);
      CheckEquals(scPrivate, M.FindElement(strDeclaresLabel).Elements[2].Scope);
      CheckEquals('Function Test1 Lib "Kernal32" Alias "TestA" () As Long', M.FindElement(strDeclaresLabel).Elements[1].AsString(True, False));
      CheckEquals('Function Test2 Lib "Kernal32" Alias "TestA" (i As Long) As String', M.FindElement(strDeclaresLabel).Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestDisablers;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'option compare text'#13#10 +
      ''': @noerror'#13#10 +
      ''': @noexception'#13#10 +
      'sub mysub(iParam as Long)'#13#10 +
      'end sub'#13#10 +
      ''#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(0, M.HeadingCount(strWarnings), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
    Finally
      M.Free;
    End;
    strCode :=
      ''': @noerror'#13#10 +
      ''': @noexception'#13#10 +
      'option compare text'#13#10 +
      'sub mysub(iParam as Long)'#13#10 +
      'end sub'#13#10 +
      ''#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(0, M.HeadingCount(strWarnings), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestEnums;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Enum THello'#13#10 +
      '  FID = 1'#13#10 +
      '  FName = 2'#13#10 +
      'End Enum'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strTypesLabel));
      CheckEquals(scPublic, M.FindElement(strTypesLabel).Elements[1].Scope);
      CheckEquals('Enum THello', M.FindElement(strTypesLabel).Elements[1].AsString(True, False));
      CheckEquals('FID = 1', M.FindElement(strTypesLabel).Elements[1].Elements[1].AsString(True, False));
      CheckEquals('FName = 2', M.FindElement(strTypesLabel).Elements[1].Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Enum THello'#13#10 +
      '  FID'#13#10 +
      '  FName'#13#10 +
      'End Enum'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strTypesLabel));
      CheckEquals(scPrivate, M.FindElement(strTypesLabel).Elements[1].Scope);
      CheckEquals('Enum THello', M.FindElement(strTypesLabel).Elements[1].AsString(True, False));
      CheckEquals('FID', M.FindElement(strTypesLabel).Elements[1].Elements[1].AsString(True, False));
      CheckEquals('FName', M.FindElement(strTypesLabel).Elements[1].Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestFailure01;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

Begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Type RECT'#13#10 +
      '  ''Specifies the x-coordinate of the upper-left corner of the rectangle.'#13#10 +
      '  Left As Long'#13#10 +
      '  ''Specifies the y-coordinate of the upper-left corner of the rectangle.'#13#10 +
      '  Top As Long'#13#10 +
      '  ''Specifies the x-coordinate of the lower-right corner of the rectangle.'#13#10 +
      '  Right As Long'#13#10 +
      '  ''Specifies the y-coordinate of the lower-right corner of the rectangle.'#13#10 +
      '  Bottom As Long'#13#10 +
      'End Type'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strTypesLabel));
      CheckEquals(scPublic, M.FindElement(strTypesLabel).Elements[1].Scope);
      CheckEquals('Type RECT', M.FindElement(strTypesLabel).Elements[1].AsString(True, False));
      CheckEquals('Left As Long', M.FindElement(strTypesLabel).Elements[1].Elements[2].AsString(True, False));
      CheckEquals('Top As Long', M.FindElement(strTypesLabel).Elements[1].Elements[4].AsString(True, False));
      CheckEquals('Right As Long', M.FindElement(strTypesLabel).Elements[1].Elements[3].AsString(True, False));
      CheckEquals('Bottom As Long', M.FindElement(strTypesLabel).Elements[1].Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestFailure02;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

Begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'VERSION 5.00'#13#10 +
      'Begin VB.Form Form1'#13#10 +
      '   Caption         =   "Form1"'#13#10 +
      '   ClientHeight    =   5670'#13#10 +
      '   ClientLeft      =   60'#13#10 +
      '   ClientTop       =   345'#13#10 +
      '   ClientWidth     =   6885'#13#10 +
      '   LinkTopic       =   "Form1"'#13#10 +
      '   ScaleHeight     =   5670'#13#10 +
      '   ScaleWidth      =   6885'#13#10 +
      '   StartUpPosition =   3  ''Windows Default'#13#10 +
      '   Begin VB.CommandButton Command2'#13#10 +
      '      Caption         =   "Create File"'#13#10 +
      '      Height          =   495'#13#10 +
      '      Left            =   3120'#13#10 +
      '      TabIndex        =   2'#13#10 +
      '      Top             =   240'#13#10 +
      '      Width           =   3375'#13#10 +
      '   End'#13#10 +
      '   Begin VB.TextBox Text1'#13#10 +
      '      Height          =   4695'#13#10 +
      '      Left            =   240'#13#10 +
      '      MultiLine       =   -1  ''True'#13#10 +
      '      ScrollBars      =   3  ''Both'#13#10 +
      '      TabIndex        =   1'#13#10 +
      '      Top             =   840'#13#10 +
      '      Width           =   6375'#13#10 +
      '   End'#13#10 +
      '   Begin VB.CommandButton Command1'#13#10 +
      '      Caption         =   "LoadFile"'#13#10 +
      '      Height          =   495'#13#10 +
      '      Left            =   240'#13#10 +
      '      TabIndex        =   0'#13#10 +
      '      Top             =   240'#13#10 +
      '      Width           =   2535'#13#10 +
      '   End'#13#10 +
      'End'#13#10 +
      'Attribute VB_Name = "Form1"'#13#10 +
      'Attribute VB_GlobalNameSpace = False'#13#10 +
      'Attribute VB_Creatable = False'#13#10 +
      'Attribute VB_PredeclaredId = True'#13#10 +
      'Attribute VB_Exposed = False'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestFailure03;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;
  I: TElementContainer;
  F: TElementContainer;
  C: TComment;
  boolCascade: Boolean;

Begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'VERSION 5.00'#13#10 +
      'Option Compare Text'#13#10 +
      'Option Explicit'#13#10 +
      ''#13#10 +
      ''':'#13#10 +
      ''': This is a method comment.'#13#10 +
      ''':'#13#10 +
      ''': @precon  None.'#13#10 +
      ''': @postcon None.'#13#10 +
      ''':'#13#10 +
      ''': @param  iParam as a Long as a Reference'#13#10 +
      ''': @return a Boolean'#13#10 +
      ''':'#13#10 +
      'Private Function MyMethod(ByRef iParam as Long) As Boolean'#13#10 +
      'End Function'#13#10 +
      ''#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(0, M.HeadingCount(strWarnings), M.FirstWarning);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      I := M.FindElement(strImplementedMethodsLabel);
      Check(I <> Nil, 'Implemented Methods is NULL!');
      F := I.FindElement('MyMethod', ftIdentifier);
      Check(F <> Nil, 'MyMethod is NULL!');
      C := F.Comment;
      Check(C <> Nil, 'MyMethod.Comment is NULL!');
      If F is TVBMethod Then
        (F As TVBMethod).CheckDocumentation(boolCascade);
      CheckEquals(0, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
    Finally
      M.Free;
    End;
    strCode :=
      'VERSION 5.00'#13#10 +
      'Option Compare Text'#13#10 +
      'Option Explicit'#13#10 +
      ''#13#10 +
      ''''''#13#10 +
      ''''' This is a method comment.'#13#10 +
      ''''''#13#10 +
      ''''' @precon  None.'#13#10 +
      ''''' @postcon None.'#13#10 +
      ''''''#13#10 +
      ''''' @param  iParam as a Long as a Reference'#13#10 +
      ''''' @return a Boolean'#13#10 +
      ''''''#13#10 +
      'Private Function MyMethod(ByRef iParam as Long) As Boolean'#13#10 +
      'End Function'#13#10 +
      ''#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(0, M.HeadingCount(strWarnings), M.FirstWarning);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      I := M.FindElement(strImplementedMethodsLabel);
      Check(I <> Nil, 'Implemented Methods is NULL!');
      F := I.FindElement('MyMethod', ftIdentifier);
      Check(F <> Nil, 'MyMethod is NULL!');
      C := F.Comment;
      Check(C <> Nil, 'MyMethod.Comment is NULL!');
      If F is TVBMethod Then
        (F As TVBMethod).CheckDocumentation(boolCascade);
      CheckEquals(0, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestFunctions;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Function Test() As Long'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Function Test() As Long', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Function Test(i as long) As Long'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPrivate, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Function Test(i As long) As Long', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Friend Function Test(i as long) As Long'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scFriend, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Function Test(i As long) As Long', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Function Test(Optional i as long = 0) As Long'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Function Test(Optional i As long = 0) As Long', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Function Test(i as msforms.long, str as String) As Long'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Function Test(i As msforms.long, str As String) As Long', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Function Test(ParamArray i as long) As MSForms.Integer'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Function Test(ParamArray i As long) As MSForms.Integer', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Function Test1(i as msforms.long, str as String) As Long'#13#10 +
      'End Function'#13#10 +
      'Private Function Test2(i as msforms.long) As Long'#13#10 +
      'End Function'#13#10 +
      'Function Test3(Optional i as Long = 0) As Long'#13#10 +
      'End Function'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(3, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals(scPrivate, M.FindElement(strImplementedMethodsLabel).Elements[2].Scope);
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[3].Scope);
      CheckEquals('Function Test1(i As msforms.long, str As String) As Long', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
      CheckEquals('Function Test2(i As msforms.long) As Long', M.FindElement(strImplementedMethodsLabel).Elements[2].AsString(True, False));
      CheckEquals('Function Test3(Optional i As Long = 0) As Long', M.FindElement(strImplementedMethodsLabel).Elements[3].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestGetComment;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      ''':'#13#10 +
      ''': This is a module comment.'#13#10 +
      ''':'#13#10 +
      ''': @author David Hoyle'#13#10 +
      ''': @version 1.0'#13#10 +
      ''': @date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', True, [moParse, moCheckForDocumentConflicts]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(0, M.HeadingCount(strDocumentationConflicts), M.DocConflict(1));
      Check(M.Comment <> Nil, 'Module Comment is NIL!');
      CheckEquals('This is a module comment.', M.Comment.AsString(80, True));
      CheckEquals('David Hoyle', M.Comment.Tag[0].AsString(80, True));
      CheckEquals('1.0', M.Comment.Tag[1].AsString(80, True));
      CheckEquals(FormatDateTime('dd mmm yyyy', Now), M.Comment.Tag[2].AsString(80, True));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestOption;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Option Base 1'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Base 1', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Base 0'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Base 0', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Compare Binary'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Compare Binary', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Compare Database'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Compare Database', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Compare Text'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Compare Text', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Explicit'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Explicit', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Private Module'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals('Private Module', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Option Explicit'#13#10 +
      'Option Compare Text'#13#10 +
      'Option Private Module'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(3, M.HeadingCount(strOptionsLabel));
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[1].Scope);
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[2].Scope);
      CheckEquals(scNone, M.FindElement(strOptionsLabel).Elements[3].Scope);
      CheckEquals('Compare Text', M.FindElement(strOptionsLabel).Elements[1].AsString(True, False));
      CheckEquals('Explicit', M.FindElement(strOptionsLabel).Elements[2].AsString(True, False));
      CheckEquals('Private Module', M.FindElement(strOptionsLabel).Elements[3].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestProperties;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Property Get Test() As String'#13#10 +
      'End Property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strPropertiesLabel));
      CheckEquals(scPublic, M.FindElement(strPropertiesLabel).Elements[1].Scope);
      CheckEquals('Property Get Test() As String', M.FindElement(strPropertiesLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Property Let Test(i As Long)'#13#10 +
      'End Property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strPropertiesLabel));
      CheckEquals(scPrivate, M.FindElement(strPropertiesLabel).Elements[1].Scope);
      CheckEquals('Property Let Test(i As Long)', M.FindElement(strPropertiesLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Friend Property Let Test(i As Long)'#13#10 +
      'End Property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strPropertiesLabel));
      CheckEquals(scFriend, M.FindElement(strPropertiesLabel).Elements[1].Scope);
      CheckEquals('Property Let Test(i As Long)', M.FindElement(strPropertiesLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Property Set Test(Obj As TObject)'#13#10 +
      'End Property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strPropertiesLabel));
      CheckEquals(scPublic, M.FindElement(strPropertiesLabel).Elements[1].Scope);
      CheckEquals('Property Set Test(Obj As TObject)', M.FindElement(strPropertiesLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Property Let Test1(i As Long)'#13#10 +
      'End Property'#13#10 +
      'Public Property Set Test2(Obj As TObject)'#13#10 +
      'End Property'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(2, M.HeadingCount(strPropertiesLabel));
      CheckEquals(scPrivate, M.FindElement(strPropertiesLabel).Elements[1].Scope);
      CheckEquals(scPublic, M.FindElement(strPropertiesLabel).Elements[2].Scope);
      CheckEquals('Property Let Test1(i As Long)', M.FindElement(strPropertiesLabel).Elements[1].AsString(True, False));
      CheckEquals('Property Set Test2(Obj As TObject)', M.FindElement(strPropertiesLabel).Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestRecords;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Type THello'#13#10 +
      '  FID As Long'#13#10 +
      '  FName As String'#13#10 +
      'End Type'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strTypesLabel));
      CheckEquals(scPublic, M.FindElement(strTypesLabel).Elements[1].Scope);
      CheckEquals('Type THello', M.FindElement(strTypesLabel).Elements[1].AsString(True, False));
      CheckEquals('FID As Long', M.FindElement(strTypesLabel).Elements[1].Elements[1].AsString(True, False));
      CheckEquals('FName As String', M.FindElement(strTypesLabel).Elements[1].Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Type THello'#13#10 +
      '  FID As Long'#13#10 +
      '  FName As String'#13#10 +
      'End Type'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strTypesLabel));
      CheckEquals(scPrivate, M.FindElement(strTypesLabel).Elements[1].Scope);
      CheckEquals('Type THello', M.FindElement(strTypesLabel).Elements[1].AsString(True, False));
      CheckEquals('FID As Long', M.FindElement(strTypesLabel).Elements[1].Elements[1].AsString(True, False));
      CheckEquals('FName As String', M.FindElement(strTypesLabel).Elements[1].Elements[2].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestSubs;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Sub Test()'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Sub Test()', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private Sub Test(i as long)'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPrivate, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Sub Test(i As long)', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Friend Sub Test(i as long)'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scFriend, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Sub Test(i As long)', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Sub Test(Optional i as long = 0)'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Sub Test(Optional i As long = 0)', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Sub Test(i as msforms.long, str as String)'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Sub Test(i As msforms.long, str As String)', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Sub Test(ParamArray i as long)'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals('Sub Test(ParamArray i As long)', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public Sub Test1(i as msforms.long, str as String)'#13#10 +
      'End Sub'#13#10 +
      'Private Sub Test2(i as msforms.long)'#13#10 +
      'End Sub'#13#10 +
      'Sub Test3(Optional i as Long = 0)'#13#10 +
      'End Sub'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(3, M.HeadingCount(strImplementedMethodsLabel));
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[1].Scope);
      CheckEquals(scPrivate, M.FindElement(strImplementedMethodsLabel).Elements[2].Scope);
      CheckEquals(scPublic, M.FindElement(strImplementedMethodsLabel).Elements[3].Scope);
      CheckEquals('Sub Test1(i As msforms.long, str As String)', M.FindElement(strImplementedMethodsLabel).Elements[1].AsString(True, False));
      CheckEquals('Sub Test2(i As msforms.long)', M.FindElement(strImplementedMethodsLabel).Elements[2].AsString(True, False));
      CheckEquals('Sub Test3(Optional i As Long = 0)', M.FindElement(strImplementedMethodsLabel).Elements[3].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestVars;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'Dim strText As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText As String', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private strText As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPrivate, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText As String', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public strText As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText As String', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private strText() As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPrivate, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText() As String', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public strText(1 to 10) As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText(1 to 10) As String', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Private strText(1 to 10, 1 to 2) As String'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPrivate, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText(1 to 10, 1 to 2) As String', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public strText(1 to 10, 1 to 2) As MSForms.Integer'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('strText(1 to 10, 1 to 2) As MSForms.Integer', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public WithEvents strText As Integer'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals('WithEvents strText As Integer', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public strText1 As Integer'#13#10 +
      'Private strText2 As String'#13#10 +
      'Dim strText3 As Double'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(3, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals(scPrivate, M.FindElement(strVarsLabel).Elements[2].Scope);
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[3].Scope);
      CheckEquals('strText1 As Integer', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
      CheckEquals('strText2 As String', M.FindElement(strVarsLabel).Elements[2].AsString(True, False));
      CheckEquals('strText3 As Double', M.FindElement(strVarsLabel).Elements[3].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'Public strText1 As Integer, strText2 As String'#13#10 +
      'Dim strText3 As Double'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(3, M.HeadingCount(strVarsLabel));
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[1].Scope);
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[2].Scope);
      CheckEquals(scPublic, M.FindElement(strVarsLabel).Elements[3].Scope);
      CheckEquals('strText1 As Integer', M.FindElement(strVarsLabel).Elements[1].AsString(True, False));
      CheckEquals('strText2 As String', M.FindElement(strVarsLabel).Elements[2].AsString(True, False));
      CheckEquals('strText3 As Double', M.FindElement(strVarsLabel).Elements[3].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

procedure TestTVBModule.TestVersion;

Var
  S : TMemoryStream;
  M : TBaseLanguageModule;
  strCode : String;
  VL: TElementContainer;

begin
  S := TMemoryStream.Create;
  Try
    strCode :=
      'VERSION 1.0 CLASS'#13#10 +
      'BEGIN'#13#10 +
      '  Multiuse = -1  ''True'#13#10 +
      'END'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Cls', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVersionLabel));
      CheckEquals(scNone, M.FindElement(strVersionLabel).Elements[1].Scope);
      CheckEquals('VERSION 1.0 CLASS', M.FindElement(strVersionLabel).Elements[1].AsString(True, False));
      CheckEquals('Multiuse = - 1', M.FindElement(strVersionLabel).Elements[1].Elements[1].AsString(True, False));
    Finally
      M.Free;
    End;
    strCode :=
      'VERSION 5.00'#13#10 +
      'Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} frmWireRunWizard'#13#10 +
      '   Caption         =   "Wire Run Wizard"'#13#10 +
      '   ClientHeight    =   4620'#13#10 +
      '   ClientLeft      =   45'#13#10 +
      '   ClientTop       =   435'#13#10 +
      '   ClientWidth     =   6180'#13#10 +
      '   OleObjectBlob   =   "frmWireRunWizard.frx":0000'#13#10 +
      '   StartUpPosition =   1  ''CenterOwner'#13#10 +
      'End'#13#10;
    S.LoadBufferFromString(strCode);
    M := Dispatcher(S, 'VBFile.Frm', False, [moParse]);
    Try
      CheckEquals(0, M.HeadingCount(strErrors), M.FirstError);
      CheckEquals(ttFileEnd, M.CurrentToken.TokenType);
      CheckEquals(1, M.HeadingCount(strVersionLabel));
      VL := M.FindElement(strVersionLabel);
      CheckEquals(scNone, VL.Elements[1].Scope);
      CheckEquals('VERSION 5.00', VL.Elements[1].AsString(True, False));
      CheckEquals('Caption = "Wire Run Wizard"', VL.Elements[1].Elements[1].Elements[1].AsString(True, False));
      CheckEquals('ClientHeight = 4620', VL.Elements[1].Elements[1].Elements[2].AsString(True, False));
      CheckEquals('ClientLeft = 45', VL.Elements[1].Elements[1].Elements[3].AsString(True, False));
      CheckEquals('ClientTop = 435', VL.Elements[1].Elements[1].Elements[4].AsString(True, False));
      CheckEquals('ClientWidth = 6180', VL.Elements[1].Elements[1].Elements[5].AsString(True, False));
      CheckEquals('OleObjectBlob = "frmWireRunWizard.frx" : 0000', VL.Elements[1].Elements[1].Elements[6].AsString(True, False));
      CheckEquals('StartUpPosition = 1', VL.Elements[1].Elements[1].Elements[7].AsString(True, False));
    Finally
      M.Free;
    End;
  Finally
    S.Free;
  End;
end;

//
// Test methods for the class TVBComment.
//
Procedure TestTVBComment.TestCreateComment;

Var
  C: TComment;

Begin
  C := TVBComment.CreateComment('', 0, 0);
  Try
    Check(C = Nil, 'Comment is not NULL!');
  Finally
    C.Free;
  End;
  C := TVBComment.CreateComment(''' This is a standard VB Comment.', 0, 0);
  Try
    Check(C = Nil, 'Comment is not NULL!');
  Finally
    C.Free;
  End;
  C := TVBComment.CreateComment(''''' This is a standard VB Comment.', 0, 0);
  Try
    Check(C <> Nil, 'Comment is NULL!');
    CheckEquals('This is a standard VB Comment.', C.AsString(9999, True));
  Finally
    C.Free;
  End;
  C := TVBComment.CreateComment(''': This is a standard VB Comment.', 0, 0);
  Try
    Check(C <> Nil, 'Comment is NULL!');
    CheckEquals('This is a standard VB Comment.', C.AsString(9999, True));
  Finally
    C.Free;
  End;
  C := TVBComment.CreateComment(
    ''': This is a standard VB Comment.'#13#10 +
    ''': @todo Hello Dave.'#13#10, 0, 0);
  Try
    Check(C <> Nil, 'Comment is NULL!');
    CheckEquals('This is a standard VB Comment.', C.AsString(9999, True));
    CheckEquals(1, C.TagCount);
    CheckEquals('Hello Dave.', C.Tag[0].AsString(80, True)); 
  Finally
    C.Free;
  End;
End;

//
// Test methods for the class TExceptionHandling.
//
Procedure TestTExceptionHandling.Setup;

Begin
  FExceptionHandling := TExceptionHandling.Create;
End;

Procedure TestTExceptionHandling.TearDown;

Begin
  FExceptionHandling.Free;
End;

Procedure TestTExceptionHandling.TestGetHasErrorHnd;

Begin
  CheckEquals(False, FExceptionHandling.GetHasErrorHnd);
  FExceptionHandling.SetHasErrorHnd(True);
  CheckEquals(True, FExceptionHandling.GetHasErrorHnd);
End;

Procedure TestTExceptionHandling.TestGetHasExit;

Begin
  CheckEquals(False, FExceptionHandling.GetHasExit);
  FExceptionHandling.SetHasExit(True);
  CheckEquals(True, FExceptionHandling.GetHasExit);
End;

Procedure TestTExceptionHandling.TestGetHasPop;

Begin
  CheckEquals(False, FExceptionHandling.GetHasPop);
  FExceptionHandling.SetHasPop(True);
  CheckEquals(True, FExceptionHandling.GetHasPop);
End;

Procedure TestTExceptionHandling.TestGetHasPush;

Begin
  CheckEquals(False, FExceptionHandling.GetHasPush);
  FExceptionHandling.SetHasPush(True);
  CheckEquals(True, FExceptionHandling.GetHasPush);
End;

Procedure TestTExceptionHandling.TestGetPushName;

Begin
  CheckEquals('', FExceptionHandling.GetPushName);
  FExceptionHandling.SetPushName('MyPushName');
  CheckEquals('MyPushName', FExceptionHandling.GetPushName);
End;

Procedure TestTExceptionHandling.TestGetPushParams;

Begin
  CheckEquals(0, FExceptionHandling.GetPushParams.Count);
  FExceptionHandling.GetPushParams.Add('Hello');
  CheckEquals(1, FExceptionHandling.GetPushParams.Count);
End;

Procedure TestTExceptionHandling.TestSetHasErrorHnd;

Begin
  CheckEquals(False, FExceptionHandling.GetHasErrorHnd);
  FExceptionHandling.SetHasErrorHnd(True);
  CheckEquals(True, FExceptionHandling.GetHasErrorHnd);
End;

Procedure TestTExceptionHandling.TestSetHasExit;

Begin
  CheckEquals(False, FExceptionHandling.GetHasExit);
  FExceptionHandling.SetHasExit(True);
  CheckEquals(True, FExceptionHandling.GetHasExit);
End;

Procedure TestTExceptionHandling.TestSetHasPop;

Begin
  CheckEquals(False, FExceptionHandling.GetHasPop);
  FExceptionHandling.SetHasPop(True);
  CheckEquals(True, FExceptionHandling.GetHasPop);
End;

Procedure TestTExceptionHandling.TestSetHasPush;

Begin
  CheckEquals(False, FExceptionHandling.GetHasPush);
  FExceptionHandling.SetHasPush(True);
  CheckEquals(True, FExceptionHandling.GetHasPush);
End;

Procedure TestTExceptionHandling.TestSetPushName;

Begin
  CheckEquals('', FExceptionHandling.GetPushName);
  FExceptionHandling.SetPushName('MyPushName');
  CheckEquals('MyPushName', FExceptionHandling.GetPushName);
End;

//
// Test methods for the class TVBEnumerateDecl.
//
Procedure TestTVBEnumerateDecl.Setup;

Begin
  FVBEnumerateDecl := TVBEnumerateDecl.Create('MyEnumerate', scPrivate, 12, 23,
    iiPublicType, Nil);
End;

Procedure TestTVBEnumerateDecl.TearDown;

Begin
  FVBEnumerateDecl.Free;
End;

Procedure TestTVBEnumerateDecl.TestAsString;

Begin
  CheckEquals('Enum MyEnumerate', FVBEnumerateDecl.AsString(true, True));
End;

procedure TestTVBEnumerateDecl.TestCreate;
begin
  CheckEquals('MyEnumerate', FVBEnumerateDecl.Identifier);
  CheckEquals(scPrivate, FVBEnumerateDecl.Scope);
  CheckEquals(12, FVBEnumerateDecl.Line);
  CheckEquals(23, FVBEnumerateDecl.Column);
  CheckEquals(iiPrivateType, FVBEnumerateDecl.ImageIndexAdjustedForScope);
  Check(Nil = FVBEnumerateDecl.Comment);
end;

//
// Test methods for the class TVBEnumIdent.
//
Procedure TestTVBEnumIdent.Setup;

Begin
  FVBEnumIdent := TVBEnumIdent.Create('MyEnumIdent', scPublic, 12, 23,
    iiUsesItem, Nil);
End;

Procedure TestTVBEnumIdent.TearDown;

Begin
  FVBEnumIdent.Free;
End;

Procedure TestTVBEnumIdent.TestAsString;

Begin
  CheckEquals('MyEnumIdent', FVBEnumIdent.AsString(true, True));
  FVBEnumIdent.AddToken('1');
  CheckEquals('MyEnumIdent = 1', FVBEnumIdent.AsString(true, True));
End;

procedure TestTVBEnumIdent.TestCreate;
begin
  CheckEquals('MyEnumIdent', FVBEnumIdent.Identifier);
  CheckEquals(scPublic, FVBEnumIdent.Scope);
  CheckEquals(12, FVBEnumIdent.Line);
  CheckEquals(23, FVBEnumIdent.Column);
  CheckEquals(iiUsesItem, FVBEnumIdent.ImageIndexAdjustedForScope);
  Check(Nil = FVBEnumIdent.Comment);
end;

//
// Test methods for the class TVBField.
//
Procedure TestTVBField.Setup;

Begin
  FVBField := TVBField.Create('MyField', scPublic, 12, 23, iiPublicField, Nil);
End;

Procedure TestTVBField.TearDown;

Begin
  FVBField.Free;
End;

Procedure TestTVBField.TestAsString;

Begin
  CheckEquals('MyField', FVBField.AsString(True, True));
  FVBField.AddToken('Long');
  CheckEquals('MyField As Long', FVBField.AsString(True, True));
End;

procedure TestTVBField.TestCreate;
begin
  CheckEquals('MyField', FVBField.Identifier);
  CheckEquals(scPublic, FVBField.Scope);
  CheckEquals(12, FVBField.Line);
  CheckEquals(23, FVBField.Column);
  CheckEquals(iiPublicField, FVBField.ImageIndexAdjustedForScope);
  Check(Nil = FVBField.Comment);
end;

//
// Test methods for the class TVBOption.
//
Procedure TestTVBOption.Setup;

Begin
  FVBOption := TVBOption.Create('Option', scNone, 12, 23, iiUsesItem, Nil);
End;

Procedure TestTVBOption.TearDown;

Begin
  FVBOption.Free;
End;

Procedure TestTVBOption.TestAsString;

Begin
  CheckEquals('Option', FVBOption.AsString(True, True));
End;

procedure TestTVBOption.TestCreate;
begin
  CheckEquals('Option', FVBOption.Identifier);
  CheckEquals(scNone, FVBOption.Scope);
  CheckEquals(12, FVBOption.Line);
  CheckEquals(23, FVBOption.Column);
  CheckEquals(iiUsesItem, FVBOption.ImageIndexAdjustedForScope);
  Check(Nil = FVBOption.Comment);
end;

//
// Test methods for the class TVBVersion.
//
Procedure TestTVBVersion.Setup;

Begin
  FVBVersion := TVBVersion.Create('Version', scPublic, 12, 23, iiUsesItem, Nil);
End;

Procedure TestTVBVersion.TearDown;

Begin
  FVBVersion.Free;
End;

Procedure TestTVBVersion.TestAsString;

Begin
  CheckEquals('Version', FVBVersion.AsString(True, True));
  FVBVersion.AddToken('1.0');
  FVBVersion.AddToken('Class');
  CheckEquals('Version 1.0 Class', FVBVersion.AsString(True, True));
End;

procedure TestTVBVersion.TestCreate;
begin
  CheckEquals('Version', FVBVersion.Identifier);
  CheckEquals(scPublic, FVBVersion.Scope);
  CheckEquals(12, FVBVersion.Line);
  CheckEquals(23, FVBVersion.Column);
  CheckEquals(iiUsesItem, FVBVersion.ImageIndexAdjustedForScope);
  Check(Nil = FVBVersion.Comment);
end;

//
// Test methods for the class TVBAttribute.
//
Procedure TestTVBAttribute.Setup;

Begin
  FVBAttribute := TVBAttribute.Create('Attribute', scPublic, 12, 23, iiUsesItem,
    Nil);
End;

Procedure TestTVBAttribute.TearDown;

Begin
  FVBAttribute.Free;
End;

Procedure TestTVBAttribute.TestAsString;

Begin
  CheckEquals('Attribute', FVBAttribute.AsString(True, True));
  FVBAttribute.AddToken('iThing');
  FVBAttribute.AddToken('=');
  FVBAttribute.AddToken('1');
  CheckEquals('Attribute iThing = 1', FVBAttribute.AsString(True, True));
End;

procedure TestTVBAttribute.TestCreate;
begin
  CheckEquals('Attribute', FVBAttribute.Identifier);
  CheckEquals(scPublic, FVBAttribute.Scope);
  CheckEquals(12, FVBAttribute.Line);
  CheckEquals(23, FVBAttribute.Column);
  CheckEquals(iiUsesItem, FVBAttribute.ImageIndexAdjustedForScope);
  Check(Nil = FVBAttribute.Comment);
end;

initialization
  // Register any test cases with the test runner
  RegisterTest('VB Module Tests', TestTVBParameter.Suite);
  RegisterTest('VB Module Tests', TestTVBMethod.Suite);
  RegisterTest('VB Module Tests', TestTVBConstant.Suite);
  RegisterTest('VB Module Tests', TestTVBVar.Suite);
  RegisterTest('VB Module Tests', TestTVBProperty.Suite);
  RegisterTest('VB Module Tests', TestTVBRecordDecl.Suite);
  RegisterTest('VB Module Tests', TestTVBTypeDecl.Suite);
  RegisterTest('VB Module Tests', TestTVBModule.Suite);
  RegisterTest('VB Module Tests', TestTVBComment.Suite);
  RegisterTest('VB Module Tests', TestTExceptionHandling.Suite);
  RegisterTest('VB Module Tests', TestTVBEnumerateDecl.Suite);
  RegisterTest('VB Module Tests', TestTVBEnumIdent.Suite);
  RegisterTest('VB Module Tests', TestTVBField.Suite);
  RegisterTest('VB Module Tests', TestTVBOption.Suite);
  RegisterTest('VB Module Tests', TestTVBVersion.Suite);
  RegisterTest('VB Module Tests', TestTVBAttribute.Suite);
End.

