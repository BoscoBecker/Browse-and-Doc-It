unit TestPascalModule;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, Classes, Contnrs, SysUtils, Windows, BaseLanguageModule,
  PascalModule, TestBaseLanguageModule;
type
  // Test methods for class TPascalComment

  TestTPascalComment = class(TExtendedTestCase)
  strict private
  public
  published
    procedure TestCreateComment;
  end;
  // Test methods for class TIdentList

  TestTIdentList = class(TExtendedTestCase)
  strict private
    FIdentList: TIdentList;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
  end;

  TestTTypes = class(TExtendedTestCase)
  strict private
    FTypes: TTypes;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
  end;
  // Test methods for class TArrayType
  TestTArrayType = class(TExtendedTestCase)
  strict private
    FArrayType: TArrayType;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
    procedure TestAddDimension;
  end;
  // Test methods for class TRecordDecl

  TestTRecordDecl = class(TExtendedTestCase)
  strict private
    FRecordDecl: TRecordDecl;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
    procedure TestAsString;
    procedure TestReferenceSymbol;
  end;
  // Test methods for class TPascalParameter

  TestTPascalParameter = class(TExtendedTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TPascalMethod

  TestTPascalMethod = class(TExtendedTestCase)
  strict private
    FPascalMethod: TPascalMethod;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAddDirectives;
    procedure TestHasDirective;
    procedure TestAsString;
    procedure TestReferenceSymbol;
  end;
  // Test methods for class TPascalProperty

  TestTPascalProperty = class(TExtendedTestCase)
  strict private
    FPascalProperty: TPascalProperty;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
  end;
  // Test methods for class TPropertySpec

  TestTPropertySpec = class(TExtendedTestCase)
  strict private
    FPropertySpec: TPropertySpec;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAsString;
  end;
  // Test methods for class TObjectDecl

  TestTObjectDecl = class(TExtendedTestCase)
  strict private
    FObjectDecl: TObjectDecl;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
    procedure TestAsString;
    procedure TestReferenceSymbol;
  end;
  // Test methods for class TClassDecl

  TestTClassDecl = class(TExtendedTestCase)
  strict private
    FClassDecl: TClassDecl;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
    procedure TestAsString;
    procedure TestReferenceSymbol;
  end;
  // Test methods for class TInterfaceDecl

  TestTInterfaceDecl = class(TExtendedTestCase)
  strict private
    FInterfaceDecl: TInterfaceDecl;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
    procedure TestAsString;
  end;
  // Test methods for class TDispInterfaceDecl

  TestTDispInterfaceDecl = class(TExtendedTestCase)
  strict private
    FDispInterfaceDecl: TDispInterfaceDecl;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
    procedure TestAsString;
  end;
  // Test methods for class TConstant

  TestTConstant = class(TExtendedTestCase)
  strict private
    FConstant: TConstant;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
  end;
  // Test methods for class TResourceString

  TestTResourceString = class(TExtendedTestCase)
  strict private
    FResourceString: TResourceString;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
  end;
  // Test methods for class TVar

  TestTVar = class(TExtendedTestCase)
  strict private
    FVar: TVar;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
  end;
  // Test methods for class TThreadVar

  TestTThreadVar = class(TExtendedTestCase)
  strict private
    FThreadVar: TThreadVar;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
  end;
  // Test methods for class TField

  TestTField = class(TExtendedTestCase)
  strict private
    FField: TField;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
    procedure TestCheckDocumentation;
  end;
  // Test methods for class TExportsItem

  TestTExportsItem = class(TExtendedTestCase)
  strict private
    FExportsItem: TExportsItem;
  public
    Procedure TestCreate;
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAsString;
  end;
  // Test methods for class TInitializationSection

  TestTInitializationSection = class(TExtendedTestCase)
  strict private
    FInitializationSection: TInitializationSection;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
    procedure TestCheckDocumentation;
  end;
  // Test methods for class TFinalizationSection

  TestTFinalizationSection = class(TExtendedTestCase)
  strict private
    FFinalizationSection: TFinalizationSection;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
    procedure TestCheckDocumentation;
  end;

  //
  // Test Class for the TPascalModule Class Methods.
  //
  TestTPascalModule = Class(TExtendedTestCase)
  Strict Private
    FSource: String;
    FPascalModule : TPascalModule;
  Public
    Procedure SetUp; Override;
    Procedure TearDown; Override;
  Published
    Procedure TestAsString;
    Procedure TestCreateParser;
    Procedure TestReservedWords;
    Procedure TestDirectives;
    Procedure TestProcessCompilerDirective;
    Procedure TestReferenceSymbol;
    Procedure TestGoal;
    Procedure TestOPProgram;
    Procedure TestOPUnit;
    Procedure TestOPPackage;
    Procedure TestOPLibrary;
    Procedure TestProgramBlock;
    procedure TestUsesClause;
    Procedure TestPortabilityDirective;
    Procedure TestInterfaceSection;
    Procedure TestInterfaceDecl;
    Procedure TestExportedHeading;
    Procedure TestImplementationSection;
    Procedure TestBlock;
    Procedure TestExportsStmt;
    procedure TestExportsItem;
    Procedure TestDeclSection;
    Procedure TestLabelDeclSection;
    Procedure TestConstSection;
    Procedure TestConstantDecl;
    Procedure TestResStringSection;
    Procedure TestResourceStringDecl;
    Procedure TestTypeSection;
    Procedure TestTypeDecl;
    Procedure TestTypedConstant;
    Procedure TestArrayConstant;
    Procedure TestRecordConstant;
    Procedure TestRecordFieldConstant;
    Procedure TestOPType;
    Procedure TestRestrictedType;
    Procedure TestClassRefType;
    Procedure TestSimpleType;
    Procedure TestRealType;
    Procedure TestOrdinalType;
    Procedure TestOrdIdent;
    Procedure TestVariantType;
    Procedure TestSubRangeType;
    Procedure TestEnumerateType;
    Procedure TestEnumerateElement;
    Procedure TestStringType;
    Procedure TestStrucType;
    Procedure TestArrayType;
    Procedure TestRecType;
    Procedure TestFieldList;
    procedure TestFieldDecl;
    Procedure TestVariantSection;
    procedure TestRecVariant;
    Procedure TestSetType;
    Procedure TestFileType;
    Procedure TestPointerType;
    Procedure TestProcedureType;
    Procedure TestVarSection;
    Procedure TestClassVarSection;
    Procedure TestThreadVarSection;
    Procedure TestVarDecl;
    Procedure TestThreadVarDecl;
    Procedure TestExpression;
    Procedure TestSimpleExpression;
    Procedure TestTerm;
    Procedure TestFactor;
    Procedure TestRelOp;
    Procedure TestAddOp;
    Procedure TestMulOp;
    Procedure TestDesignator;
    Procedure TestSetConstructor;
    Procedure TestSetElement;
    Procedure TestExprList;
    Procedure TestStatement;
    Procedure TestStmtList;
    Procedure TestSimpleStatement;
    Procedure TestStructStmt;
    Procedure TestCompoundStmt;
    Procedure TestConditionalStmt;
    Procedure TestIfStmt;
    Procedure TestCaseStmt;
    Procedure TestCaseSelector;
    Procedure TestCaseLabel;
    Procedure TestLoopStmt;
    Procedure TestRepeatStmt;
    Procedure TestWhileStmt;
    Procedure TestForStmt;
    Procedure TestWithStmt;
    Procedure TestTryExceptAndFinallyStmt;
    Procedure TestExceptionBlock;
    Procedure TestRaiseStmt;
    Procedure TestAssemblerStatement;
    Procedure TestProcedureDeclSection;
    Procedure TestProcedureDecl;
    Procedure TestFunctionDecl;
    Procedure TestConstructorDecl;
    Procedure TestDestructorDecl;
    Procedure TestFunctionHeading;
    Procedure TestProcedureHeading;
    Procedure TestFormalParameter;
    Procedure TestFormalParam;
    Procedure TestParameter;
    Procedure TestDirective;
    Procedure TestObjectType;
    Procedure TestObjHeritage;
    Procedure TestMethodList;
    Procedure TestMethodHeading;
    Procedure TestConstructorHeading;
    Procedure TestDestructorHeading;
    Procedure TestObjFieldList;
    Procedure TestInitSection;
    Procedure TestClassType;
    Procedure TestClassHeritage;
    procedure TestClassVisibility;
    Procedure TestClassFieldList;
    Procedure TestClassMethodList;
    Procedure TestClassPropertyList;
    Procedure TestPropertyList;
    Procedure TestPropertyInterface;
    Procedure TestPropertyParameterList;
    Procedure TestPropertySpecifiers;
    Procedure TestInterfaceType;
    Procedure TestInterfaceHeritage;
    Procedure TestRequiresClause;
    procedure TestContainsClause;
    Procedure TestAdvancedRecords;
    Procedure TestRTTIAttributesSingleClass;
    Procedure TestRTTIAttributesSingleMethod;
    Procedure TestRTTIAttributesSingleRecord;
    Procedure TestRTTIAttributesComplexType;
    Procedure TestRTTIAttributesMultiFields;
    Procedure TestRTTIAttributesMultiFunction;
    Procedure TestRTTIAttributesSingleTypeConst;
    Procedure TestRTTIAttributesSingleProperty;
    Procedure TestRTTIAttributesRecord;
    Procedure TestRTTIAttributesClass;
    Procedure TestRTTIAttributesInterface;
    Procedure TestCodeFailure01;
    Procedure TestCodeFailure02;
    Procedure TestCodeFailure03;
    Procedure TestCodeFailure04;
    Procedure TestCodeFailure05;
    Procedure TestCodeFailure06;
    Procedure TestCodeFailure07;
    Procedure TestCodeFailure08;
    procedure TestCodeFailure09;
    Procedure TestCodeFaliure10;
    Procedure TestCodeFailure11;
    Procedure TestCodeFailure12;
    Procedure TestCodeFailure13;
    Procedure TestCodeFailure14;
    Procedure TestCodeFailure15;
    Procedure TestCodeFailure16;
    Procedure TestCodeFailure17;
    Procedure TestCodeFailure18;
    Procedure TestCodeFailure19;
    Procedure TestCodeFailure21;
    Procedure TestCodeFailure22;
  Public
  End;

implementation

procedure TestTPascalComment.TestCreateComment;

var
  ReturnValue: TComment;

begin
  ReturnValue := TPascalComment.CreateComment(
    '(** Sorry Dave, I can`t do that! **)', 12, 23);
  Try
    CheckEquals(15, ReturnValue.TokenCount);
    CheckEquals('Sorry', ReturnValue.Tokens[0].Token);
    CheckEquals('Dave', ReturnValue.Tokens[2].Token);
    CheckEquals(',', ReturnValue.Tokens[3].Token);
    CheckEquals('I', ReturnValue.Tokens[5].Token);
    CheckEquals('can', ReturnValue.Tokens[7].Token);
    CheckEquals('`', ReturnValue.Tokens[8].Token);
    CheckEquals('t', ReturnValue.Tokens[9].Token);
    CheckEquals('do', ReturnValue.Tokens[11].Token);
    CheckEquals('that', ReturnValue.Tokens[13].Token);
    CheckEquals('!', ReturnValue.Tokens[14].Token);
    CheckEquals('Sorry Dave, I can`t do that!', ReturnValue.AsString(999, True));
  Finally
    ReturnValue.Free;
  End;
  ReturnValue := TPascalComment.CreateComment(
    '//: Sorry Dave, I can`t do that!', 12, 23);
  Try
    CheckEquals(15, ReturnValue.TokenCount);
    CheckEquals('Sorry', ReturnValue.Tokens[0].Token);
    CheckEquals('Dave', ReturnValue.Tokens[2].Token);
    CheckEquals(',', ReturnValue.Tokens[3].Token);
    CheckEquals('I', ReturnValue.Tokens[5].Token);
    CheckEquals('can', ReturnValue.Tokens[7].Token);
    CheckEquals('`', ReturnValue.Tokens[8].Token);
    CheckEquals('t', ReturnValue.Tokens[9].Token);
    CheckEquals('do', ReturnValue.Tokens[11].Token);
    CheckEquals('that', ReturnValue.Tokens[13].Token);
    CheckEquals('!', ReturnValue.Tokens[14].Token);
    CheckEquals('Sorry Dave, I can`t do that!', ReturnValue.AsString(999, True));
  Finally
    ReturnValue.Free;
  End;
  ReturnValue := TPascalComment.CreateComment(
    '{: Sorry Dave, I can`t do that! }', 12, 23);
  Try
    CheckEquals(15, ReturnValue.TokenCount);
    CheckEquals('Sorry', ReturnValue.Tokens[0].Token);
    CheckEquals('Dave', ReturnValue.Tokens[2].Token);
    CheckEquals(',', ReturnValue.Tokens[3].Token);
    CheckEquals('I', ReturnValue.Tokens[5].Token);
    CheckEquals('can', ReturnValue.Tokens[7].Token);
    CheckEquals('`', ReturnValue.Tokens[8].Token);
    CheckEquals('t', ReturnValue.Tokens[9].Token);
    CheckEquals('do', ReturnValue.Tokens[11].Token);
    CheckEquals('that', ReturnValue.Tokens[13].Token);
    CheckEquals('!', ReturnValue.Tokens[14].Token);
    CheckEquals('Sorry Dave, I can`t do that!', ReturnValue.AsString(999, True));
  Finally
    ReturnValue.Free;
  End;
end;

procedure TestTIdentList.SetUp;
begin
  FIdentList := TIdentList.Create('Hello', scNone, 12, 23, iiNone, Nil);
end;

procedure TestTIdentList.TearDown;
begin
  FIdentList.Free;
  FIdentList := nil;
end;

procedure TestTIdentList.TestAsString;

begin
  CheckEquals('Hello', FIdentList.AsString(True, False));
  FIdentList.AddToken('=', ttSymbol);
  FIdentList.AddToken('1', ttNumber);
  CheckEquals('Hello = 1', FIdentList.AsString(True, False));
  FIdentList.ClearTokens;
  FIdentList.AddToken('In', ttReservedWord);
  FIdentList.AddToken('''D:\Path\PascalFile.pas''', ttSingleLiteral);
  CheckEquals('Hello In ''D:\Path\PascalFile.pas''', FIdentList.AsString(True, False));
end;

procedure TestTIdentList.TestCreate;
begin
  CheckEquals(scNone, FIdentList.Scope);
  CheckEquals(12, FIdentList.Line);
  Checkequals(23, FIdentList.Column);
  CheckEquals(iiNone, FIdentList.ImageIndex);
  CheckEquals(iiNone, FIdentList.ImageIndexAdjustedForScope);
end;

procedure TestTTypes.SetUp;
begin
  FTypes := TTypes.Create('MyType', scPrivate, 12, 23, iiPublicType, Nil);
end;

procedure TestTTypes.TearDown;
begin
  FTypes.Free;
  FTypes := nil;
end;

procedure TestTTypes.TestAsString;

begin
  CheckEquals('MyType', FTypes.AsString(True, False));
  FTypes.AddToken('Integer');
  CheckEquals('MyType = Integer', FTypes.AsString(True, False));
end;

procedure TestTTypes.TestCreate;
begin
  CheckEquals(scPrivate, FTypes.Scope);
  CheckEquals(12, FTypes.Line);
  Checkequals(23, FTypes.Column);
  CheckEquals(iiPublicType, FTypes.ImageIndex);
  CheckEquals(iiPrivateType, FTypes.ImageIndexAdjustedForScope);
end;

procedure TestTArrayType.SetUp;
begin
  FArrayType := TArrayType.Create('MyArrayType', scProtected, 12, 23,
    iiPublicType, Nil);
end;

procedure TestTArrayType.TearDown;
begin
  FArrayType.Free;
  FArrayType := nil;
end;

procedure TestTArrayType.TestAsString;

begin
  CheckEquals('MyArrayType', FArrayType.AsString(True, False));
  FArrayType.AddToken('Array');
  FArrayType.AddToken('Of');
  FArrayType.AddToken('Integer');
  CheckEquals('MyArrayType = Array Of Integer', FArrayType.AsString(True, False));
  FArrayType.ClearTokens;
  FArrayType.AddToken('Array');
  FArrayType.AddToken('[');
  FArrayType.AddToken('1');
  FArrayType.AddToken('..');
  FArrayType.AddToken('2');
  FArrayType.AddToken(']');
  FArrayType.AddToken('Of');
  FArrayType.AddToken('Integer');
  CheckEquals('MyArrayType = Array[1..2] Of Integer', FArrayType.AsString(True, False));
end;

procedure TestTArrayType.TestCreate;
begin
  CheckEquals(scProtected, FArrayType.Scope);
  CheckEquals(12, FArrayType.Line);
  Checkequals(23, FArrayType.Column);
  CheckEquals(iiPublicType, FArrayType.ImageIndex);
  CheckEquals(iiProtectedType, FArrayType.ImageIndexAdjustedForScope);
end;

procedure TestTArrayType.TestAddDimension;
begin
  CheckEquals(0, FArrayType.Dimensions);
  FArrayType.AddDimension;
  CheckEquals(1, FArrayType.Dimensions);
  FArrayType.AddDimension;
  CheckEquals(2, FArrayType.Dimensions);
end;

procedure TestTRecordDecl.SetUp;
begin
  FRecordDecl := TRecordDecl.Create('MyRecord', scProtected, 12, 23,
    iiPublicRecord, Nil);
end;

procedure TestTRecordDecl.TearDown;
begin
  FRecordDecl.Free;
  FRecordDecl := nil;
end;

procedure TestTRecordDecl.TestCheckDocumentation;

var
  boolCascade: Boolean;
  C: TComment;

begin
  CheckEquals(0, FRecordDecl.ElementCount);
  FRecordDecl.CheckDocumentation(boolCascade);
  CheckEquals(1, FRecordDecl.ElementCount);
  CheckEquals('1) Record type ''MyRecord'' is undocumented.',
    FRecordDecl.DocConflict(1));
  FRecordDecl.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the record.', 0, 0);
  Try
    FRecordDecl.Comment := C;
    FRecordDecl.CheckDocumentation(boolCascade);
    CheckEquals(0, FRecordDecl.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTRecordDecl.TestCreate;
begin
  CheckEquals(scProtected, FRecordDecl.Scope);
  CheckEquals(12, FRecordDecl.Line);
  Checkequals(23, FRecordDecl.Column);
  CheckEquals(iiPublicRecord, FRecordDecl.ImageIndex);
  CheckEquals(iiProtectedRecord, FRecordDecl.ImageIndexAdjustedForScope);
end;

procedure TestTRecordDecl.TestAsString;
begin
  CheckEquals('MyRecord = Record', FRecordDecl.AsString(True, False));
end;

procedure TestTRecordDecl.TestReferenceSymbol;

var
  AToken: TTokenInfo;

begin
  AToken := TTokenInfo.Create('Hello', 0, 1, 2, 5, ttUnknown);
  Try
    CheckEquals(False, FRecordDecl.ReferenceSymbol(AToken));
    //: @todo Requires more tests.
  Finally
    AToken.Free;
  End;
end;

procedure TestTPascalParameter.TestAsString;

var
  P: TPascalParameter;
  AType : TInteger;

begin
  AType := TInteger.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('Integer');
    P := TPascalParameter.Create(pamNone, 'MyParam', False, AType, '', scNone, 12, 23);
    Try
      CheckEquals(scNone, P.Scope);
      CheckEquals(12, P.Line);
      Checkequals(23, P.Column);
      CheckEquals('MyParam : Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
    P := TPascalParameter.Create(pamVar, 'MyParam', False, AType, '', scNone, 12, 23);
    Try
      CheckEquals(scNone, P.Scope);
      CheckEquals(12, P.Line);
      Checkequals(23, P.Column);
      CheckEquals('var MyParam : Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
    P := TPascalParameter.Create(pamConst, 'MyParam', False, AType, '', scNone, 12, 23);
    Try
      CheckEquals(scNone, P.Scope);
      CheckEquals(12, P.Line);
      Checkequals(23, P.Column);
      CheckEquals('const MyParam : Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
    P := TPascalParameter.Create(pamOut, 'MyParam', False, AType, '', scNone, 12, 23);
    Try
      CheckEquals(scNone, P.Scope);
      CheckEquals(12, P.Line);
      Checkequals(23, P.Column);
      CheckEquals('out MyParam : Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
    P := TPascalParameter.Create(pamNone, 'MyParam', True, AType, '', scNone, 12, 23);
    Try
      CheckEquals(scNone, P.Scope);
      CheckEquals(12, P.Line);
      Checkequals(23, P.Column);
      CheckEquals('MyParam : Array Of Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
    P := TPascalParameter.Create(pamNone, 'MyParam', False, AType, '0', scNone, 12, 23);
    Try
      CheckEquals(scNone, P.Scope);
      CheckEquals(12, P.Line);
      Checkequals(23, P.Column);
      CheckEquals('MyParam : Integer = 0', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    AType.Free;
  end;
end;

procedure TestTPascalMethod.SetUp;
begin
  FPascalMethod := TPascalMethod.Create(mtFunction, 'MyFunction', scPrivate, 12, 23);
  FPascalMethod.ReturnType := TTypes.Create('', scNone, 0, 0, iiNone, Nil);
  FPascalMethod.ReturnType.AddToken('Integer');
end;

procedure TestTPascalMethod.TearDown;
begin
  FPascalMethod.Free;
  FPascalMethod := nil;
end;

procedure TestTPascalMethod.TestAddDirectives;

begin
  FPascalMethod.AddDirectives('Virtual');
  FPascalMethod.AddDirectives('Message');
  CheckEquals(True, FPascalMethod.HasDirective('Virtual'));
  CheckEquals(True, FPascalMethod.HasDirective('Message'));
end;

procedure TestTPascalMethod.TestHasDirective;

begin
  FPascalMethod.AddDirectives('Virtual');
  FPascalMethod.AddDirectives('Message');
  CheckEquals(True, FPascalMethod.HasDirective('Virtual'));
  CheckEquals(True, FPascalMethod.HasDirective('Message'));
end;

procedure TestTPascalMethod.TestAsString;
var
  P: TPascalParameter;
  AType : TTypes;

begin
  CheckEquals('Function MyFunction : Integer', FPascalMethod.AsString(True, False));
  CheckEquals('Function MyFunction : Integer', FPascalMethod.AsString(True, True));
  AType := TTypes.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('Integer');
    P := TPascalParameter.Create(pamNone, 'Param1', False, AType, '', scNone, 0, 0);
    FPascalMethod.AddParameter(P);
  Finally
    AType.Free;
  End;
  CheckEquals('Function MyFunction(Param1 : Integer) : Integer', FPascalMethod.AsString(True, False));
  CheckEquals('Function MyFunction('#13#10#32#32'Param1 : Integer'#13#10') : Integer', FPascalMethod.AsString(True, True));
  AType := TTypes.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('String');
    P := TPascalParameter.Create(pamNone, 'Param2', False, AType, '', scNone, 0, 0);
    FPascalMethod.AddParameter(P);
  Finally
    AType.Free;
  End;
  CheckEquals('Function MyFunction(Param1 : Integer; Param2 : String) : Integer', FPascalMethod.AsString(True, False));
  CheckEquals('Function MyFunction('#13#10#32#32'Param1 : Integer;'#13#10#32#32'Param2 : String'#13#10') : Integer', FPascalMethod.AsString(True, True));
end;

procedure TestTPascalMethod.TestCreate;

Const
  strMethodTypes : Array[mtConstructor..mtFunction] Of String = (
    'Constructor', 'Destructor', 'Procedure', 'Function');
begin
  CheckEquals(strMethodTypes[mtFunction], strMethodTypes[FPascalMethod.MethodType]);
  Checkequals('MyFunction', FPascalMethod.Identifier);
  Checkequals(scPrivate, FPascalMethod.Scope);
  Checkequals(12, FPascalMethod.Line);
  Checkequals(23, FPascalMethod.Column);
end;

procedure TestTPascalMethod.TestReferenceSymbol;
var
  AToken: TTokenInfo;
begin
  AToken := TTokenInfo.Create('Hello', 0, 0, 0, 5, ttIdentifier);
  Try
    CheckEquals(False, FPascalMethod.ReferenceSymbol(AToken));
    //: @todo Requires more tests.
  Finally
    AToken.Free;
  End;
end;

procedure TestTPascalProperty.SetUp;
begin
  FPascalProperty := TPascalProperty.Create('MyProperty', scProtected, 12, 23,
    iiPublicProperty, Nil);
  FPascalProperty.ReturnType := TTypes.Create('', scNone, 0, 0, iiNone, Nil);
  FPascalProperty.ReturnType.AddToken('String');
end;

procedure TestTPascalProperty.TearDown;
begin
  FPascalProperty.Free;
  FPascalProperty := nil;
end;

procedure TestTPascalProperty.TestAsString;
var
  AType: TTypes;
  P: TPascalParameter;
begin
  Checkequals('Property MyProperty : String', FPascalProperty.AsString(True, False));
  Checkequals('Property MyProperty : String'#13#10, FPascalProperty.AsString(True, True));
  AType := TTypes.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('Integer');
    P := TPascalParameter.Create(pamNone, 'Param1', False, AType, '', scNone, 0, 0);
    FPascalProperty.AddParameter(P);
  Finally
    AType.Free;
  End;
  CheckEquals('Property MyProperty[Param1 : Integer] : String', FPascalProperty.AsString(True, False));
  CheckEquals('Property MyProperty['#13#10#32#32'Param1 : Integer'#13#10'] : String'#13#10, FPascalProperty.AsString(True, True));
  AType := TTypes.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('String');
    P := TPascalParameter.Create(pamNone, 'Param2', False, AType, '', scNone, 0, 0);
    FPascalProperty.AddParameter(P);
  Finally
    AType.Free;
  End;
  CheckEquals('Property MyProperty[Param1 : Integer; Param2 : String] : String', FPascalProperty.AsString(True, False));
  CheckEquals('Property MyProperty['#13#10#32#32'Param1 : Integer; '#13#10#32#32'Param2 : String'#13#10'] : String'#13#10, FPascalProperty.AsString(True, True));
  FPascalProperty.ReadSpec := 'FValue';
  FPascalProperty.WriteSpec := 'FValue';
  CheckEquals('Property MyProperty[Param1 : Integer; Param2 : String] : String Read FValue Write FValue', FPascalProperty.AsString(True, False));
  CheckEquals('Property MyProperty['#13#10#32#32'Param1 : Integer; '#13#10#32#32'Param2 : String'#13#10'] : String'#13#10'  Read FValue'#13#10'  Write FValue'#13#10, FPascalProperty.AsString(True, True));
  FPascalProperty.ImplementsSpec.Add('mythingy', iiNone, scNone, Nil);
  FPascalProperty.ImplementsSpec.Add('mythingy2', iiNone, scNone, Nil);
  CheckEquals('Property MyProperty[Param1 : Integer; Param2 : String] : String Read FValue Write FValue Implements mythingy, mythingy2', FPascalProperty.AsString(True, False));
  CheckEquals('Property MyProperty['#13#10#32#32'Param1 : Integer; '#13#10#32#32'Param2 : String'#13#10'] : String'#13#10'  Read FValue'#13#10'  Write FValue'#13#10'  Implements mythingy, mythingy2'#13#10, FPascalProperty.AsString(True, True));
end;

procedure TestTPascalProperty.TestCreate;
begin
  CheckEquals('MyProperty', FPascalProperty.Identifier);
  Checkequals(scProtected, FPascalProperty.Scope);
  Checkequals(12, FPascalProperty.Line);
  Checkequals(23, FPascalProperty.Column);
  CheckEquals(iiPublicProperty, FPascalProperty.ImageIndex);
  CheckEquals(iiProtectedProperty, FPascalProperty.ImageIndexAdjustedForScope);
end;

procedure TestTPropertySpec.SetUp;
begin
  FPropertySpec := TPropertySpec.Create('', scNone, 0, 0, iiNone, Nil);
  FPropertySpec.AddToken('FValue');
end;

procedure TestTPropertySpec.TearDown;
begin
  FPropertySpec.Free;
  FPropertySpec := nil;
end;

procedure TestTPropertySpec.TestAsString;

begin
  CheckEquals('FValue', FPropertySpec.AsString(True, False));
end;

procedure TestTObjectDecl.SetUp;
begin
  FObjectDecl := TObjectDecl.Create('MyObject', scProtected, 12, 23,
    iiPublicObject, Nil);
end;

procedure TestTObjectDecl.TearDown;
begin
  FObjectDecl.Free;
  FObjectDecl := nil;
end;

procedure TestTObjectDecl.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C : TComment;

begin
  CheckEquals(0, FObjectDecl.ElementCount);
  FObjectDecl.CheckDocumentation(boolCascade);
  CheckEquals(1, FObjectDecl.ElementCount);
  CheckEquals('1) Object type ''MyObject'' is undocumented.',
    FObjectDecl.DocConflict(1));
  FObjectDecl.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the object.', 0, 0);
  Try
    FObjectDecl.Comment := C;
    FObjectDecl.CheckDocumentation(boolCascade);
    CheckEquals(0, FObjectDecl.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTObjectDecl.TestCreate;
begin
  CheckEquals('MyObject', FObjectDecl.Identifier);
  Checkequals(scProtected, FObjectDecl.Scope);
  Checkequals(12, FObjectDecl.Line);
  Checkequals(23, FObjectDecl.Column);
  CheckEquals(iiPublicObject, FObjectDecl.ImageIndex);
  CheckEquals(iiProtectedObject, FObjectDecl.ImageIndexAdjustedForScope);
end;

procedure TestTObjectDecl.TestAsString;
begin
  CheckEquals('MyObject = Object', FObjectDecl.AsString(True, False));
end;

procedure TestTObjectDecl.TestReferenceSymbol;
var
  AToken: TTokenInfo;
begin
  AToken := TTokenInfo.Create('Hello', 0, 0, 0, 5, ttIdentifier);
  Try
    CheckEquals(False, FObjectDecl.ReferenceSymbol(AToken));
    //: @todo Requires more tests.
  Finally
    AToken.Free;
  End;
end;

procedure TestTClassDecl.SetUp;
begin
  FClassDecl := TClassDecl.Create('MyClass', scPublic, 12, 23, iiPublicClass, Nil);
end;

procedure TestTClassDecl.TearDown;
begin
  FClassDecl.Free;
  FClassDecl := nil;
end;

procedure TestTClassDecl.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FClassDecl.ElementCount);
  FClassDecl.CheckDocumentation(boolCascade);
  CheckEquals(1, FClassDecl.ElementCount);
  CheckEquals('1) Class type ''MyClass'' is undocumented.',
    FClassDecl.DocConflict(1));
  FClassDecl.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the class.', 0, 0);
  Try
    FClassDecl.Comment := C;
    FClassDecl.CheckDocumentation(boolCascade);
    CheckEquals(0, FClassDecl.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTClassDecl.TestCreate;
begin
  CheckEquals('MyClass', FClassDecl.Identifier);
  Checkequals(scPublic, FClassDecl.Scope);
  Checkequals(12, FClassDecl.Line);
  Checkequals(23, FClassDecl.Column);
  CheckEquals(iiPublicClass, FClassDecl.ImageIndex);
  CheckEquals(iiPublicClass, FClassDecl.ImageIndexAdjustedForScope);
end;

procedure TestTClassDecl.TestAsString;

Var
  H1, H2 : TTokenInfo;

begin
  CheckEquals('MyClass = Class', FClassDecl.AsString(True, False));
  H1 := TTokenInfo.Create('TObject', 0, 0, 0, 7, ttIdentifier);
  Try
    FClassDecl.Heritage.Add(H1, scNone, iiNone, Nil);
    CheckEquals('MyClass = Class(TObject)', FClassDecl.AsString(True, False));
    H2 := TTokenInfo.Create('IMyInterface', 0, 0, 0, 7, ttIdentifier);
    Try
      FClassDecl.Heritage.Add(H2, scNone, iiNone, Nil);
      CheckEquals('MyClass = Class(TObject, IMyInterface)', FClassDecl.AsString(True, False));
      FClassDecl.AbstractClass := True;
      CheckEquals('MyClass = Class Abstract(TObject, IMyInterface)', FClassDecl.AsString(True, False));
      FClassDecl.AbstractClass := False;
      FClassDecl.SealedClass := True;
      CheckEquals('MyClass = Class Sealed(TObject, IMyInterface)', FClassDecl.AsString(True, False));
      FClassDecl.SealedClass := False;
      FClassDecl.HelperClass := True;
      FClassDecl.HelperClassName := 'TSomething';
      CheckEquals('MyClass = Class Helper(TObject, IMyInterface) For TSomething', FClassDecl.AsString(True, False));
    Finally
      H2.Free;
    End;
  Finally
    H1.Free;
  End;
end;

procedure TestTClassDecl.TestReferenceSymbol;
var
  AToken: TTokenInfo;
begin
  AToken := TTokenInfo.Create('Hello', 0, 0, 0, 5, ttIdentifier);
  Try
    CheckEquals(False, FClassDecl.ReferenceSymbol(AToken));
    //: @todo Requires more tests.
  Finally
    AToken.Free;
  End;
end;

procedure TestTInterfaceDecl.SetUp;
begin
  FInterfaceDecl := TInterfaceDecl.Create('MyInterface', scPublished, 12, 23,
    iiPublicInterface, Nil);
end;

procedure TestTInterfaceDecl.TearDown;
begin
  FInterfaceDecl.Free;
  FInterfaceDecl := nil;
end;

procedure TestTInterfaceDecl.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FInterfaceDecl.ElementCount);
  FInterfaceDecl.CheckDocumentation(boolCascade);
  CheckEquals(1, FInterfaceDecl.ElementCount);
  CheckEquals('1) Interface type ''MyInterface'' is undocumented.',
    FInterfaceDecl.DocConflict(1));
  FInterfaceDecl.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the Interface.', 0, 0);
  Try
    FInterfaceDecl.Comment := C;
    FInterfaceDecl.CheckDocumentation(boolCascade);
    CheckEquals(0, FInterfaceDecl.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTInterfaceDecl.TestCreate;
begin
  CheckEquals('MyInterface', FInterfaceDecl.Identifier);
  Checkequals(scPublished, FInterfaceDecl.Scope);
  Checkequals(12, FInterfaceDecl.Line);
  Checkequals(23, FInterfaceDecl.Column);
  CheckEquals(iiPublicInterface, FInterfaceDecl.ImageIndex);
  CheckEquals(iiPublishedInterface, FInterfaceDecl.ImageIndexAdjustedForScope);
end;

procedure TestTInterfaceDecl.TestAsString;
var
  H: TTokenInfo;
begin
  CheckEquals('MyInterface = Interface', FInterfaceDecl.AsString(True, False));
  H := TTokenInfo.Create('IUnknown', 0, 0, 0, 7, ttIdentifier);
  Try
    FInterfaceDecl.Heritage.Add(H, scNone, iiNone, Nil);
    CheckEquals('MyInterface = Interface(IUnknown)', FInterfaceDecl.AsString(True, False));
  Finally
    H.Free;
  End;
end;

procedure TestTDispInterfaceDecl.SetUp;
begin
  FDispInterfaceDecl := TDispInterfaceDecl.Create('MyDispInterface', scPrivate,
    12, 23, iiPublicDispInterface, Nil);
end;

procedure TestTDispInterfaceDecl.TearDown;
begin
  FDispInterfaceDecl.Free;
  FDispInterfaceDecl := nil;
end;

procedure TestTDispInterfaceDecl.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FDispInterfaceDecl.ElementCount);
  FDispInterfaceDecl.CheckDocumentation(boolCascade);
  CheckEquals(1, FDispInterfaceDecl.ElementCount);
  CheckEquals('1) DispInterface type ''MyDispInterface'' is undocumented.',
    FDispInterfaceDecl.DocConflict(1));
  FDispInterfaceDecl.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the DispInterface.', 0, 0);
  Try
    FDispInterfaceDecl.Comment := C;
    FDispInterfaceDecl.CheckDocumentation(boolCascade);
    CheckEquals(0, FDispInterfaceDecl.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTDispInterfaceDecl.TestCreate;
begin
  CheckEquals('MyDispInterface', FDispInterfaceDecl.Identifier);
  Checkequals(scPrivate, FDispInterfaceDecl.Scope);
  Checkequals(12, FDispInterfaceDecl.Line);
  Checkequals(23, FDispInterfaceDecl.Column);
  CheckEquals(iiPublicDispInterface, FDispInterfaceDecl.ImageIndex);
  CheckEquals(iiPrivateDispInterface, FDispInterfaceDecl.ImageIndexAdjustedForScope);
end;

procedure TestTDispInterfaceDecl.TestAsString;
var
  H : TTokenInfo;
begin
  CheckEquals('MyDispInterface = DispInterface', FDispInterfaceDecl.AsString(True, False));
  H := TTokenInfo.Create('IUnknown', 0, 0, 0, 7, ttIdentifier);
  Try
    FDispInterfaceDecl.Heritage.Add(H, scNone, iiNone, Nil);
    CheckEquals('MyDispInterface = DispInterface(IUnknown)', FDispInterfaceDecl.AsString(True, False));
  Finally
    H.Free;
  End;
end;

procedure TestTConstant.SetUp;
begin
  FConstant := TConstant.Create('MyConstant', scPrivate, 12, 23,
    iiPublicConstant, Nil);
  FConstant.AddToken('1');
end;

procedure TestTConstant.TearDown;
begin
  FConstant.Free;
  FConstant := nil;
end;

procedure TestTConstant.TestAsString;
begin
  Checkequals('MyConstant = 1', FConstant.AsString(True, False));
  FConstant.AddToken('+');
  FConstant.AddToken('2');
  FConstant.AddToken('*');
  FConstant.AddToken('3');
  Checkequals('MyConstant = 1 + 2 * 3', FConstant.AsString(True, False));
end;

procedure TestTConstant.TestCreate;
begin
  CheckEquals('MyConstant', FConstant.Identifier);
  Checkequals(scPrivate, FConstant.Scope);
  Checkequals(12, FConstant.Line);
  Checkequals(23, FConstant.Column);
  CheckEquals(iiPublicConstant, FConstant.ImageIndex);
  CheckEquals(iiPrivateConstant, FConstant.ImageIndexAdjustedForScope);
end;

procedure TestTResourceString.SetUp;
begin
  FResourceString := TResourceString.Create('MyResourceString', scPublic,
    12, 23, iiPublicResourceString, Nil);
  FResourceString.AddToken('''This is a string literal.''');
end;

procedure TestTResourceString.TearDown;
begin
  FResourceString.Free;
  FResourceString := nil;
end;

procedure TestTResourceString.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FResourceString.ElementCount);
  FResourceString.CheckDocumentation(boolCascade);
  CheckEquals(1, FResourceString.ElementCount);
  Checkequals('1) Resource string ''MyResourceString'' is undocumented.',
    FResourceString.DocConflict(1));
  FResourceString.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the resource string.', 0, 0);
  Try
    FResourceString.Comment := C;
    FResourceString.CheckDocumentation(boolCascade);
    CheckEquals(0, FResourceString.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTResourceString.TestCreate;
begin
  CheckEquals('MyResourceString', FResourceString.Identifier);
  Checkequals(scPublic, FResourceString.Scope);
  Checkequals(12, FResourceString.Line);
  Checkequals(23, FResourceString.Column);
  CheckEquals(iiPublicResourceString, FResourceString.ImageIndex);
  CheckEquals(iiPublicResourceString, FResourceString.ImageIndexAdjustedForScope);
end;

procedure TestTVar.SetUp;
begin
  FVar := TVar.Create('MyVar', scPrivate, 12, 23, iiPublicVariable, Nil);
  FVar.AddToken('Integer');
end;

procedure TestTVar.TearDown;
begin
  FVar.Free;
  FVar := nil;
end;

procedure TestTVar.TestAsString;
begin
  Checkequals('MyVar : Integer', FVar.AsString(True, False));
end;

procedure TestTVar.TestCreate;
begin
  CheckEquals('MyVar', FVar.Identifier);
  Checkequals(scPrivate, FVar.Scope);
  Checkequals(12, FVar.Line);
  Checkequals(23, FVar.Column);
  CheckEquals(iiPublicVariable, FVar.ImageIndex);
  CheckEquals(iiPrivateVariable, FVar.ImageIndexAdjustedForScope);
end;

procedure TestTThreadVar.SetUp;
begin
  FThreadVar := TThreadVar.Create('MyThreadVar', scPrivate, 12, 23,
    iiPublicThreadVar, Nil);
end;

procedure TestTThreadVar.TearDown;
begin
  FThreadVar.Free;
  FThreadVar := nil;
end;

procedure TestTThreadVar.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FThreadVar.ElementCount);
  FThreadVar.CheckDocumentation(boolCascade);
  CheckEquals(1, FThreadVar.ElementCount);
  Checkequals('1) Thread variable ''MyThreadVar'' is undocumented.',
    FThreadVar.DocConflict(1));
  FThreadVar.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the threadvar.', 0, 0);
  Try
    FThreadVar.Comment := C;
    FThreadVar.CheckDocumentation(boolCascade);
    CheckEquals(0, FThreadVar.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTThreadVar.TestCreate;
begin
  CheckEquals('MyThreadVar', FThreadVar.Identifier);
  Checkequals(scPrivate, FThreadVar.Scope);
  Checkequals(12, FThreadVar.Line);
  Checkequals(23, FThreadVar.Column);
  CheckEquals(iiPublicThreadVar, FThreadVar.ImageIndex);
  CheckEquals(iiPrivateThreadVar, FThreadVar.ImageIndexAdjustedForScope);
end;

procedure TestTField.SetUp;
begin
  FField := TField.Create('MyField', scPublic, 12, 23, iiPublicField, Nil);
  FField.AddToken('Integer');
end;

procedure TestTField.TearDown;
begin
  FField.Free;
  FField := nil;
end;

procedure TestTField.TestAsString;
begin
  CheckEquals('MyField : Integer', FField.AsString(True, False));
end;

procedure TestTField.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FField.ElementCount);
  FField.CheckDocumentation(boolCascade);
  CheckEquals(1, FField.ElementCount);
  Checkequals('1) Field ''MyField'' is undocumented.',
    FField.DocConflict(1));
  FField.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the field.', 0, 0);
  Try
    FField.Comment := C;
    FField.CheckDocumentation(boolCascade);
    CheckEquals(0, FField.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTField.TestCreate;
begin
  CheckEquals('MyField', FField.Identifier);
  Checkequals(scPublic, FField.Scope);
  Checkequals(12, FField.Line);
  Checkequals(23, FField.Column);
  CheckEquals(iiPublicField, FField.ImageIndex);
  CheckEquals(iiPublicField, FField.ImageIndexAdjustedForScope);
end;

procedure TestTExportsItem.SetUp;
begin
  FExportsItem := TExportsItem.Create('MyMethod', scPublic, 12, 23,
    iiPublicExportedFunction, Nil);
end;

procedure TestTExportsItem.TearDown;
begin
  FExportsItem.Free;
  FExportsItem := nil;
end;

procedure TestTExportsItem.TestAsString;
begin
  Checkequals('MyMethod', FExportsItem.AsString(True, False));
end;

procedure TestTExportsItem.TestCreate;
begin
  CheckEquals('MyMethod', FExportsItem.Identifier);
  Checkequals(scPublic, FExportsItem.Scope);
  Checkequals(12, FExportsItem.Line);
  Checkequals(23, FExportsItem.Column);
  CheckEquals(iiPublicExportedFunction, FExportsItem.ImageIndex);
  CheckEquals(iiPublicExportedFunction, FExportsItem.ImageIndexAdjustedForScope);
end;

procedure TestTInitializationSection.SetUp;
begin
  FInitializationSection := TInitializationSection.Create('Initialization',
    scNone, 12, 23, iiInitialization, Nil);
end;

procedure TestTInitializationSection.TearDown;
begin
  FInitializationSection.Free;
  FInitializationSection := nil;
end;

procedure TestTInitializationSection.TestAsString;
begin
  Checkequals('Initialization', FInitializationSection.AsString(True, False));
end;

procedure TestTInitializationSection.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FInitializationSection.ElementCount);
  FInitializationSection.CheckDocumentation(boolCascade);
  CheckEquals(1, FInitializationSection.ElementCount);
  CheckEquals('1) The module is missing an Initialization comment.',
    FInitializationSection.DocConflict(1));
  FInitializationSection.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the initialisation section.', 0, 0);
  Try
    FInitializationSection.Comment := C;
    FInitializationSection.CheckDocumentation(boolCascade);
    CheckEquals(0, FInitializationSection.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTInitializationSection.TestCreate;
begin
  CheckEquals('Initialization', FInitializationSection.Identifier);
  Checkequals(scNone, FInitializationSection.Scope);
  Checkequals(12, FInitializationSection.Line);
  Checkequals(23, FInitializationSection.Column);
  CheckEquals(iiInitialization, FInitializationSection.ImageIndex);
  CheckEquals(iiInitialization, FInitializationSection.ImageIndexAdjustedForScope);
end;

procedure TestTFinalizationSection.SetUp;
begin
  FFinalizationSection := TFinalizationSection.Create('Finalization',
    scNone, 12, 23, iiFinalization, Nil);
end;

procedure TestTFinalizationSection.TearDown;
begin
  FFinalizationSection.Free;
  FFinalizationSection := nil;
end;

procedure TestTFinalizationSection.TestAsString;
begin
  Checkequals('Finalization', FFinalizationSection.AsString(True, False));
end;

procedure TestTFinalizationSection.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FFinalizationSection.ElementCount);
  FFinalizationSection.CheckDocumentation(boolCascade);
  CheckEquals(1, FFinalizationSection.ElementCount);
  CheckEquals('1) The module is missing an Finalization comment.',
    FFinalizationSection.DocConflict(1));
  FFinalizationSection.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the finalisation section.', 0, 0);
  Try
    FFinalizationSection.Comment := C;
    FFinalizationSection.CheckDocumentation(boolCascade);
    CheckEquals(0, FFinalizationSection.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTFinalizationSection.TestCreate;
begin
  CheckEquals('Finalization', FFinalizationSection.Identifier);
  Checkequals(scNone, FFinalizationSection.Scope);
  Checkequals(12, FFinalizationSection.Line);
  Checkequals(23, FFinalizationSection.Column);
  CheckEquals(iiFinalization, FFinalizationSection.ImageIndex);
  CheckEquals(iiFinalization, FFinalizationSection.ImageIndexAdjustedForScope);
end;

//
// Test methods for the class TPascalModule.
//
Procedure TestTPascalModule.Setup;

Begin
  FSource :=
    '(**'#13#10 +
    '  Hello description.'#13#10 +
    '  @Date ' + FormatDateTime('dd mmm yyyy', Now) + #13#10 +
    '  @Author David Hoyle'#13#10 +
    '  @Version 1.0'#13#10 +
    '**)'#13#10 +
    'Program Hello;'#13#10 +
    ''#13#10 +
    'Var'#13#10 +
    '  (** Hello variable **)'#13#10 +
    '  Hello : Integer;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  // Do nothing.'#13#10 +
    'End.'#13#10;
  FPascalModule := TPascalModule.CreateParser(FSource, 'Hello.dpr', True,
    [moParse, moCheckForDocumentConflicts]);
End;

Procedure TestTPascalModule.TearDown;

Begin
  FPascalModule.Free;
End;

procedure TestTPascalModule.TestAddOp;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  i := 1 + 2;'#13#10 +
    '  j := Hello - i;'#13#10 +
    '  k := $FF OR $12;'#13#10 +
    '  l := $FF XOR 123;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestAdvancedRecords;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyRec1 = Record'#13#10 +
    '  private '#13#10 +
    '    Field1 : String'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    '  TMyRec2 = Record'#13#10 +
    '  strict protected '#13#10 +
    '    Field1 : String'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    '  TMyRec3 = Record'#13#10 +
    '  strict protected '#13#10 +
    '    Field1 : String'#13#10 +
    '    Field2 : String'#13#10 +
    '  strict protected '#13#10 +
    '    function hello : string;'#13#10 +
    '  public '#13#10 +
    '    procedure goodbye;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    '  TMyRec4 = Record'#13#10 +
    '  strict protected '#13#10 +
    '    Field1 : String'#13#10 +
    '    Field2 : String'#13#10 +
    '  strict protected '#13#10 +
    '    function hello : string;'#13#10 +
    '  public '#13#10 +
    '    procedure goodbye;'#13#10 +
    '  published '#13#10 +
    '    class operator Implicit(A : Integer) : Integer;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestArrayConstant;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  j : Array[1..2] Of String = (''one'', ''two'');'#13#10 +
    '  i : Array[1..2] Of Integer = (1, 2);'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestArrayType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = Array of Integer;'#13#10 +
    '  t02 = Array[1..2] Of String Platform;'#13#10 +
    '  t03 = Array[1 + 2..3*9] of Byte;'#13#10 +
    '  t04 = Array[1, 2, 3] of Integer;'#13#10 +
    '  t05 = Array[1..2, 0..2] of String;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TArrayType.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestAssemblerStatement;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  asm'#13#10 +
    '    MOV DX,BX'#13#10 +
    '  end;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Procedure Hello2;'#13#10 +
    ''#13#10 +
    '  asm'#13#10 +
    '    MOV DX,BX'#13#10 +
    '  end;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

Procedure TestTPascalModule.TestAsString;

Begin
  CheckEquals('Program Hello', FPascalModule.AsString(True, False));
End;

procedure TestTPascalModule.TestBlock;

Const
  strSource =
    'Program MyProgram;'#13#10 +
    ''#13#10 +
    'ResourceString'#13#10 +
    '  strHello = ''Hello'';'#13#10 +
    ''#13#10 +
    'Exports'#13#10 +
    ' DGHProc1;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  WriteLn(strHello);'#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCaseLabel;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  case i of'#13#10 +
    '    1..2 * 3 / 4: Hello;'#13#10 +
    '  end;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCaseSelector;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  case i of'#13#10 +
    '    1, 2, 3, 4: Hello;'#13#10 +
    '  end;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCaseStmt;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  case i of'#13#10 +
    '    1: Hello;'#13#10 +
    '  end;'#13#10 +
    '  case i of '#13#10 +
    '    2: Goodbye;'#13#10 +
    '  else'#13#10 +
    '    exit;'#13#10 +
    '  end;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestClassFieldList;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyClass = Class'#13#10 +
    '  private'#13#10 +
    '    MyPrivateField : Integer;'#13#10 +
    '  protected'#13#10 +
    '    MyProtectedField1, MyProtectedField2 : Integer;'#13#10 +
    '  public'#13#10 +
    '    MyPublicField : String;'#13#10 +
    '  published'#13#10 +
    '    MyPublishedField : Boolean;'#13#10 +
    '  strict private'#13#10 +
    '    MyStrictPrivateField : TMyClass;'#13#10 +
    '  strict protected'#13#10 +
    '    MyStrictProtectedField : TMyClass;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
    P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
    Try
      //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
      CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
      CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    Finally
      P.Free;
    End;
end;

procedure TestTPascalModule.TestClassHeritage;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyClass1 = Class(TObject)'#13#10 +
    '  End;'#13#10 +
    '  MyClass1 = Class(TObject, IMyInterface, IMyOtherInterface)'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
    P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
    Try
      //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
      CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
      CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    Finally
      P.Free;
    End;
end;

procedure TestTPascalModule.TestClassMethodList;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '  private'#13#10 +
    '    Procedure MyPrivateMethod;'#13#10 +
    '  protected'#13#10 +
    '    Function MyProtectedMethod : Boolean;'#13#10 +
    '  public'#13#10 +
    '    Constructor MyPublicMehod;'#13#10 +
    '    Constructor MyPublicMehod2;'#13#10 +
    '  published'#13#10 +
    '    Destructor MyPublishedMethod;'#13#10 +
    '  strict private'#13#10 +
    '    Procedure MyStrictPrivateMethod;'#13#10 +
    '  strict protected'#13#10 +
    '    Function MyStrictProtectedMethod : String;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure TMyClass.MyPrivateMethod; Begin End;'#13#10 +
    'Function TMyClass.MyProtectedMethod : Boolean; Begin End;'#13#10 +
    'Constructor TMyClass.MyPublicMehod; Begin End;'#13#10 +
    'Constructor TMyClass.MyPublicMehod2; Begin End;'#13#10 +
    'Destructor TMyClass.MyPublishedMethod; Begin End;'#13#10 +
    'Procedure TMyClass.MyStrictPrivateMethod; Begin End;'#13#10 +
    'Function TMyClass.MyStrictProtectedMethod : String; Begin End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestClassPropertyList;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '  private'#13#10 +
    '    Property MyPrivateProperty;'#13#10 +
    '  protected'#13#10 +
    '    Property MyProtectedProperty : Boolean;'#13#10 +
    '  public'#13#10 +
    '    Property MyPublicProperty;'#13#10 +
    '  published'#13#10 +
    '    Property MyPublishedProperty;'#13#10 +
    '  strict private'#13#10 +
    '    Property MyStrictPrivateProperty;'#13#10 +
    '  strict protected'#13#10 +
    '    Property MyStrictProtectedProperty;'#13#10 +
    '    Property MyStrictProtectedProperty2;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestClassRefType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  a = Class of TClass;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestClassType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyClass1 = Class'#13#10 +
    '  End;'#13#10 +
    '  MyClass2 = Class Abstract'#13#10 +
    '  End;'#13#10 +
    '  MyClass3 = Class Sealed'#13#10 +
    '  End;'#13#10 +
    '  MyClass4 = Class Helper For TMyClass'#13#10 +
    '  End;'#13#10 +
    '  MyClass5 = Class Helper (TMyClass) For TMyClass'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestClassVarSection;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  c1 = Class'#13#10 +
    '  var'#13#10 +
    '    v1, v2 : Integer;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  c2 = Class'#13#10 +
    '  Field : TField;'#13#10 +
    '  var'#13#10 +
    '    v3, v4 : Integer;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T, C: TElementContainer;
  i: Integer;
  V: TElementContainer;
  j: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        Begin
          C := T.Elements[i];
          V := C.FindElement(strClassVarsLabel);
          Check(T <> Nil, 'Can not find ClassVars label.');
          If V <> Nil Then
            Begin
              For j := 1 To V.ElementCount Do
                CheckEquals(TVar.ClassName, V.Elements[j].ClassName);
            End;
        End;
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestClassVisibility;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyClass = Class'#13#10 +
    '  private'#13#10 +
    '  protected'#13#10 +
    '  public'#13#10 +
    '  published'#13#10 +
    '  strict private'#13#10 +
    '  strict protected'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure01;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  With TMyClass.Create(Nil) Do '#13#10 +
    '    DoSomething;'#13#10 +
    '  With TMyClass.Create(Nil), MyObject Do '#13#10 +
    '    DoSomething(MyObjectField);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure02;

Const
  strSource =
    '(**'#13#10 +
    '  This is a description.'#13#10 +
    '  @date %s'#13#10 +
    '  @author DGH'#13#10 +
    '  @version 0.9'#13#10 +
    '**)'#13#10 +
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    '(**'#13#10 +
    '  This is a description.'#13#10 +
    '  @precon  None.'#13#10 +
    '  @postcon None.'#13#10 +
    '  @param   Ident as an Array Of String'#13#10 +
    '**)'#13#10 +
    'Procedure Hello1(Ident : Array of String);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    '(**'#13#10 +
    '  This is a description.'#13#10 +
    '  @precon  None.'#13#10 +
    '  @postcon None.'#13#10 +
    '  @param   Ident as an Array Of Const'#13#10 +
    '**)'#13#10 +
    'Procedure Hello2(Ident : Array of Const);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  I: TElementContainer;
  M: TPascalMethod;

begin
  P := TPascalModule.CreateParser(Format(strSource, [FormatDateTime('dd mmm yyyy',
    Now)]), '', True, [moParse, moCheckForDocumentConflicts]);
  Try
    CheckEquals(0, P.HeadingCount(strDocumentationConflicts), P.DocConflict(1));
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    I := P.FindElement(strImplementedMethodsLabel);
    Check(I <> Nil, 'Implemented Methods Not Found!');
    M := I.FindElement('Hello1', ftIdentifier) As TPascalMethod;
    Check(M <> Nil, 'Method Hello1 NOT Found');
    CheckEquals('Ident : Array Of String', M.Parameters[0].AsString(True, False));
    M := I.FindElement('Hello2', ftIdentifier) As TPascalMethod;
    Check(M <> Nil, 'Method Hello2 NOT Found');
    CheckEquals('Ident : Array Of Const', M.Parameters[0].AsString(True, False));
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure03;

Const
  strSource =
    '(**'#13#10 +
    '  This is a description.'#13#10 +
    '  @date %s'#13#10 +
    '  @author DGH'#13#10 +
    '  @version 0.9'#13#10 +
    '**)'#13#10 +
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    '  {$R *.res}'#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(Format(strSource, [FormatDateTime('dd mmm yyyy',
    Now)]), '', True, [moParse, moCheckForDocumentConflicts]);
  Try
    CheckEquals(0, P.HeadingCount(strDocumentationConflicts), P.DocConflict(1));
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure04;

Const
  strSource =
    'Library MyLibrary;'#13#10 +
    ''#13#10 +
    'Uses'#13#10 +
    '  Windows;'#13#10 +
    ''#13#10 +
    'Exports'#13#10 +
    '  MyFunc;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure05;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  try'#13#10 +
    '    AMethod;'#13#10 +
    '    fail(''Expected exception not raised'');'#13#10 +
    '  except'#13#10 +
    '    on E: Exception do'#13#10 +
    '    begin'#13#10 +
    '      if E.ClassType <> AExceptionClass then'#13#10 +
    '        raise;'#13#10 +
    '    end'#13#10 +
    '  end;'#13#10 +
    'end;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', True, [moParse,
    moCheckForDocumentConflicts]);
  Try
    //CheckEquals(0, P.HeadingCount(strDocumentationConflicts), P.DocConflict(1));
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure06;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  ProtectedFields: string ='#13#10 +
    '    (''Call_Number,DatIns,DatFup,DatFin,EmpIns,EmpFup,EmpFin,Status,DIS_FileOrg,'''#13#10 +
    '    +''DIS_MailFrom,DIS_MailTo,Emp_Email,Dep_Email,Act_CallID,DIS_CallID'''#13#10 +
    '    +''EmpChg,DatChg,Act_Memo,Cost_CallID,Cost_Value,Call_Cost'');'#13#10 +
    '    '#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure07;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'var'#13#10 +
    '  TagSymbols: array[TTag] of string ='#13#10 +
    '    ('''', ''LINK'', ''IMAGE'', ''TABLE'', ''IMAGEMAP'', ''OBJECT'', ''EMBED'');'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure08;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  a = 123;'#13#10 +
    '  b = 234.567;'#13#10 +
    '  c = $123;'#13#10 +
    '  d = $FFEE00;'#13#10 +
    '  e = 12.345e-12;'#13#10 +
    '  f = 23.456e+34;'#13#10 +
    '  '#13#10 +
    '  '#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure11;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'var'#13#10 +
    '  StandardOLEFormat: TFormatEtc = ('#13#10 +
    '    // Format must later be set.'#13#10 +
    '    cfFormat: 0;'#13#10 +
    '    // No specific target device to render on.'#13#10 +
    '    ptd: nil;'#13#10 +
    '    // Normal content to render.'#13#10 +
    '    dwAspect: DVASPECT_CONTENT;'#13#10 +
    '    // No specific page of multipage data (we don''t use multipage data by default).'#13#10 +
    '    lindex: -1;'#13#10 +
    '    // Acceptable storage formats are IStream and global memory. The first is preferred.'#13#10 +
    '    tymed: TYMED_ISTREAM or TYMED_HGLOBAL;'#13#10 +
    '  );'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure12;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  Case i Of'#13#10 +
    '    ^L: DoSomething;'#13#10 +
    '  Else'#13#10 +
    '    DoSomethingElse;'#13#10 +
    '  End;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure13;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  MyProc01 : Procedure = Nil;'#13#10 +
    '  MyFunc01 : Function : Integer = Nil;'#13#10 +
    ''#13#10 +
    '  MyProc02 : Procedure StdCall = Nil;'#13#10 +
    '  MyFunc02 : Function : Integer StdCall = Nil;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

// THIS FAILS DUE TO ROLLBACK NOT REINSTATING THE COMPILERSTACK
procedure TestTPascalModule.TestCodeFailure09;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '    {$IFNDEF DELPHI7_UP}'#13#10 +
    '    property Size: LongInt read GetSize;'#13#10 +
    '    {$ENDIF}'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFaliure10;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '    IID_IDropTargetHelper: TGUID = (D1: $4657278B; D2: $411B; D3: $11D2; D4: ($83, $9A, $00, $C0, $4F, $D9, $18, $D0));'#13#10 +
    '    IID_IDragSourceHelper: TGUID = (D1: $DE5BF786; D2: $477A; D3: $11D2; D4: ($83, $9D, $00, $C0, $4F, $D9, $18, $D0));'#13#10 +
    '    IID_IDropTarget: TGUID = (D1: $00000122; D2: $0000; D3: $0000; D4: ($C0, $00, $00, $00, $00, $00, $00, $46));'#13#10 +
    '    CLSID_DragDropHelper: TGUID = (D1: $4657278A; D2: $411B; D3: $11D2; D4: ($83, $9A, $00, $C0, $4F, $D9, $18, $D0));'#13#10 +
    '  '#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure14;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class(TObject, IMyInterface)'#13#10 +
    '  Protected'#13#10 +
    '    function IMyInterface.DoSomething = DoSomething; '#13#10 +
    '    function DoSomething : Integer; StdCall;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Function TMyClass.DoSomething : Integer;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure15;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '  Private'#13#10 +
    '    property PropertyPageImpl: TPropertyPageImpl read FPropertyPageImpl'#13#10 +
    '      implements IPropertyPage, IPropertyPage2;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
    P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
    Try
      //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
      CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
      CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    Finally
      P.Free;
    End;
end;

procedure TestTPascalModule.TestCodeFailure16;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'procedure TBasicAction.UnRegisterChanges(Value: TBasicActionLink);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  Value.{!}FAction := nil;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure17;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  if (goEditing in Options) and (Char(Msg.CharCode) in [^H, #32..#255]) then'#13#10 +
    '    ShowEditorChar(Char(Msg.CharCode))'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure18;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  try'#13#10 +
    '    Result := StrToDate(DateStr);'#13#10 +
    '  except'#13#10 +
    '    on EConvertError do'#13#10 +
    '    else raise;'#13#10 +
    '  end;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure19;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '    procedure Add(Item: TMenuItem); overload;'#13#10 +
    '    procedure Add(const AItems: array of TMenuItem); overload;'#13#10 +
    ''#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Procedure TMyClass.Add(Item : TMenuItem);'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure TMyClass.Add(const AItems : array of TMenuItem);'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure21;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Procedure Hello; deprecated;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '    function PSExecuteStatement(const ASQL: string; AParams: TParams;'#13#10 +
    '      ResultSet: Pointer = nil): Integer; overload; virtual; deprecated;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Procedure Hello; deprecated;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Function TMyClass.PSExecuteStatement(const ASQL: string; AParams: TParams;'#13#10 +
    '  ResultSet: Pointer = nil): Integer;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCodeFailure22;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Test;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  Str(dblValue:3:4, strValue);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestCompoundStmt;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  begin'#13#10 +
    '    Hello;'#13#10 +
    '    i := 1 + 2 * j;'#13#10 +
    '    Print(j);'#13#10 +
    '  end;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestConditionalStmt;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  if Hello Then'#13#10 +
    '    exit;'#13#10 +
    '  case i of'#13#10 +
    '    1: Exit;'#13#10 +
    '  end;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestConstantDecl;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  c = 0 platform;'#13#10 +
    '  e : String = ''Hello'' library;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'procedure implode(i : Integer);'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  c : Integer = 0;'#13#10 +
    '  e = ''Hello'';'#13#10 +
    ''#13#10 +
    'begin'#13#10 +
    'end;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestConstructorDecl;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Constructor TMyClass.Create; Virtual; Platform'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestConstructorHeading;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyObject = Object(TObject)'#13#10 +
    '  End;'#13#10 +
    '  MySecondObject = Object(TObject)'#13#10 +
    '    Constructor Create(str : String);'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    ''#13#10 +
    'Constructor MySecondObject.Create(str : String);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestConstSection;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  c = 0;'#13#10 +
    '  e = ''Hello'';'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'procedure implode(i : Integer);'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  c = 0;'#13#10 +
    '  e = ''Hello'';'#13#10 +
    '  ex = 1 * 2 + 3 / 4;'#13#10 +
    ''#13#10 +
    'begin'#13#10 +
    'end;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestContainsClause;

Const
  strSource =
    'Package MyPackage;'#13#10 +
    ''#13#10 +
    'Requires'#13#10 +
    '  VCL50;'#13#10 +
    ''#13#10 +
    'Contains'#13#10 +
    '  DGHLibrary In ''DGHLibrary.pas'','#13#10 +
    '  Library In ''Library.pas'';'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

Procedure TestTPascalModule.TestCreateParser;

Begin
  CheckEquals(0, FPascalModule.HeadingCount(strErrors), FPascalModule.FirstError);
  CheckEquals(0, FPascalModule.HeadingCount(strDocumentationConflicts),
    FPascalModule.DocConflict(1));
End;

procedure TestTPascalModule.TestDeclSection;

Const
  strSource =
    'Program MyProgram;'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  c = 0;'#13#10 +
    ''#13#10 +
    'ResourceString'#13#10 +
    '  rs = ''Hello'';'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t = Integer;'#13#10 +
    ''#13#10 +
    'Var'#13#10 +
    '  v : String;'#13#10 +
    ''#13#10 +
    'Threadvar'#13#10 +
    '  tv : Integer;'#13#10 +
    ''#13#10 +
    '  Procedure MyProc;'#13#10 +
    '  '#13#10 +
    '  Label'#13#10 +
    '    DGH;'#13#10 +
    '  '#13#10 +
    '  Const'#13#10 +
    '    c = 0;'#13#10 +
    '  '#13#10 +
    '  ResourceString'#13#10 +
    '    rs = ''Hello'';'#13#10 +
    '  '#13#10 +
    '  Type'#13#10 +
    '    t = Integer;'#13#10 +
    '  '#13#10 +
    '  Var'#13#10 +
    '    v : String;'#13#10 +
    '  '#13#10 +
    '  Begin'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestDesignator;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  QualId;'#13#10 +
    '  QualId.Ident;'#13#10 +
    '  Ident[1 + 2, Hello];'#13#10 +
    '  QualId.ident[1 + 2, Hello];'#13#10 +
    '  Ident^;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestDestructorDecl;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Destructor TMyClass.Destroy; Override; Platform'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestDestructorHeading;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyObject = Object(TObject)'#13#10 +
    '  End;'#13#10 +
    '  MySecondObject = Object(TObject)'#13#10 +
    '    Destructor Destroy(str : String);'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Destructor MySecondObject.Destroy(str : String);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestDirective;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Ident01; abstract;'#13#10 +
    ''#13#10 +
    'Procedure Ident02; assembler;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident03; cdecl;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident04a; dispid 1;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident04; dynamic;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident05; export;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident06; external ''Hello'';'#13#10 +
    ''#13#10 +
    'Procedure Ident07; far;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident08; final;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident09; forward;'#13#10 +
    ''#13#10 +
    'Procedure Ident10; inline;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident11; local;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident12; message WM_QUIT;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident13; near;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident14; overload;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident15; override;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident16; pascal;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident17; register;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident18; reintroduce;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident19; safecall;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident20; stdcall;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident21; varargs;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident22; virtual;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident23; virtual; overload;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident24; virtual overload;'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'Procedure Ident25; virtual overload; platform'#13#10 +
    'Begin End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestDirectives;

Var
  Words : TKeyWords;
  i : Integer;

begin
  Words := FPascalModule.Directives;
  CheckEquals(0, Low(Words));
  CheckEquals(44, High(Words));
  For i := Low(Words) To Pred(High(Words)) Do
    Check(Words[i] < Words[i + 1], Words[i] + '!<' + Words[i + 1]);
end;

procedure TestTPascalModule.TestEnumerateElement;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = (emOne, emTwo, emThree);'#13#10 +
    '  t02 = (emOne = 2, emTwo = 3 * 5, emThree = i * 100);'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TEnumerateType.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestEnumerateType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = (emOne, emTwo, emThree);'#13#10 +
    '  t02 = (emOne = 2, emTwo = 3 * 5, emThree = i * 100);'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TEnumerateType.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestExceptionBlock;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  sl := tstringlist.create;'#13#10 +
    '  try'#13#10 +
    '    sl.clear;'#13#10 +
    '  finally'#13#10 +
    '    sl.free;'#13#10 +
    '  end;'#13#10 +
    '  '#13#10 +
    '  try'#13#10 +
    '    sl.clear;'#13#10 +
    '  except'#13#10 +
    '    on e : exception do'#13#10 +
    '      exit;'#13#10 +
    '  end;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestExportedHeading;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'procedure implode(i : Integer); stdcall;'#13#10 +
    'function explode(i : Integer) : boolean; pascal;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'procedure implode(i : Integer);'#13#10 +
    'begin'#13#10 +
    'end;'#13#10 +
    ''#13#10 +
    'function explode(i : Integer) : boolean;'#13#10 +
    'begin'#13#10 +
    'end;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestExportsItem;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Exports'#13#10 +
    '  DGHProc1 Name ''DGHProcA'', DGHProc2 Index 1,'#13#10 +
    '  DGHProc3 Name ''Hello'' Index 2, DGHProc4 Index 3 Name ''Hello'';'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestExportsStmt;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Exports'#13#10 +
    '  DGHProc1, DGHProc2;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestExpression;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  i := Hello <> Goodbye;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestExprList;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  i := [1..2, 2, 3];'#13#10 +
    '  i := MyFunc[Hello, 2, 3];'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestFactor;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  Designator;'#13#10 +
    '  Designator(1 + 2, Help);'#13#10 +
    '  o := @Designator;'#13#10 +
    '  i := 1.0;'#13#10 +
    '  str := ''Hello'';'#13#10 +
    '  i := (1 + 2 / 3  *4);'#13#10 +
    '  bool := Not bool;'#13#10 +
    '  Inherited Create;'#13#10 +
    '  i := [1, 2, 3..6];'#13#10 +
    '  TypeId(1 * 2 / 3 * 4);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestFieldDecl;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = Record'#13#10 +
    '    FField1 : Integer platform;'#13#10 +
    '    FField2 : String;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TRecordDecl.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestFieldList;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = Record'#13#10 +
    '    FField1 : Integer;'#13#10 +
    '    FField2 : String;'#13#10 +
    '  End;'#13#10 +
    '  THInfo = Record'#13#10 +
    '    dblBearing : Double;'#13#10 +
    '    Case THInfoType Of'#13#10 +
    '      itSetout  : (dblEasting, dblNorthing  : Double);'#13#10 +
    '      itMeasure, itCompare : (dblChainage : Double;'#13#10 +
    '        Case THInfoType Of'#13#10 +
    '          itMeasure: (dblOffset : Double);'#13#10 +
    '          itCompare: (dblDistance : Double);'#13#10 +
    '    );'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TRecordDecl.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestFileType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = File Of Integer;'#13#10 +
    '  t02 = File Of TSomething platform;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TFileType.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestFormalParam;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Ident(i : Integer; var j : String; const k : Boolean; out l : String);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestFormalParameter;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Ident(i : Integer; j : String; k : Boolean);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestForStmt;

Const
  strSource1 =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  for i := 0 To 10 Do'#13#10 +
    '    Inc(j);'#13#10 +
    '  for i := 10 DownTo 0 Do'#13#10 +
    '    Inc(j);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;
  strSource2 =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  for i in names Do'#13#10 +
    '    Inc(i);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource1, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
  P := TPascalModule.CreateParser(strSource2, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestFunctionDecl;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Function Hello : Integer; StdCall; Library'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestFunctionHeading;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Function Ident : Boolean;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Function Ident2 : String;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Function Ident3(i : Integer) : String;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestGoal;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestIfStmt;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  if Hello Then'#13#10 +
    '    exit;'#13#10 +
    '  if Hello then'#13#10 +
    '    statement'#13#10 +
    '  else'#13#10 +
    '    anotherstatement;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestImplementationSection;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Uses'#13#10 +
    '  Windows, DGHLibrary;'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  c = 1;'#13#10 +
    ''#13#10 +
    'Var'#13#10 +
    '  i : Integer;'#13#10 +
    ''#13#10 +
    'Exports'#13#10 +
    '  DGHProc;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestInitSection;

Const
  strSource1 =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Initialization'#13#10 +
    '  DoSomething;'#13#10 +
    'End.'#13#10;
  strSource2 =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Initialization'#13#10 +
    '  DoSomething;'#13#10 +
    'Finalization'#13#10 +
    '  DoSomethingMore;'#13#10 +
    'End.'#13#10;
  strSource3 =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'BEGIN'#13#10 +
    '  DoSomething;'#13#10 +
    '  DoSomethingMore;'#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource1, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
  P := TPascalModule.CreateParser(strSource2, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
  P := TPascalModule.CreateParser(strSource3, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestInterfaceDecl;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Uses'#13#10 +
    '  Windows;'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t = Integer;'#13#10 +
    ''#13#10 +
    'const'#13#10 +
    '  c = 0;'#13#10 +
    ''#13#10 +
    'resourcestring'#13#10 +
    '  rs = ''hello.'';'#13#10 +
    ''#13#10 +
    'var'#13#10 +
    '  v : string;'#13#10 +
    ''#13#10 +
    'threadvar'#13#10 +
    '  tv : integer;'#13#10 +
    ''#13#10 +
    'Exports'#13#10 +
    '  Blobby;'#13#10 +
    ''#13#10 +
    'procedure implode;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'procedure implode;'#13#10 +
    'begin'#13#10 +
    'end;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestInterfaceHeritage;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyInterface = Interface(IUnknown, IInterfaceedObject, ISomethingElse)'#13#10 +
    '    Procedure MyProc;'#13#10 +
    '    Procedure MyProc2;'#13#10 +
    '    Property Count : Integer Read GetCount;'#13#10 +
    '    Property Count2 : Integer Read GetCount2;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestInterfaceSection;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Uses'#13#10 +
    '  Windows;'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t = Integer;'#13#10 +
    ''#13#10 +
    'var'#13#10 +
    '  v : string;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestInterfaceType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyInterface1 = Interface'#13#10 +
    '  End;'#13#10 +
    '  TMyInterface2 = Interface(IUnknown)'#13#10 +
    '  End;'#13#10 +
    '  TMyInterface3 = Interface(IUnknown)'#13#10 +
    '    Procedure MyProc;'#13#10 +
    '    Procedure MyProc2;'#13#10 +
    '    Property Count : Integer Read GetCount;'#13#10 +
    '    Property Count2 : Integer Read GetCount2;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

Procedure TestTPascalModule.TestReservedWords;

Var
  Words : TKeyWords;
  i : Integer;

Begin
  Words := FPascalModule.ReservedWords;
  CheckEquals(0, Low(Words));
  CheckEquals(73, High(Words));
  For i := Low(Words) To Pred(High(Words)) Do
    Check(Words[i] < Words[i + 1], Words[i] + '!<' + Words[i + 1]);
End;

procedure TestTPascalModule.TestLabelDeclSection;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Label'#13#10 +
    '  Dave, DGH, Hoyle;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  WriteLn(i);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestLoopStmt;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure H73ello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  repeat'#13#10 +
    '    Inc(i);'#13#10 +
    '  until i > 10;'#13#10 +
    '  while i < 0 Do'#13#10 +
    '    Inc(i);'#13#10 +
    '  for i := 0 To 10 Do'#13#10 +
    '    Inc(j);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestMethodHeading;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyObject = Object(TObject)'#13#10 +
    '  End;'#13#10 +
    '  MySecondObject = Object(TObject)'#13#10 +
    '    MyField : Integer;'#13#10 +
    '    Procedure MyMethod;'#13#10 +
    '    Function MyFunction : Integer;'#13#10 +
    '    Constructor Create;'#13#10 +
    '    Destructor Destroy;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyOtherObject = Object(TObject)'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Procedure MySecondObject.MyMethod;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Function MySecondObject.MyFunction : Integer;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Constructor MySecondObject.Create;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Destructor MySecondObject.Destroy;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestMethodList;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyObject = Object(TObject)'#13#10 +
    '  End;'#13#10 +
    '  MySecondObject = Object(TObject)'#13#10 +
    '    MyField : Integer;'#13#10 +
    '    Procedure MyMethod;'#13#10 +
    '    Function MyFunction : Integer;'#13#10 +
    '    Constructor Create;'#13#10 +
    '    Destructor Destroy;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyOtherObject = Object(TObject)'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Procedure MySecondObject.MyMethod;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Function MySecondObject.MyFunction : Integer;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Constructor MySecondObject.Create;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Destructor MySecondObject.Destroy;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestMulOp;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  d := 1.2 * 2.3;'#13#10 +
    '  d := 1.2 / 4.2;'#13#10 +
    '  d := 1 Div 2;'#13#10 +
    '  d := 1 Mod 2;'#13#10 +
    '  d := 1 And 2;'#13#10 +
    '  d := 1 Shr 2;'#13#10 +
    '  d := 1 Shl 2;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestObjectType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyObject = Object'#13#10 +
    '  End;'#13#10 +
    '  MySecondObject = Object'#13#10 +
    '    Procedure MyMethod;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyOtherObject = Object(TObject)'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Procedure MySecondObject.MyMethod;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestObjFieldList;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyObject = Object(TObject)'#13#10 +
    '  End;'#13#10 +
    '  MySecondObject = Object(TObject)'#13#10 +
    '    MyField : Integer;'#13#10 +
    '    MyField2, MyField3 : String;'#13#10 +
    '    Procedure MyMethod;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyOtherObject = Object(TObject)'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Procedure MySecondObject.MyMethod;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestObjHeritage;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyObject = Object(TObject)'#13#10 +
    '  End;'#13#10 +
    '  MySecondObject = Object(TObject)'#13#10 +
    '    MyField : Integer;'#13#10 +
    '    Procedure MyMethod;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  MyOtherObject = Object(TObject)'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Procedure MySecondObject.MyMethod;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestOPLibrary;

Const
  strSource =
    'Library MyLibrary;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  WriteLn(''Hello'');'#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestOPPackage;

Const
  strSource =
    'Package MyPackage;'#13#10 +
    ''#13#10 +
    'Requires'#13#10 +
    '  VCL50;'#13#10 +
    ''#13#10 +
    'Contains'#13#10 +
    '  DGHLibrary In ''DGHLibrary.pas'';'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestOPProgram;

Const
  strSource =
    'Program MyProgram;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  WriteLn(''Hello'');'#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestOPType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  a = THello;'#13#10 +
    '  b = [1..2];'#13#10 +
    '  c = (eOne, eTwo);'#13#10 +
    '  d = record'#13#10 +
    '      end;'#13#10 +
    '  e = ^d;'#13#10 +
    '  f = String;'#13#10 +
    '  g = function(i : Integer) : integer;'#13#10 +
    '  h = variant;'#13#10 +
    '  i = class of THello;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestOPUnit;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Uses'#13#10 +
    '  Windows;'#13#10 +
    ''#13#10 +
    '  Procedure Hello;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  i = 10;'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  WriteLn(i);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestOrdIdent;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = ShortInt;'#13#10 +
    '  t02 = SmallInt;'#13#10 +
    '  t03 = Integer;'#13#10 +
    '  t04 = Byte;'#13#10 +
    '  t05 = LongInt;'#13#10 +
    '  t06 = Int64;'#13#10 +
    '  t07 = Word;'#13#10 +
    '  t08 = Boolean;'#13#10 +
    '  t09 = Char;'#13#10 +
    '  t10 = WideChar;'#13#10 +
    '  t11 = LongWord;'#13#10 +
    '  t12 = PChar;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TOrdIdent.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestOrdinalType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  a = 1..2;'#13#10 +
    '  b = (eOne, eTwo);'#13#10 +
    '  c = Byte;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestParameter;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Ident1(i);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Procedure Ident2(i : Integer);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Procedure Ident3(i : String);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Procedure Ident4(i : File);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Procedure Ident4(i : Array Of Integer);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Procedure Ident5(i : Integer = 0);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestPointerType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = ^Integer;'#13#10 +
    '  t02 = ^TSomething platform;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TPointerType.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestPortabilityDirective;

Const
  strSource =
    'Unit MyUnit platform;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t = Integer library;'#13#10 +
    '  u = Class'#13#10 +
    '    property oops library;'#13#10 +
    '  End deprecated;'#13#10 +
    '  a = Array[1..2] of Integer platform;'#13#10 +
    '  r = record'#13#10 +
    '    myField : String platform;'#13#10 +
    '  end library;'#13#10 +
    '  s = set of integer deprecated;'#13#10 +
    '  f = file of integer deprecated;'#13#10 +
    '  p = ^Integer platform;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  i = 1 deprecated;'#13#10 +
    '  j : Integer = 2 deprecated;'#13#10 +
    ''#13#10 +
    'Var'#13#10 +
    '  k : Integer platform;'#13#10 +
    ''#13#10 +
    'ThreadVar'#13#10 +
    '  str : Integer platform;'#13#10 +
    ''#13#10 +
    'procedure Hello; platform'#13#10 +
    ''#13#10 +
    'begin'#13#10 +
    'end;'#13#10 +
    ''#13#10 +
    'function Hello1 : integer; platform'#13#10 +
    ''#13#10 +
    'begin'#13#10 +
    'end;'#13#10 +
    ''#13#10 +
    'function Hello2 : integer; platform deprecated'#13#10 +
    ''#13#10 +
    'begin'#13#10 +
    'end;'#13#10 +
    ''#13#10 +
    'procedure Hello3; platform; deprecated;'#13#10 +
    ''#13#10 +
    'begin'#13#10 +
    'end;'#13#10 +
    ''#13#10 +
    'constructor create; platform'#13#10 +
    ''#13#10 +
    'begin'#13#10 +
    'end;'#13#10 +
    ''#13#10 +
    'destructor destroy; platform'#13#10 +
    ''#13#10 +
    'begin'#13#10 +
    'end;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestProcedureDecl;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello; Virtual; Platform'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
End;

procedure TestTPascalModule.TestProcedureDeclSection;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Function Hello2 : Boolean;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Constructor Create;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Destructor Destroy;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestProcedureHeading;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Ident;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Procedure Ident2;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Procedure Ident3(i : Integer);'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestProcedureType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = Procedure;'#13#10 +
    '  t02 = Procedure(i : Integer);'#13#10 +
    '  t03 = Procedure(i, j : Integer);'#13#10 +
    '  t04 = Procedure(i, j : Integer; k : Integer);'#13#10 +
    '  t05 = Procedure(i : Integer) Of Object;'#13#10 +
    '  t06 = Function(i, j : Integer; s : String) : Boolean Of Object;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TProcedureType.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

Procedure TestTPascalModule.TestProcessCompilerDirective;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    '{$DEFINE DGH}'#13#10 +
    '{$DEFINE DGH1}'#13#10 +
    '{$UNDEF DGH1}'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    '{$IFDEF DGH}'#13#10 +
    'Const iMyConstant : Integer = 1;'#13#10 +
    '{$ELSE}'#13#10 +
    'Const iMyConstant : Integer = 0;'#13#10 +
    '{$ENDIF}'#13#10 +
    ''#13#10 +
    '{$IFNDEF DGH}'#13#10 +
    'Var iMyVar : Integer;'#13#10 +
    '{$ENDIF}'#13#10 +
    ''#13#10 +
    '{$IFOPT R=}'#13#10 +
    '  WriteLn(''Hello!'');'#13#10 +
    '{$ENDIF}'#13#10 +
    ''#13#10 +
    '{$EXTERNALSYM MySymbol}'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

Begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    CheckEquals(True, P.IfDef('DGH'));
    CheckEquals(False, P.IfDef('DGH1'));
  Finally
    P.Free;
  End;
End;

procedure TestTPascalModule.TestProgramBlock;

Const
  strSource =
    'Program MyProgram;'#13#10 +
    ''#13#10 +
    'Uses'#13#10 +
    '  SysUtils, Windows;'#13#10 +
    ''#13#10 +
    'ResourceString'#13#10 +
    '  strHello = ''Hello'';'#13#10 +
    'Begin'#13#10 +
    '  WriteLn(strHello);'#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestPropertyInterface;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '  private'#13#10 +
    '    Property MyPrivateProperty[Ident1, Ident2 : Integer; Ident3 : String] : Boolean;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestPropertyList;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '  private'#13#10 +
    '    Property MyPrivateProperty;'#13#10 +
    '  protected'#13#10 +
    '    Property MyProtectedProperty : Boolean;'#13#10 +
    '  public'#13#10 +
    '    Property MyPublicProperty[iIndex : Integer] : Boolean;'#13#10 +
    '  published'#13#10 +
    '    Property MyPublishedProperty : String Read FProp;'#13#10 +
    '  strict private'#13#10 +
    '    Property MyStrictPrivateProperty : String Write FProp;'#13#10 +
    '  strict protected'#13#10 +
    '    Property MyStrictProtectedProperty Platform;'#13#10 +
    '    Property MyStrictProtectedProperty2;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestPropertyParameterList;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '  private'#13#10 +
    '    Property MyPrivateProperty[Ident1, Ident2 : Integer; Ident3 : String] : Boolean;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestPropertySpecifiers;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '  private'#13#10 +
    '    Property MyProperty1 : Boolean Index 1 + 2 / 3;'#13#10 +
    '    Property MyProperty2 : Boolean Read FProp;'#13#10 +
    '    Property MyProperty3 : Boolean Write FProp;'#13#10 +
    '    Property MyProperty5 : Boolean Stored FIdent;'#13#10 +
    '    Property MyProperty6 : Boolean Stored Value;'#13#10 +
    '    Property MyProperty7 : Boolean default 1 + 2;'#13#10 +
    '    Property MyProperty8 : Boolean nodefault ;'#13#10 +
    '    Property MyProperty9 : Boolean implements mythingy;'#13#10 +
    '    Property MyPropertyA : Boolean implements mythingy, mythingy2;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestRaiseStmt;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  raise exception.create;'#13#10 +
    '  raise exception.create at $FFFFFFFF;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestRealType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  r1 = Real48;'#13#10 +
    '  r2 = Real;'#13#10 +
    '  r3 = Single;'#13#10 +
    '  r4 = Double;'#13#10 +
    '  r5 = Extended;'#13#10 +
    '  r6 = Currency;'#13#10 +
    '  r7 = Comp;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TRealType.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestRecordConstant;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  k : Array[1..2] of TRec = ('#13#10 +
    '    (Name: ''Hello''; Value : 1),'#13#10 +
    '    (Name: ''Hello''; Value : 1)'#13#10 +
    '  );'#13#10 +
    ''#13#10 +
    'Begin;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestRecordFieldConstant;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  k : Array[1..2] of TRec = ('#13#10 +
    '    (Name: ''Hello''; Value : 1 * 2 + 3 /4),'#13#10 +
    '    (Name: ''Hello''; Value : 1.0)'#13#10 +
    '  );'#13#10 +
    ''#13#10 +
    'Begin;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestRecType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = Record'#13#10 +
    '    FField : Integer;'#13#10 +
    '  End;'#13#10 +
    '  t02 = Record'#13#10 +
    '    FField : Integer;'#13#10 +
    '  End platform;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TRecordDecl.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestRecVariant;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = Record'#13#10 +
    '    FField1 : Integer;'#13#10 +
    '    FField2 : String;'#13#10 +
    '  End;'#13#10 +
    '  THInfo = Record'#13#10 +
    '    dblBearing : Double;'#13#10 +
    '    Case THInfoType Of'#13#10 +
    '      itSetout  : (dblEasting, dblNorthing  : Double);'#13#10 +
    '      itMeasure, itCompare : (dblChainage : Double;'#13#10 +
    '        Case THInfoType Of'#13#10 +
    '          itMeasure: (dblOffset : Double);'#13#10 +
    '          itCompare: (dblDistance : Double);'#13#10 +
    '    );'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TRecordDecl.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

Procedure TestTPascalModule.TestReferenceSymbol;

Var
  T : TTokenInfo;

Begin
  T := TTokenInfo.Create('Hello1', 0, 0, 0, 5, ttIdentifier);
  Try
    CheckEquals(False, FPascalModule.ReferenceSymbol(T));
  Finally
    T.Free;
  End;
  T := TTokenInfo.Create('Hello', 0, 0, 0, 5, ttIdentifier);
  Try
    CheckEquals(True, FPascalModule.ReferenceSymbol(T));
  Finally
    T.Free;
  End;
End;

procedure TestTPascalModule.TestRelOp;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  bool := 1 > 2;'#13#10 +
    '  bool := 1 < 2;'#13#10 +
    '  bool := 1 <= 2;'#13#10 +
    '  bool := 1 >= 2;'#13#10 +
    '  bool := 1 <> 2;'#13#10 +
    '  bool := fsBold In MyStyles;'#13#10 +
    '  bool := MyClass Is TDGHObject;'#13#10 +
    '  (MyObject As TClass);'#13#10 +
    '  bool := 1 = 2;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestRepeatStmt;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  repeat'#13#10 +
    '    Inc(i);'#13#10 +
    '  until i > 10;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestRequiresClause;

Const
  strSource =
    'Package MyPackage;'#13#10 +
    ''#13#10 +
    'Requires'#13#10 +
    '  VCL50,'#13#10 +
    '  DesignIDE;'#13#10 +
    ''#13#10 +
    'Contains'#13#10 +
    '  DGHLibrary In ''DGHLibrary.pas'';'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestResourceStringDecl;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'ResourceString'#13#10 +
    '  str1 = ''Hello'';'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'ResourceString'#13#10 +
    '  str2 = ''Hello'' + '#13#10 +
    '    '' Goodbye'';'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'ResourceString'#13#10 +
    '  str3 = ''Hello'';'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  WriteLn(i);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestResStringSection;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'ResourceString'#13#10 +
    '  str1 = ''Hello'';'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'ResourceString'#13#10 +
    '  str2 = ''Hello'';'#13#10 +
    '  str4 = ''Hello'';'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'ResourceString'#13#10 +
    '  str3 = ''Hello'';'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  WriteLn(i);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestRestrictedType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  a = Object End;'#13#10 +
    '  b = Object(TMyObject)'#13#10 +
    '  End;'#13#10 +
    '  c = Class;'#13#10 +
    '  d = Class(TObecjt)'#13#10 +
    '  End;'#13#10 +
    '  e = Interface;'#13#10 +
    '  f = Interface(IInterface)'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

Procedure TestTPascalModule.TestRTTIAttributesClass;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  [Custom]'#13#10 +
    '  TMyClass = Class(TObject)'#13#10 +
    '  Strict Private'#13#10 +
    '    [Custom(Hello)]'#13#10 +
    '    FInteger : Integer;'#13#10 +
    '  Strict Protected'#13#10 +
    '    [Custom, Custom1(''Hello'')]'#13#10 +
    '    Procedure MyProc(i : Integer); Abstract;'#13#10 +
    '  Public'#13#10 +
    '    [Custom2()]'#13#10 +
    '    Property Int : Integer Read FInteger;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;
Var
  P : TPascalModule;

Begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
End;

Procedure TestTPascalModule.TestRTTIAttributesComplexType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  [Custom(Arguemnt1, Argument2, Argument3)]'#13#10 +
    '  TSimpleType = Set Of (stOne, stTwo, stThree);'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P : TPascalModule;

Begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
End;

Procedure TestTPascalModule.TestRTTIAttributesInterface;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  [Custom(MyInterface, 1)]'#13#10 +
    '  TMyInterface = Interface'#13#10 +
    '    [GetterMethod(1), Custom()]'#13#10 +
    '    Function GetSomething : Boolean;'#13#10 +
    '    [Custom1(MyProc, 1, 2, 3, x, y, z)]'#13#10 +
    '    Property Something : Boolean Read GetSomething;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;
Var
  P : TPascalModule;

Begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
End;

Procedure TestTPascalModule.TestRTTIAttributesMultiFunction;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '    [Custom1, Custom2(MyAergument)]'#13#10 +
    '    Function IsReady : Boolean;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Function TMyClass.IsReady : Boolean;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P : TPascalModule;

Begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
End;

Procedure TestTPascalModule.TestRTTIAttributesRecord;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  [Custom(''Hello'')]'#13#10 +
    '  TMyRecord = Record'#13#10 +
    '    [Custom1, Custom2(MyArgument)]'#13#10 +
    '    FField : Boolean;'#13#10 +
    '    [Custom2(), Custom3, Custom4(i, x, y, z)]'#13#10 +
    '    Procedure MyProc( i : Integer);'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P : TPascalModule;

Begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
End;

Procedure TestTPascalModule.TestRTTIAttributesMultiFields;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '    [Custom1]'#13#10 +
    '    [Custom2(MyArgument)]'#13#10 +
    '    FString : String;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P : TPascalModule;

Begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
End;

Procedure TestTPascalModule.TestRTTIAttributesSingleClass;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  [CustomAttribute]'#13#10 +
    '  TMyClass = Class;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P : TPascalModule;

Begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
End;

Procedure TestTPascalModule.TestRTTIAttributesSingleMethod;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '    [Custom]'#13#10 +
    '    Procedure DoSomething;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure TMyClass.DoSomething;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P : TPascalModule;

Begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
End;

Procedure TestTPascalModule.TestRTTIAttributesSingleProperty;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  TMyClass = Class'#13#10 +
    '    [Custom1, Custom2(MyAergument)]'#13#10 +
    '    Property IsReady : Boolean;'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P : TPascalModule;

Begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
End;

Procedure TestTPascalModule.TestRTTIAttributesSingleRecord;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  [Custom()]'#13#10 +
    '  TMyRecord = Record'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P : TPascalModule;

Begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
End;

Procedure TestTPascalModule.TestRTTIAttributesSingleTypeConst;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  a = 10;'#13#10 +
    '  b = 20;'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  [Something(a + b)]'#13#10 +
    '  TSomeType = Record'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'Procedure DoSomething;'#13#10 +
    ''#13#10 +
    'Var'#13#10 +
    '  rec : TSomeType;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  rec;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'Initialization'#13#10 +
    ' DoSomething;'#13#10 +
    'End.'#13#10;

Var
  P : TPascalModule;

Begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
End;

procedure TestTPascalModule.TestSetConstructor;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  i := [1..2, 4..5, 6, 7];'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestSetElement;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  i := [1..2];'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestSetType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = Set Of TEnum;'#13#10 +
    '  t02 = Set Of TEnums platform;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TSetType.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestSimpleExpression;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  i := + 10 + 1;'#13#10 +
    '  i := - 10 + 1;'#13#10 +
    '  i := - 10 - 1;'#13#10 +
    '  i := + 10 - 1;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestSimpleStatement;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  Designator;'#13#10 +
    '  Designator(1, 2, Hello, ''Qwerty'');'#13#10+
    '  Designator := 1 + 2 / Hello * $FF;'#13#10 +
    '  Inherited Create;'#13#10 +
    '  Goto MyLabel;'#13#10 +
    '  Designator := (Helli + 1 * 4 Shl 5);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestSimpleType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  a = 1..2;'#13#10 +
    '  b = (eOne, eTwo);'#13#10 +
    '  c = Byte;'#13#10 +
    '  d = Single;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestStatement;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Label'#13#10 +
    '  labelID;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'LabelId: Hello;'#13#10 +
    '  SimpleStatement;'#13#10+
    '  If True Then'#13#10 +
    '    Exit;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestStmtList;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Label'#13#10 +
    '  labelID;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'LabelId: Hello;'#13#10 +
    '  SimpleStatement;'#13#10+
    '  If True Then'#13#10 +
    '    Exit;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestStringType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = String;'#13#10 +
    '  t02 = AnsiString;'#13#10 +
    '  t03 = WideString;'#13#10 +
    '  t04 = String[10];'#13#10 +
    '  t05 = String[1 + 2 * 3];'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TStringType.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestStructStmt;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  begin'#13#10 +
    '    i := 1 + 2;'#13#10+
    '  end;'#13#10 +
    '  if i > 0 then'#13#10 +
    '    exit;'#13#10 +
    '  for i := 0 to 1 do'#13#10 +
    '    Dosomething;'#13#10 +
    '  with frogs do'#13#10 +
    '    croak;'#13#10 +
    '  sl := tstringlist.create;'#13#10 +
    '  try'#13#10 +
    '    sl.clear;'#13#10 +
    '  finally'#13#10 +
    '    sl.free;'#13#10 +
    '  end;'#13#10 +
    '  try'#13#10 +
    '    dosomething;'#13#10 +
    '  except'#13#10 +
    '    on e : exception do'#13#10 +
    '      break;'#13#10 +
    '  end;'#13#10 +
    '  raise exception.create(''Hello'');'#13#10 +
    '  asm'#13#10 +
    '    MOV DX,BX'#13#10 +
    '    ADD DX,BS'#13#10 +
    '  end;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestStrucType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = Packed Array of Integer;'#13#10 +
    '  t02 = Set Of Integer;'#13#10 +
    '  t03 = File Of Word;'#13#10 +
    '  t04 = Record'#13#10 +
    '  End;'#13#10 +
    '  t05 = Array Of Byte Packed;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        If T.Elements[i].Identifier <> 't04' Then // Skip record as its derived from TStrictType deliberately
          Check(T.Elements[i] Is TStrucType,
            Format('Expected type ''%s'' but found ''%s''.', [
            TStrucType.ClassName, T.Elements[i].ClassName]));
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestSubRangeType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = 1..2;'#13#10 +
    '  t02 = i..j;'#13#10 +
    '  t03 = 1 + 2..3 * 4;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TSubRangeType.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestTerm;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  i := 10 * 1;'#13#10 +
    '  i := 10 / 1;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestThreadVarDecl;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'ThreadVar'#13#10 +
    '  v1 : Integer;'#13#10 +
    '  v2 : String;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'ThreadVar'#13#10 +
    '  v3 : String;'#13#10 +
    '  v4, v5, v6 : Integer;'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  V: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    V := P.FindElement(strThreadVarsLabel);
    Check(V <> Nil, 'Can not find ThreadVars label.');
    If V <> Nil Then
      For i := 1 To V.ElementCount Do
        CheckEquals(TThreadVar.ClassName, V.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestThreadVarSection;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'ThreadVar'#13#10 +
    '  v1 : Integer;'#13#10 +
    '  v2 : String;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'ThreadVar'#13#10 +
    '  v3 : String;'#13#10 +
    '  v4, v5, v6 : Integer;'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  V: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    V := P.FindElement(strThreadVarsLabel);
    Check(V <> Nil, 'Can not find ThreadVars label.');
    If V <> Nil Then
      For i := 1 To V.ElementCount Do
        CheckEquals(TThreadVar.ClassName, V.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestTryExceptAndFinallyStmt;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  sl := tstringlist.create;'#13#10 +
    '  try'#13#10 +
    '    sl.clear;'#13#10 +
    '  finally'#13#10 +
    '    sl.free;'#13#10 +
    '  end;'#13#10 +
    '  '#13#10 +
    '  try'#13#10 +
    '    sl.clear;'#13#10 +
    '  except'#13#10 +
    '    on e : exception do'#13#10 +
    '      exit;'#13#10 +
    '  end;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestTypedConstant;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  i : integer = 1 * 2 + 3 /4;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  j : Array[1..2] Of String = (''one'', ''two'');'#13#10 +
    ''#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Const'#13#10 +
    '  k : Array[1..2] of TRec = ('#13#10 +
    '    (Name: ''Hello''; Value : 1),'#13#10 +
    '    (Name: ''Hello''; Value : 1)'#13#10 +
    '  );'#13#10 +
    ''#13#10 +
    'Begin;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestTypeDecl;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t = type Integer platform;'#13#10 +
    '  u = Class;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t1 = Integer;'#13#10 +
    '  u2 = type Class;'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t = type Integer;'#13#10 +
    '  u = Class;'#13#10 +
    ''#13#10 +
    'Begin;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestTypeSection;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t = Integer;'#13#10 +
    '  u = Class;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t1 = Integer;'#13#10 +
    '  u2 = Class;'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t = Integer;'#13#10 +
    '  u = Class;'#13#10 +
    ''#13#10 +
    'Begin;'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestUsesClause;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Uses'#13#10 +
    '  SysUtils, Windows;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Uses'#13#10 +
    '  Classes;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestVarDecl;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Var'#13#10 +
    '  v1 : Integer;'#13#10 +
    '  v2 : String;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Var'#13#10 +
    '  v3 : String;'#13#10 +
    '  v4, v5, v6 : Integer;'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Var'#13#10 +
    '  v13 : String;'#13#10 +
    '  v14, v25, v36 : Integer;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  V: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    V := P.FindElement(strVarsLabel);
    Check(V <> Nil, 'Can not find Vars label.');
    If V <> Nil Then
      For i := 1 To V.ElementCount Do
        CheckEquals(TVar.ClassName, V.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestVariantSection;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = Record'#13#10 +
    '    FField1 : Integer;'#13#10 +
    '    FField2 : String;'#13#10 +
    '  End;'#13#10 +
    '  THInfo = Record'#13#10 +
    '    dblBearing : Double;'#13#10 +
    '    Case THInfoType Of'#13#10 +
    '      itSetout  : (dblEasting, dblNorthing  : Double);'#13#10 +
    '      itMeasure, itCompare : (dblChainage : Double;'#13#10 +
    '        Case THInfoType Of'#13#10 +
    '          itMeasure: (dblOffset : Double);'#13#10 +
    '          itCompare: (dblDistance : Double);'#13#10 +
    '    );'#13#10 +
    '  End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TRecordDecl.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestVariantType;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Type'#13#10 +
    '  t01 = Variant;'#13#10 +
    '  t02 = OLEVariant;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  T: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    T := P.FindElement(strTypesLabel);
    Check(T <> Nil, 'Can not find Types label.');
    If T <> Nil Then
      For i := 1 To T.ElementCount Do
        CheckEquals(TVariantType.ClassName, T.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestVarSection;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Var'#13#10 +
    '  v1 : Integer;'#13#10 +
    '  v2 : String;'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Var'#13#10 +
    '  v3 : String;'#13#10 +
    '  v4, v5, v6 : Integer;'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Var'#13#10 +
    '  v7, v8 : Byte;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;
  V: TElementContainer;
  i: Integer;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
    V := P.FindElement(strVarsLabel);
    Check(V <> Nil, 'Can not find Vars label.');
    If V <> Nil Then
      For i := 1 To V.ElementCount Do
        CheckEquals(TVar.ClassName, V.Elements[i].ClassName);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestWhileStmt;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  while i < 0 Do'#13#10 +
    '    Inc(i);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

procedure TestTPascalModule.TestWithStmt;

Const
  strSource =
    'Unit MyUnit;'#13#10 +
    ''#13#10 +
    'Interface'#13#10 +
    ''#13#10 +
    'Implementation'#13#10 +
    ''#13#10 +
    'Procedure Hello;'#13#10 +
    ''#13#10 +
    'Begin'#13#10 +
    '  with objDGH Do'#13#10 +
    '    Inc(i);'#13#10 +
    '  with objDGH, dghObject Do'#13#10 +
    '    Inc(i);'#13#10 +
    'End;'#13#10 +
    ''#13#10 +
    'End.'#13#10;

Var
  P: TPascalModule;

begin
  P := TPascalModule.CreateParser(strSource, '', False, [moParse]);
  Try
    //CheckEquals(0, P.HeadingCount(strHints), P.FirstHint);
    CheckEquals(0, P.HeadingCount(strWarnings), P.FirstWarning);
    CheckEquals(0, P.HeadingCount(strErrors), P.FirstError);
  Finally
    P.Free;
  End;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest('PascalModule Tests', TestTPascalComment.Suite);
  RegisterTest('PascalModule Tests', TestTIdentList.Suite);
  RegisterTest('PascalModule Tests', TestTTypes.Suite);
  RegisterTest('PascalModule Tests', TestTArrayType.Suite);
  RegisterTest('PascalModule Tests', TestTRecordDecl.Suite);
  RegisterTest('PascalModule Tests', TestTPascalParameter.Suite);
  RegisterTest('PascalModule Tests', TestTPascalMethod.Suite);
  RegisterTest('PascalModule Tests', TestTPascalProperty.Suite);
  RegisterTest('PascalModule Tests', TestTPropertySpec.Suite);
  RegisterTest('PascalModule Tests', TestTObjectDecl.Suite);
  RegisterTest('PascalModule Tests', TestTClassDecl.Suite);
  RegisterTest('PascalModule Tests', TestTInterfaceDecl.Suite);
  RegisterTest('PascalModule Tests', TestTDispInterfaceDecl.Suite);
  RegisterTest('PascalModule Tests', TestTConstant.Suite);
  RegisterTest('PascalModule Tests', TestTResourceString.Suite);
  RegisterTest('PascalModule Tests', TestTVar.Suite);
  RegisterTest('PascalModule Tests', TestTThreadVar.Suite);
  RegisterTest('PascalModule Tests', TestTField.Suite);
  RegisterTest('PascalModule Tests', TestTExportsItem.Suite);
  RegisterTest('PascalModule Tests', TestTInitializationSection.Suite);
  RegisterTest('PascalModule Tests', TestTFinalizationSection.Suite);
  RegisterTest('PascalModule Tests', TestTPascalModule.Suite);
end.
