unit TestPascalModule;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, Classes, Contnrs, SysUtils, Windows, BaseLanguageModule,
  PascalModule, TestBaseLanguageModule;
type
  // Test methods for class TPascalComment

  TestTPascalComment = class(TExtendedTestCase)
  strict private
  public
  published
    procedure TestCreateComment;
  end;
  // Test methods for class TIdentList

  TestTIdentList = class(TExtendedTestCase)
  strict private
    FIdentList: TIdentList;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
  end;

  TestTTypes = class(TExtendedTestCase)
  strict private
    FTypes: TTypes;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
  end;
  // Test methods for class TArrayType
  TestTArrayType = class(TExtendedTestCase)
  strict private
    FArrayType: TArrayType;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
    procedure TestAddDimension;
  end;
  // Test methods for class TRecordDecl

  TestTRecordDecl = class(TExtendedTestCase)
  strict private
    FRecordDecl: TRecordDecl;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
    procedure TestAsString;
    procedure TestReferenceSymbol;
  end;
  // Test methods for class TPascalParameter

  TestTPascalParameter = class(TExtendedTestCase)
  strict private
  public
  published
    procedure TestAsString;
  end;
  // Test methods for class TPascalMethod

  TestTPascalMethod = class(TExtendedTestCase)
  strict private
    FPascalMethod: TPascalMethod;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAddDirectives;
    procedure TestHasDirective;
    procedure TestAsString;
    procedure TestReferenceSymbol;
  end;
  // Test methods for class TPascalProperty

  TestTPascalProperty = class(TExtendedTestCase)
  strict private
    FPascalProperty: TPascalProperty;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
  end;
  // Test methods for class TPropertySpec

  TestTPropertySpec = class(TExtendedTestCase)
  strict private
    FPropertySpec: TPropertySpec;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAsString;
  end;
  // Test methods for class TObjectDecl

  TestTObjectDecl = class(TExtendedTestCase)
  strict private
    FObjectDecl: TObjectDecl;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
    procedure TestAsString;
    procedure TestReferenceSymbol;
  end;
  // Test methods for class TClassDecl

  TestTClassDecl = class(TExtendedTestCase)
  strict private
    FClassDecl: TClassDecl;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
    procedure TestAsString;
    procedure TestReferenceSymbol;
  end;
  // Test methods for class TInterfaceDecl

  TestTInterfaceDecl = class(TExtendedTestCase)
  strict private
    FInterfaceDecl: TInterfaceDecl;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
    procedure TestAsString;
  end;
  // Test methods for class TDispInterfaceDecl

  TestTDispInterfaceDecl = class(TExtendedTestCase)
  strict private
    FDispInterfaceDecl: TDispInterfaceDecl;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
    procedure TestAsString;
  end;
  // Test methods for class TConstant

  TestTConstant = class(TExtendedTestCase)
  strict private
    FConstant: TConstant;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
  end;
  // Test methods for class TResourceString

  TestTResourceString = class(TExtendedTestCase)
  strict private
    FResourceString: TResourceString;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
  end;
  // Test methods for class TVar

  TestTVar = class(TExtendedTestCase)
  strict private
    FVar: TVar;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
  end;
  // Test methods for class TThreadVar

  TestTThreadVar = class(TExtendedTestCase)
  strict private
    FThreadVar: TThreadVar;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
  end;
  // Test methods for class TField

  TestTField = class(TExtendedTestCase)
  strict private
    FField: TField;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
    procedure TestCheckDocumentation;
  end;
  // Test methods for class TExportsItem

  TestTExportsItem = class(TExtendedTestCase)
  strict private
    FExportsItem: TExportsItem;
  public
    Procedure TestCreate;
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAsString;
  end;
  // Test methods for class TInitializationSection

  TestTInitializationSection = class(TExtendedTestCase)
  strict private
    FInitializationSection: TInitializationSection;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
    procedure TestCheckDocumentation;
  end;
  // Test methods for class TFinalizationSection

  TestTFinalizationSection = class(TExtendedTestCase)
  strict private
    FFinalizationSection: TFinalizationSection;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
    procedure TestCheckDocumentation;
  end;

  (*
  // Test methods for class TPascalModule

  TestTPascalModule = class(TExtendedTestCase)
  strict private
    FPascalModule: TPascalModule;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestKeyWords;
    procedure TestProcessCompilerDirective;
    procedure TestReferenceSymbol;
    procedure TestAsString;
  end;

  *)

implementation

procedure TestTPascalComment.TestCreateComment;

var
  ReturnValue: TComment;

begin
  ReturnValue := TPascalComment.CreateComment(
    '(** Sorry Dave, I can''t do that! **)', 12, 23);
  Try
    CheckEquals(10, ReturnValue.TokenCount);
    CheckEquals('Sorry', ReturnValue.Tokens[0].Token);
    CheckEquals('Dave', ReturnValue.Tokens[1].Token);
    CheckEquals(',', ReturnValue.Tokens[2].Token);
    CheckEquals('I', ReturnValue.Tokens[3].Token);
    CheckEquals('can', ReturnValue.Tokens[4].Token);
    CheckEquals('''', ReturnValue.Tokens[5].Token);
    CheckEquals('t', ReturnValue.Tokens[6].Token);
    CheckEquals('do', ReturnValue.Tokens[7].Token);
    CheckEquals('that', ReturnValue.Tokens[8].Token);
    CheckEquals('!', ReturnValue.Tokens[9].Token);
  Finally
    ReturnValue.Free;
  End;
  ReturnValue := TPascalComment.CreateComment(
    '//: Sorry Dave, I can''t do that!', 12, 23);
  Try
    CheckEquals(10, ReturnValue.TokenCount);
    CheckEquals('Sorry', ReturnValue.Tokens[0].Token);
    CheckEquals('Dave', ReturnValue.Tokens[1].Token);
    CheckEquals(',', ReturnValue.Tokens[2].Token);
    CheckEquals('I', ReturnValue.Tokens[3].Token);
    CheckEquals('can', ReturnValue.Tokens[4].Token);
    CheckEquals('''', ReturnValue.Tokens[5].Token);
    CheckEquals('t', ReturnValue.Tokens[6].Token);
    CheckEquals('do', ReturnValue.Tokens[7].Token);
    CheckEquals('that', ReturnValue.Tokens[8].Token);
    CheckEquals('!', ReturnValue.Tokens[9].Token);
  Finally
    ReturnValue.Free;
  End;
  ReturnValue := TPascalComment.CreateComment(
    '{: Sorry Dave, I can''t do that! }', 12, 23);
  Try
    CheckEquals(10, ReturnValue.TokenCount);
    CheckEquals('Sorry', ReturnValue.Tokens[0].Token);
    CheckEquals('Dave', ReturnValue.Tokens[1].Token);
    CheckEquals(',', ReturnValue.Tokens[2].Token);
    CheckEquals('I', ReturnValue.Tokens[3].Token);
    CheckEquals('can', ReturnValue.Tokens[4].Token);
    CheckEquals('''', ReturnValue.Tokens[5].Token);
    CheckEquals('t', ReturnValue.Tokens[6].Token);
    CheckEquals('do', ReturnValue.Tokens[7].Token);
    CheckEquals('that', ReturnValue.Tokens[8].Token);
    CheckEquals('!', ReturnValue.Tokens[9].Token);
  Finally
    ReturnValue.Free;
  End;
end;

procedure TestTIdentList.SetUp;
begin
  FIdentList := TIdentList.Create('Hello', scNone, 12, 23, iiNone, Nil);
end;

procedure TestTIdentList.TearDown;
begin
  FIdentList.Free;
  FIdentList := nil;
end;

procedure TestTIdentList.TestAsString;

begin
  CheckEquals('Hello', FIdentList.AsString(True, False));
  FIdentList.AddToken('=', ttSymbol);
  FIdentList.AddToken('1', ttNumber);
  CheckEquals('Hello = 1', FIdentList.AsString(True, False));
  FIdentList.ClearTokens;
  FIdentList.AddToken('In', ttReservedWord);
  FIdentList.AddToken('''D:\Path\PascalFile.pas''', ttStringLiteral);
  CheckEquals('Hello In ''D:\Path\PascalFile.pas''', FIdentList.AsString(True, False));
end;

procedure TestTIdentList.TestCreate;
begin
  CheckEquals(scNone, FIdentList.Scope);
  CheckEquals(12, FIdentList.Line);
  Checkequals(23, FIdentList.Column);
  CheckEquals(iiNone, FIdentList.ImageIndex);
  CheckEquals(iiNone, FIdentList.ImageIndexAdjustedForScope);
end;

procedure TestTTypes.SetUp;
begin
  FTypes := TTypes.Create('MyType', scPrivate, 12, 23, iiPublicType, Nil);
end;

procedure TestTTypes.TearDown;
begin
  FTypes.Free;
  FTypes := nil;
end;

procedure TestTTypes.TestAsString;

begin
  CheckEquals('MyType', FTypes.AsString(True, False));
  FTypes.AddToken('Integer');
  CheckEquals('MyType = Integer', FTypes.AsString(True, False));
end;

procedure TestTTypes.TestCreate;
begin
  CheckEquals(scPrivate, FTypes.Scope);
  CheckEquals(12, FTypes.Line);
  Checkequals(23, FTypes.Column);
  CheckEquals(iiPublicType, FTypes.ImageIndex);
  CheckEquals(iiPrivateType, FTypes.ImageIndexAdjustedForScope);
end;

procedure TestTArrayType.SetUp;
begin
  FArrayType := TArrayType.Create('MyArrayType', scProtected, 12, 23,
    iiPublicType, Nil);
end;

procedure TestTArrayType.TearDown;
begin
  FArrayType.Free;
  FArrayType := nil;
end;

procedure TestTArrayType.TestAsString;

begin
  CheckEquals('MyArrayType', FArrayType.AsString(True, False));
  FArrayType.AddToken('Array');
  FArrayType.AddToken('Of');
  FArrayType.AddToken('Integer');
  CheckEquals('MyArrayType = Array Of Integer', FArrayType.AsString(True, False));
  FArrayType.ClearTokens;
  FArrayType.AddToken('Array');
  FArrayType.AddToken('[');
  FArrayType.AddToken('1');
  FArrayType.AddToken('..');
  FArrayType.AddToken('2');
  FArrayType.AddToken(']');
  FArrayType.AddToken('Of');
  FArrayType.AddToken('Integer');
  CheckEquals('MyArrayType = Array[1..2] Of Integer', FArrayType.AsString(True, False));
end;

procedure TestTArrayType.TestCreate;
begin
  CheckEquals(scProtected, FArrayType.Scope);
  CheckEquals(12, FArrayType.Line);
  Checkequals(23, FArrayType.Column);
  CheckEquals(iiPublicType, FArrayType.ImageIndex);
  CheckEquals(iiProtectedType, FArrayType.ImageIndexAdjustedForScope);
end;

procedure TestTArrayType.TestAddDimension;
begin
  CheckEquals(0, FArrayType.Dimensions);
  FArrayType.AddDimension;
  CheckEquals(1, FArrayType.Dimensions);
  FArrayType.AddDimension;
  CheckEquals(2, FArrayType.Dimensions);
end;

procedure TestTRecordDecl.SetUp;
begin
  FRecordDecl := TRecordDecl.Create('MyRecord', scProtected, 12, 23,
    iiPublicRecord, Nil);
end;

procedure TestTRecordDecl.TearDown;
begin
  FRecordDecl.Free;
  FRecordDecl := nil;
end;

procedure TestTRecordDecl.TestCheckDocumentation;

var
  boolCascade: Boolean;
  C: TComment;

begin
  CheckEquals(0, FRecordDecl.ElementCount);
  FRecordDecl.CheckDocumentation(boolCascade);
  CheckEquals(1, FRecordDecl.ElementCount);
  FRecordDecl.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the record.', 0, 0);
  Try
    FRecordDecl.Comment := C;
    FRecordDecl.CheckDocumentation(boolCascade);
    CheckEquals(0, FRecordDecl.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTRecordDecl.TestCreate;
begin
  CheckEquals(scProtected, FRecordDecl.Scope);
  CheckEquals(12, FRecordDecl.Line);
  Checkequals(23, FRecordDecl.Column);
  CheckEquals(iiPublicRecord, FRecordDecl.ImageIndex);
  CheckEquals(iiProtectedRecord, FRecordDecl.ImageIndexAdjustedForScope);
end;

procedure TestTRecordDecl.TestAsString;
begin
  CheckEquals('MyRecord = Record', FRecordDecl.AsString(True, False));
end;

procedure TestTRecordDecl.TestReferenceSymbol;

var
  AToken: TTokenInfo;

begin
  AToken := TTokenInfo.Create('Hello', 0, 1, 2, 5, ttUnknown);
  Try
    CheckEquals(False, FRecordDecl.ReferenceSymbol(AToken));
    //: @todo Requires more tests.
  Finally
    AToken.Free;
  End;
end;

procedure TestTPascalParameter.TestAsString;

var
  P: TPascalParameter;
  AType : TInteger;

begin
  AType := TInteger.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('Integer');
    P := TPascalParameter.Create(pamNone, 'MyParam', False, AType, '', scNone, 12, 23);
    Try
      CheckEquals(scNone, P.Scope);
      CheckEquals(12, P.Line);
      Checkequals(23, P.Column);
      CheckEquals('MyParam : Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
    P := TPascalParameter.Create(pamVar, 'MyParam', False, AType, '', scNone, 12, 23);
    Try
      CheckEquals(scNone, P.Scope);
      CheckEquals(12, P.Line);
      Checkequals(23, P.Column);
      CheckEquals('var MyParam : Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
    P := TPascalParameter.Create(pamConst, 'MyParam', False, AType, '', scNone, 12, 23);
    Try
      CheckEquals(scNone, P.Scope);
      CheckEquals(12, P.Line);
      Checkequals(23, P.Column);
      CheckEquals('const MyParam : Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
    P := TPascalParameter.Create(pamOut, 'MyParam', False, AType, '', scNone, 12, 23);
    Try
      CheckEquals(scNone, P.Scope);
      CheckEquals(12, P.Line);
      Checkequals(23, P.Column);
      CheckEquals('out MyParam : Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
    P := TPascalParameter.Create(pamNone, 'MyParam', True, AType, '', scNone, 12, 23);
    Try
      CheckEquals(scNone, P.Scope);
      CheckEquals(12, P.Line);
      Checkequals(23, P.Column);
      CheckEquals('MyParam : Array Of Integer', P.AsString(True, False));
    Finally
      P.Free;
    End;
    P := TPascalParameter.Create(pamNone, 'MyParam', False, AType, '0', scNone, 12, 23);
    Try
      CheckEquals(scNone, P.Scope);
      CheckEquals(12, P.Line);
      Checkequals(23, P.Column);
      CheckEquals('MyParam : Integer = 0', P.AsString(True, False));
    Finally
      P.Free;
    End;
  Finally
    AType.Free;
  end;
end;

procedure TestTPascalMethod.SetUp;
begin
  FPascalMethod := TPascalMethod.Create(mtFunction, 'MyFunction', scPrivate, 12, 23);
  FPascalMethod.ReturnType := TTypes.Create('', scNone, 0, 0, iiNone, Nil);
  FPascalMethod.ReturnType.AddToken('Integer');
end;

procedure TestTPascalMethod.TearDown;
begin
  FPascalMethod.Free;
  FPascalMethod := nil;
end;

procedure TestTPascalMethod.TestAddDirectives;

begin
  FPascalMethod.AddDirectives('Virtual');
  FPascalMethod.AddDirectives('Message');
  CheckEquals(True, FPascalMethod.HasDirective('Virtual'));
  CheckEquals(True, FPascalMethod.HasDirective('Message'));
end;

procedure TestTPascalMethod.TestHasDirective;

begin
  FPascalMethod.AddDirectives('Virtual');
  FPascalMethod.AddDirectives('Message');
  CheckEquals(True, FPascalMethod.HasDirective('Virtual'));
  CheckEquals(True, FPascalMethod.HasDirective('Message'));
end;

procedure TestTPascalMethod.TestAsString;
var
  P: TPascalParameter;
  AType : TTypes;

begin
  CheckEquals('Function MyFunction : Integer', FPascalMethod.AsString(True, False));
  CheckEquals('Function MyFunction : Integer', FPascalMethod.AsString(True, True));
  AType := TTypes.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('Integer');
    P := TPascalParameter.Create(pamNone, 'Param1', False, AType, '', scNone, 0, 0);
    FPascalMethod.AddParameter(P);
  Finally
    AType.Free;
  End;
  CheckEquals('Function MyFunction(Param1 : Integer) : Integer', FPascalMethod.AsString(True, False));
  CheckEquals('Function MyFunction('#13#10#32#32'Param1 : Integer'#13#10') : Integer', FPascalMethod.AsString(True, True));
  AType := TTypes.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('String');
    P := TPascalParameter.Create(pamNone, 'Param2', False, AType, '', scNone, 0, 0);
    FPascalMethod.AddParameter(P);
  Finally
    AType.Free;
  End;
  CheckEquals('Function MyFunction(Param1 : Integer; Param2 : String) : Integer', FPascalMethod.AsString(True, False));
  CheckEquals('Function MyFunction('#13#10#32#32'Param1 : Integer;'#13#10#32#32'Param2 : String'#13#10') : Integer', FPascalMethod.AsString(True, True));
end;

procedure TestTPascalMethod.TestCreate;

Const
  strMethodTypes : Array[mtConstructor..mtFunction] Of String = (
    'Constructor', 'Destructor', 'Procedure', 'Function');
begin
  CheckEquals(strMethodTypes[mtFunction], strMethodTypes[FPascalMethod.MethodType]);
  Checkequals('MyFunction', FPascalMethod.Identifier);
  Checkequals(scPrivate, FPascalMethod.Scope);
  Checkequals(12, FPascalMethod.Line);
  Checkequals(23, FPascalMethod.Column);
end;

procedure TestTPascalMethod.TestReferenceSymbol;
var
  AToken: TTokenInfo;
begin
  AToken := TTokenInfo.Create('Hello', 0, 0, 0, 5, ttIdentifier);
  Try
    CheckEquals(False, FPascalMethod.ReferenceSymbol(AToken));
    //: @todo Requires more tests.
  Finally
    AToken.Free;
  End;
end;

procedure TestTPascalProperty.SetUp;
begin
  FPascalProperty := TPascalProperty.Create('MyProperty', scProtected, 12, 23,
    iiPublicProperty, Nil);
  FPascalProperty.TypeId := TTypes.Create('', scNone, 0, 0, iiNone, Nil);
  FPascalProperty.TypeId.AddToken('String');
end;

procedure TestTPascalProperty.TearDown;
begin
  FPascalProperty.Free;
  FPascalProperty := nil;
end;

procedure TestTPascalProperty.TestAsString;
var
  AType: TTypes;
  P: TPascalParameter;
begin
  Checkequals('Property MyProperty : String', FPascalProperty.AsString(True, False));
  Checkequals('Property MyProperty : String'#13#10, FPascalProperty.AsString(True, True));
  AType := TTypes.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('Integer');
    P := TPascalParameter.Create(pamNone, 'Param1', False, AType, '', scNone, 0, 0);
    FPascalProperty.AddParameter(P);
  Finally
    AType.Free;
  End;
  CheckEquals('Property MyProperty[Param1 : Integer] : String', FPascalProperty.AsString(True, False));
  CheckEquals('Property MyProperty['#13#10#32#32'Param1 : Integer'#13#10'] : String'#13#10, FPascalProperty.AsString(True, True));
  AType := TTypes.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('String');
    P := TPascalParameter.Create(pamNone, 'Param2', False, AType, '', scNone, 0, 0);
    FPascalProperty.AddParameter(P);
  Finally
    AType.Free;
  End;
  CheckEquals('Property MyProperty[Param1 : Integer; Param2 : String] : String', FPascalProperty.AsString(True, False));
  CheckEquals('Property MyProperty['#13#10#32#32'Param1 : Integer; '#13#10#32#32'Param2 : String'#13#10'] : String'#13#10, FPascalProperty.AsString(True, True));
  FPascalProperty.ReadSpec := 'FValue';
  FPascalProperty.WriteSpec := 'FValue';
  CheckEquals('Property MyProperty[Param1 : Integer; Param2 : String] : String Read FValue Write FValue', FPascalProperty.AsString(True, False));
  CheckEquals('Property MyProperty['#13#10#32#32'Param1 : Integer; '#13#10#32#32'Param2 : String'#13#10'] : String'#13#10'  Read FValue'#13#10'  Write FValue'#13#10, FPascalProperty.AsString(True, True));
end;

procedure TestTPascalProperty.TestCreate;
begin
  CheckEquals('MyProperty', FPascalProperty.Identifier);
  Checkequals(scProtected, FPascalProperty.Scope);
  Checkequals(12, FPascalProperty.Line);
  Checkequals(23, FPascalProperty.Column);
  CheckEquals(iiPublicProperty, FPascalProperty.ImageIndex);
  CheckEquals(iiProtectedProperty, FPascalProperty.ImageIndexAdjustedForScope);
end;

procedure TestTPropertySpec.SetUp;
begin
  FPropertySpec := TPropertySpec.Create('', scNone, 0, 0, iiNone, Nil);
  FPropertySpec.AddToken('FValue');
end;

procedure TestTPropertySpec.TearDown;
begin
  FPropertySpec.Free;
  FPropertySpec := nil;
end;

procedure TestTPropertySpec.TestAsString;

begin
  CheckEquals('FValue', FPropertySpec.AsString(True, False));
end;

procedure TestTObjectDecl.SetUp;
begin
  FObjectDecl := TObjectDecl.Create('MyObject', scProtected, 12, 23,
    iiPublicObject, Nil);
end;

procedure TestTObjectDecl.TearDown;
begin
  FObjectDecl.Free;
  FObjectDecl := nil;
end;

procedure TestTObjectDecl.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C : TComment;

begin
  CheckEquals(0, FObjectDecl.ElementCount);
  FObjectDecl.CheckDocumentation(boolCascade);
  CheckEquals(1, FObjectDecl.ElementCount);
  FObjectDecl.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the object.', 0, 0);
  Try
    FObjectDecl.Comment := C;
    FObjectDecl.CheckDocumentation(boolCascade);
    CheckEquals(0, FObjectDecl.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTObjectDecl.TestCreate;
begin
  CheckEquals('MyObject', FObjectDecl.Identifier);
  Checkequals(scProtected, FObjectDecl.Scope);
  Checkequals(12, FObjectDecl.Line);
  Checkequals(23, FObjectDecl.Column);
  CheckEquals(iiPublicObject, FObjectDecl.ImageIndex);
  CheckEquals(iiProtectedObject, FObjectDecl.ImageIndexAdjustedForScope);
end;

procedure TestTObjectDecl.TestAsString;
begin
  CheckEquals('MyObject = Object', FObjectDecl.AsString(True, False));
end;

procedure TestTObjectDecl.TestReferenceSymbol;
var
  AToken: TTokenInfo;
begin
  AToken := TTokenInfo.Create('Hello', 0, 0, 0, 5, ttIdentifier);
  Try
    CheckEquals(False, FObjectDecl.ReferenceSymbol(AToken));
    //: @todo Requires more tests.
  Finally
    AToken.Free;
  End;
end;

procedure TestTClassDecl.SetUp;
begin
  FClassDecl := TClassDecl.Create('MyClass', scPublic, 12, 23, iiPublicClass, Nil);
end;

procedure TestTClassDecl.TearDown;
begin
  FClassDecl.Free;
  FClassDecl := nil;
end;

procedure TestTClassDecl.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FClassDecl.ElementCount);
  FClassDecl.CheckDocumentation(boolCascade);
  CheckEquals(1, FClassDecl.ElementCount);
  FClassDecl.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the class.', 0, 0);
  Try
    FClassDecl.Comment := C;
    FClassDecl.CheckDocumentation(boolCascade);
    CheckEquals(0, FClassDecl.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTClassDecl.TestCreate;
begin
  CheckEquals('MyClass', FClassDecl.Identifier);
  Checkequals(scPublic, FClassDecl.Scope);
  Checkequals(12, FClassDecl.Line);
  Checkequals(23, FClassDecl.Column);
  CheckEquals(iiPublicClass, FClassDecl.ImageIndex);
  CheckEquals(iiPublicClass, FClassDecl.ImageIndexAdjustedForScope);
end;

procedure TestTClassDecl.TestAsString;

Var
  H1, H2 : TTokenInfo;

begin
  CheckEquals('MyClass = Class', FClassDecl.AsString(True, False));
  H1 := TTokenInfo.Create('TObject', 0, 0, 0, 7, ttIdentifier);
  Try
    FClassDecl.Heritage.Add(H1, scNone, iiNone, Nil);
    CheckEquals('MyClass = Class(TObject)', FClassDecl.AsString(True, False));
    H2 := TTokenInfo.Create('IMyInterface', 0, 0, 0, 7, ttIdentifier);
    Try
      FClassDecl.Heritage.Add(H2, scNone, iiNone, Nil);
      CheckEquals('MyClass = Class(TObject, IMyInterface)', FClassDecl.AsString(True, False));
      FClassDecl.AbstractClass := True;
      CheckEquals('MyClass = Class Abstract(TObject, IMyInterface)', FClassDecl.AsString(True, False));
      FClassDecl.AbstractClass := False;
      FClassDecl.SealedClass := True;
      CheckEquals('MyClass = Class Sealed(TObject, IMyInterface)', FClassDecl.AsString(True, False));
      FClassDecl.SealedClass := False;
      FClassDecl.HelperClass := True;
      FClassDecl.HelperClassName := 'TSomething';
      CheckEquals('MyClass = Class Helper(TObject, IMyInterface) For TSomething', FClassDecl.AsString(True, False));
    Finally
      H2.Free;
    End;
  Finally
    H1.Free;
  End;
end;

procedure TestTClassDecl.TestReferenceSymbol;
var
  AToken: TTokenInfo;
begin
  AToken := TTokenInfo.Create('Hello', 0, 0, 0, 5, ttIdentifier);
  Try
    CheckEquals(False, FClassDecl.ReferenceSymbol(AToken));
    //: @todo Requires more tests.
  Finally
    AToken.Free;
  End;
end;

procedure TestTInterfaceDecl.SetUp;
begin
  FInterfaceDecl := TInterfaceDecl.Create('MyInterface', scPublished, 12, 23,
    iiPublicInterface, Nil);
end;

procedure TestTInterfaceDecl.TearDown;
begin
  FInterfaceDecl.Free;
  FInterfaceDecl := nil;
end;

procedure TestTInterfaceDecl.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FInterfaceDecl.ElementCount);
  FInterfaceDecl.CheckDocumentation(boolCascade);
  CheckEquals(1, FInterfaceDecl.ElementCount);
  FInterfaceDecl.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the Interface.', 0, 0);
  Try
    FInterfaceDecl.Comment := C;
    FInterfaceDecl.CheckDocumentation(boolCascade);
    CheckEquals(0, FInterfaceDecl.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTInterfaceDecl.TestCreate;
begin
  CheckEquals('MyInterface', FInterfaceDecl.Identifier);
  Checkequals(scPublished, FInterfaceDecl.Scope);
  Checkequals(12, FInterfaceDecl.Line);
  Checkequals(23, FInterfaceDecl.Column);
  CheckEquals(iiPublicInterface, FInterfaceDecl.ImageIndex);
  CheckEquals(iiPublishedInterface, FInterfaceDecl.ImageIndexAdjustedForScope);
end;

procedure TestTInterfaceDecl.TestAsString;
var
  H: TTokenInfo;
begin
  CheckEquals('MyInterface = Interface', FInterfaceDecl.AsString(True, False));
  H := TTokenInfo.Create('IUnknown', 0, 0, 0, 7, ttIdentifier);
  Try
    FInterfaceDecl.Heritage.Add(H, scNone, iiNone, Nil);
    CheckEquals('MyInterface = Interface(IUnknown)', FInterfaceDecl.AsString(True, False));
  Finally
    H.Free;
  End;
end;

procedure TestTDispInterfaceDecl.SetUp;
begin
  FDispInterfaceDecl := TDispInterfaceDecl.Create('MyDispInterface', scPrivate,
    12, 23, iiPublicDispInterface, Nil);
end;

procedure TestTDispInterfaceDecl.TearDown;
begin
  FDispInterfaceDecl.Free;
  FDispInterfaceDecl := nil;
end;

procedure TestTDispInterfaceDecl.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FDispInterfaceDecl.ElementCount);
  FDispInterfaceDecl.CheckDocumentation(boolCascade);
  CheckEquals(1, FDispInterfaceDecl.ElementCount);
  FDispInterfaceDecl.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the DispInterface.', 0, 0);
  Try
    FDispInterfaceDecl.Comment := C;
    FDispInterfaceDecl.CheckDocumentation(boolCascade);
    CheckEquals(0, FDispInterfaceDecl.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTDispInterfaceDecl.TestCreate;
begin
  CheckEquals('MyDispInterface', FDispInterfaceDecl.Identifier);
  Checkequals(scPrivate, FDispInterfaceDecl.Scope);
  Checkequals(12, FDispInterfaceDecl.Line);
  Checkequals(23, FDispInterfaceDecl.Column);
  CheckEquals(iiPublicDispInterface, FDispInterfaceDecl.ImageIndex);
  CheckEquals(iiPrivateDispInterface, FDispInterfaceDecl.ImageIndexAdjustedForScope);
end;

procedure TestTDispInterfaceDecl.TestAsString;
var
  H : TTokenInfo;
begin
  CheckEquals('MyDispInterface = DispInterface', FDispInterfaceDecl.AsString(True, False));
  H := TTokenInfo.Create('IUnknown', 0, 0, 0, 7, ttIdentifier);
  Try
    FDispInterfaceDecl.Heritage.Add(H, scNone, iiNone, Nil);
    CheckEquals('MyDispInterface = DispInterface(IUnknown)', FDispInterfaceDecl.AsString(True, False));
  Finally
    H.Free;
  End;
end;

procedure TestTConstant.SetUp;
begin
  FConstant := TConstant.Create('MyConstant', scPrivate, 12, 23,
    iiPublicConstant, Nil);
  FConstant.AddToken('1');
end;

procedure TestTConstant.TearDown;
begin
  FConstant.Free;
  FConstant := nil;
end;

procedure TestTConstant.TestAsString;
begin
  Checkequals('MyConstant = 1', FConstant.AsString(True, False));
  FConstant.AddToken('+');
  FConstant.AddToken('2');
  FConstant.AddToken('*');
  FConstant.AddToken('3');
  Checkequals('MyConstant = 1 + 2 * 3', FConstant.AsString(True, False));
end;

procedure TestTConstant.TestCreate;
begin
  CheckEquals('MyConstant', FConstant.Identifier);
  Checkequals(scPrivate, FConstant.Scope);
  Checkequals(12, FConstant.Line);
  Checkequals(23, FConstant.Column);
  CheckEquals(iiPublicConstant, FConstant.ImageIndex);
  CheckEquals(iiPrivateConstant, FConstant.ImageIndexAdjustedForScope);
end;

procedure TestTResourceString.SetUp;
begin
  FResourceString := TResourceString.Create('MyResourceString', scPublic,
    12, 23, iiPublicResourceString, Nil);
  FResourceString.AddToken('''This is a string literal.''');
end;

procedure TestTResourceString.TearDown;
begin
  FResourceString.Free;
  FResourceString := nil;
end;

procedure TestTResourceString.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FResourceString.ElementCount);
  FResourceString.CheckDocumentation(boolCascade);
  CheckEquals(1, FResourceString.ElementCount);
  FResourceString.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the resource string.', 0, 0);
  Try
    FResourceString.Comment := C;
    FResourceString.CheckDocumentation(boolCascade);
    CheckEquals(0, FResourceString.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTResourceString.TestCreate;
begin
  CheckEquals('MyResourceString', FResourceString.Identifier);
  Checkequals(scPublic, FResourceString.Scope);
  Checkequals(12, FResourceString.Line);
  Checkequals(23, FResourceString.Column);
  CheckEquals(iiPublicResourceString, FResourceString.ImageIndex);
  CheckEquals(iiPublicResourceString, FResourceString.ImageIndexAdjustedForScope);
end;

procedure TestTVar.SetUp;
begin
  FVar := TVar.Create('MyVar', scPrivate, 12, 23, iiPublicVariable, Nil);
  FVar.AddToken('Integer');
end;

procedure TestTVar.TearDown;
begin
  FVar.Free;
  FVar := nil;
end;

procedure TestTVar.TestAsString;
begin
  Checkequals('MyVar : Integer', FVar.AsString(True, False));
end;

procedure TestTVar.TestCreate;
begin
  CheckEquals('MyVar', FVar.Identifier);
  Checkequals(scPrivate, FVar.Scope);
  Checkequals(12, FVar.Line);
  Checkequals(23, FVar.Column);
  CheckEquals(iiPublicVariable, FVar.ImageIndex);
  CheckEquals(iiPrivateVariable, FVar.ImageIndexAdjustedForScope);
end;

procedure TestTThreadVar.SetUp;
begin
  FThreadVar := TThreadVar.Create('MyThreadVar', scPrivate, 12, 23,
    iiPublicThreadVar, Nil);
end;

procedure TestTThreadVar.TearDown;
begin
  FThreadVar.Free;
  FThreadVar := nil;
end;

procedure TestTThreadVar.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FThreadVar.ElementCount);
  FThreadVar.CheckDocumentation(boolCascade);
  CheckEquals(1, FThreadVar.ElementCount);
  FThreadVar.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the threadvar.', 0, 0);
  Try
    FThreadVar.Comment := C;
    FThreadVar.CheckDocumentation(boolCascade);
    CheckEquals(0, FThreadVar.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTThreadVar.TestCreate;
begin
  CheckEquals('MyThreadVar', FThreadVar.Identifier);
  Checkequals(scPrivate, FThreadVar.Scope);
  Checkequals(12, FThreadVar.Line);
  Checkequals(23, FThreadVar.Column);
  CheckEquals(iiPublicThreadVar, FThreadVar.ImageIndex);
  CheckEquals(iiPrivateThreadVar, FThreadVar.ImageIndexAdjustedForScope);
end;

procedure TestTField.SetUp;
begin
  FField := TField.Create('MyField', scPublic, 12, 23, iiPublicField, Nil);
  FField.AddToken('Integer');
end;

procedure TestTField.TearDown;
begin
  FField.Free;
  FField := nil;
end;

procedure TestTField.TestAsString;
begin
  CheckEquals('MyField : Integer', FField.AsString(True, False));
end;

procedure TestTField.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FField.ElementCount);
  FField.CheckDocumentation(boolCascade);
  CheckEquals(1, FField.ElementCount);
  FField.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the field.', 0, 0);
  Try
    FField.Comment := C;
    FField.CheckDocumentation(boolCascade);
    CheckEquals(0, FField.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTField.TestCreate;
begin
  CheckEquals('MyField', FField.Identifier);
  Checkequals(scPublic, FField.Scope);
  Checkequals(12, FField.Line);
  Checkequals(23, FField.Column);
  CheckEquals(iiPublicField, FField.ImageIndex);
  CheckEquals(iiPublicField, FField.ImageIndexAdjustedForScope);
end;

procedure TestTExportsItem.SetUp;
begin
  FExportsItem := TExportsItem.Create('MyMethod', scPublic, 12, 23,
    iiPublicExportedFunction, Nil);
end;

procedure TestTExportsItem.TearDown;
begin
  FExportsItem.Free;
  FExportsItem := nil;
end;

procedure TestTExportsItem.TestAsString;
begin
  Checkequals('MyMethod', FExportsItem.AsString(True, False));
end;

procedure TestTExportsItem.TestCreate;
begin
  CheckEquals('MyMethod', FExportsItem.Identifier);
  Checkequals(scPublic, FExportsItem.Scope);
  Checkequals(12, FExportsItem.Line);
  Checkequals(23, FExportsItem.Column);
  CheckEquals(iiPublicExportedFunction, FExportsItem.ImageIndex);
  CheckEquals(iiPublicExportedFunction, FExportsItem.ImageIndexAdjustedForScope);
end;

procedure TestTInitializationSection.SetUp;
begin
  FInitializationSection := TInitializationSection.Create('Initialization',
    scNone, 12, 23, iiInitialization, Nil);
end;

procedure TestTInitializationSection.TearDown;
begin
  FInitializationSection.Free;
  FInitializationSection := nil;
end;

procedure TestTInitializationSection.TestAsString;
begin
  Checkequals('Initialization', FInitializationSection.AsString(True, False));
end;

procedure TestTInitializationSection.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FInitializationSection.ElementCount);
  FInitializationSection.CheckDocumentation(boolCascade);
  CheckEquals(1, FInitializationSection.ElementCount);
  FInitializationSection.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the initialisation section.', 0, 0);
  Try
    FInitializationSection.Comment := C;
    FInitializationSection.CheckDocumentation(boolCascade);
    CheckEquals(0, FInitializationSection.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTInitializationSection.TestCreate;
begin
  CheckEquals('Initialization', FInitializationSection.Identifier);
  Checkequals(scNone, FInitializationSection.Scope);
  Checkequals(12, FInitializationSection.Line);
  Checkequals(23, FInitializationSection.Column);
  CheckEquals(iiInitialization, FInitializationSection.ImageIndex);
  CheckEquals(iiInitialization, FInitializationSection.ImageIndexAdjustedForScope);
end;

procedure TestTFinalizationSection.SetUp;
begin
  FFinalizationSection := TFinalizationSection.Create('Finalization',
    scNone, 12, 23, iiFinalization, Nil);
end;

procedure TestTFinalizationSection.TearDown;
begin
  FFinalizationSection.Free;
  FFinalizationSection := nil;
end;

procedure TestTFinalizationSection.TestAsString;
begin
  Checkequals('Finalization', FFinalizationSection.AsString(True, False));
end;

procedure TestTFinalizationSection.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  CheckEquals(0, FFinalizationSection.ElementCount);
  FFinalizationSection.CheckDocumentation(boolCascade);
  CheckEquals(1, FFinalizationSection.ElementCount);
  FFinalizationSection.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment for the finalisation section.', 0, 0);
  Try
    FFinalizationSection.Comment := C;
    FFinalizationSection.CheckDocumentation(boolCascade);
    CheckEquals(0, FFinalizationSection.ElementCount);
  Finally
    C.Free;
  End;
end;

procedure TestTFinalizationSection.TestCreate;
begin
  CheckEquals('Finalization', FFinalizationSection.Identifier);
  Checkequals(scNone, FFinalizationSection.Scope);
  Checkequals(12, FFinalizationSection.Line);
  Checkequals(23, FFinalizationSection.Column);
  CheckEquals(iiFinalization, FFinalizationSection.ImageIndex);
  CheckEquals(iiFinalization, FFinalizationSection.ImageIndexAdjustedForScope);
end;

(*

procedure TestTPascalModule.SetUp;
begin
//  FPascalModule := TPascalModule.Create;
end;

procedure TestTPascalModule.TearDown;
begin
//  FPascalModule.Free;
//  FPascalModule := nil;
end;

procedure TestTPascalModule.TestKeyWords;
var
  ReturnValue: WideChar;
begin
//  ReturnValue := FPascalModule.KeyWords;
//  // TODO: Validate method results
end;

procedure TestTPascalModule.TestProcessCompilerDirective;
var
  iSkip: Integer;
begin
//  // TODO: Setup method call parameters
//  FPascalModule.ProcessCompilerDirective(iSkip);
//  // TODO: Validate method results
end;

procedure TestTPascalModule.TestReferenceSymbol;
var
  ReturnValue: Boolean;
  AToken: TTokenInfo;
begin
//  // TODO: Setup method call parameters
//  ReturnValue := FPascalModule.ReferenceSymbol(AToken);
//  // TODO: Validate method results
end;

procedure TestTPascalModule.TestAsString;
var
  ReturnValue: string;
  boolForDocumentation: Boolean;
  boolShowIdentifier: Boolean;
begin
//  // TODO: Setup method call parameters
//  ReturnValue := FPascalModule.AsString(boolShowIdentifier, boolForDocumentation);
//  // TODO: Validate method results
end;

*)

initialization
  // Register any test cases with the test runner
  RegisterTest('PascalModule Tests', TestTPascalComment.Suite);
  RegisterTest('PascalModule Tests', TestTIdentList.Suite);
  RegisterTest('PascalModule Tests', TestTTypes.Suite);
  RegisterTest('PascalModule Tests', TestTArrayType.Suite);
  RegisterTest('PascalModule Tests', TestTRecordDecl.Suite);
  RegisterTest('PascalModule Tests', TestTPascalParameter.Suite);
  RegisterTest('PascalModule Tests', TestTPascalMethod.Suite);
  RegisterTest('PascalModule Tests', TestTPascalProperty.Suite);
  RegisterTest('PascalModule Tests', TestTPropertySpec.Suite);
  RegisterTest('PascalModule Tests', TestTObjectDecl.Suite);
  RegisterTest('PascalModule Tests', TestTClassDecl.Suite);
  RegisterTest('PascalModule Tests', TestTInterfaceDecl.Suite);
  RegisterTest('PascalModule Tests', TestTDispInterfaceDecl.Suite);
  RegisterTest('PascalModule Tests', TestTConstant.Suite);
  RegisterTest('PascalModule Tests', TestTResourceString.Suite);
  RegisterTest('PascalModule Tests', TestTVar.Suite);
  RegisterTest('PascalModule Tests', TestTThreadVar.Suite);
  RegisterTest('PascalModule Tests', TestTField.Suite);
  RegisterTest('PascalModule Tests', TestTExportsItem.Suite);
  RegisterTest('PascalModule Tests', TestTInitializationSection.Suite);
  RegisterTest('PascalModule Tests', TestTFinalizationSection.Suite);
 {
  RegisterTest('PascalModule Tests', TestTPascalModule.Suite);
  }
end.

