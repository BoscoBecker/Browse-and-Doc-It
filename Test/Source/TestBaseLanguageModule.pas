unit TestBaseLanguageModule;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, Graphics, SysUtils, Classes, BaseLanguageModule, Contnrs,
  CommonIDEFunctions;

type
  TElementContainerHelper = Class Helper for TElementContainer
    Function FirstError : String;
    Function FirstWarning : String;
    Function FirstHint : String;
    Function DocConflict(iConflict : Integer) : String;
    Procedure DeleteDocumentConflicts;
    Function HeadingCount(strHeading : String) : Integer;
  End;

  TBaseLanguageModuleHelper = Class Helper For TBaseLanguageModule
    Function CurrentToken : TTokenInfo;
  End;

  TClassOfTGenericTypeDecl = Class Of TGenericTypeDecl;

  TTestType = (ttErrors, ttWarnings, ttHints);
  TTestTypes = Set of TTestType;

  TExtendedTestCase = Class(TTestCase)
  Strict Private
  Public
    Procedure CheckEquals(ttExpected, ttActual : TBADITokenType;
      strMsg : String = ''); Overload;
    Procedure CheckEquals(iiExpected, iiActual : TBADIImageIndex;
      strMsg : String = ''); Overload;
    Procedure CheckEquals(iiExpected : TBADIImageIndex; iActual : Integer;
      strMsg : String = ''); Overload;
    Procedure CheckEquals(scExpected, scActual : TScope;
      strMsg : String = ''); Overload;
    Procedure CheckEquals(trExpected, trActual : TTokenReference;
      strMsg : String = ''); Overload;
    Procedure CheckEquals(ctExpected, ctActual : TCommentType;
      strMsg : String = ''); Overload;
    Procedure CheckEquals(strExpected, strActual : String;
      strMsg : String = ''); Overload; Override;
    Procedure TestGrammarForErrors(Parser : TBaseLanguageModuleClass;
      strTemplate : String; strInterface, strImplementation : String;
      TestTypes : TTestTypes; Const strCheckValues : Array Of String);
  Published
  End;

  // Test methods for class TTokenInfo

  TestTTokenInfo = class(TExtendedTestCase)
  strict private
    FTokenInfo: TTokenInfo;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAppend;
  end;

  TestTTag = class(TExtendedTestCase)
  strict private
    FTag: TTag;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAddToken;
    procedure TestAsString;
  end;

  TestTComment = class(TExtendedTestCase)
  strict private
    FComment: TComment;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCreateComment;
    procedure TestAssign;
    procedure TestAssign1;
    procedure TestAsString;
    procedure TestFindTag;
    Procedure TestWrap;
    Procedure TestCarriageReturns;
    Procedure TestDoubleAtSign;
    Procedure TestFailure01;
  end;

  // Test methods for class TElementContainer

  TTestElementContainer = Class(TElementContainer)
  Public
    Function AsString(boolShowIdentifier, boolForDocumentation : Boolean) : String; Override;
  End;

  TTestIdent = Class(TIdent)
  Public
    Function AsString(boolShowIdentifier, boolForDocumentation : Boolean) : String; Override;
  End;

  TestTElementContainer = class(TExtendedTestCase)
  strict private
    FElementContainer: TTestElementContainer;
    FComment : TComment;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestCreate;
    procedure TestAdd;
    procedure TestAdd1;
    procedure TestAdd2;
    procedure TestAddTokens;
    procedure TestFindElement;
    procedure TestAssign;
    procedure TestFindToken;
    procedure TestDeleteElement;
    procedure TestCheckDocumentation;
    procedure TestReferenceSymbol;
    procedure TestAddIssue;
    procedure TestAddDocumentConflict;
    procedure TestAsString;
    procedure TestCheckReferences;
    procedure TestReferenceSection;
    procedure TestElementCount;
    procedure TestElements;
    procedure TestComment;
    procedure TestScope;
    procedure TestImageIndex;
    procedure TestImageIndexAdjustedForScope;
    procedure TestSorted;
    procedure TestReferenced;
    procedure TestParent;
  end;

  // Test methods for class TDocIssue

  TestTDocIssue = class(TExtendedTestCase)
  strict private
    FDocIssue: TDocIssue;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
  end;

  TTestGenericTypeDecl = Class(TGenericTypeDecl)
  Public
    Function AsString(boolShowIdentifier, boolForDocumentation : Boolean) : String; Override;
  End;

  // Test methods for class TGenericTypeDecl

  TestTGenericTypeDecl = class(TExtendedTestCase)
  strict private
    FGenericTypeDecl: TGenericTypeDecl;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
  end;

  TTestGenericConstant = Class(TGenericConstant)
  Public
    Function AsString(boolShowIdentifier, boolForDocumentation : Boolean) : String; Override;
  End;

  // Test methods for class TGenericConstant

  TestTGenericConstant = class(TExtendedTestCase)
  strict private
    FGenericConstant: TGenericConstant;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
  end;

  TTestGenericVariable = Class(TGenericVariable)
  Public
    Function AsString(boolShowIdentifier, boolForDocumentation : Boolean) : String; Override;
  End;

  // Test methods for class TGenericVariable

  TestTGenericVariable = class(TExtendedTestCase)
  strict private
    FGenericVariable: TGenericVariable;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCheckDocumentation;
  end;

  TTestGenericParameter = Class(TGenericParameter)
  Public
    Function AsString(boolShowIdentifier, boolForDocumentation : Boolean) : String; Override;
  End;

  // Test methods for class TGenericParameter

  TestTGenericParameter = class(TExtendedTestCase)
  private
    FType: TTestGenericTypeDecl;
  strict private
    FGenericParameter: TGenericParameter;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestCreate;
    Procedure TestParamModifier;
    Procedure TestArrayOf;
    Procedure TestParamType;
    Procedure TestDefaultValue;
  end;

  TTestGenericMethodDecl = Class(TGenericMethodDecl)
  Public
    Function AsString(boolShowIdentifier, boolForDocumentation : Boolean) : String; Override;
  End;

  // Test methods for class TGenericMethodDecl

  TestTGenericMethodDecl = class(TExtendedTestCase)
  strict private
    FGenericMethodDecl: TGenericMethodDecl;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAddParameter;
    procedure TestCheckDocumentation;
    Procedure TestMethodType;
    Procedure TestClassNames;
    Procedure TestParameterCount;
    Procedure TestParameters;
    Procedure TestReturnType;
    Procedure TestMsg;
    Procedure TestExt;
    Procedure TestClassMethod;
    Procedure TestQualifiedName;
    Procedure TestAlias;
    Procedure TestForwardDecl;
  end;

  TTestGenericProperty = Class(TGenericProperty)
  Public
    Function AsString(boolShowIdentifier, boolForDocumentation : Boolean) : String; Override;
  End;

  // Test methods for class TGenericProperty

  TestTGenericProperty = class(TExtendedTestCase)
  strict private
    FGenericProperty: TGenericProperty;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAddParameter;
    procedure TestCheckDocumentation;
    Procedure TestParameterCount;
    Procedure TestParameters;
    Procedure TestTypeId;
  end;

  // Test methods for class TDocumentConflict

  TestTDocumentConflict = class(TExtendedTestCase)
  strict private
    FDocumentConflict: TDocumentConflict;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
    Procedure TestCommentLine;
    Procedure TestCommentColumn;
  end;

  // Test methods for class TLabelContainer

  TestTLabelContainer = class(TExtendedTestCase)
  strict private
    FLabelContainer: TLabelContainer;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAsString;
  end;

  TTestBaseLanguageModule = Class(TBaseLanguageModule)
  Public
    Property CompilerDefines;
    Function GetComment(CommentPosition : TCommentPosition = cpBeforeCurrentToken) : TComment; Override;
    procedure ProcessCompilerDirective(var iSkip : Integer); Override;
    Function ReservedWords : TKeyWords; Override;
    Function Directives : TKeyWords; Override;
  End;

  // Test methods for class TBaseLanguageModule

  TestTBaseLanguageModule = class(TTestCase)
  strict private
    FSource : String;
    FBaseLanguageModule: TTestBaseLanguageModule;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestCreate;
    Procedure TestAddTickCount;
    Procedure TestAddDef;
    Procedure TestDeleteDef;
    Procedure TestIfDef;
    Procedure TestIfNotDef;
    Procedure TestCheckDocumentation;
    Procedure TestAsString;
    Procedure TestAddToExpression;
    Procedure TestIsToken;
    Procedure TestOpTickCount;
    Procedure TestOpTickCounts;
    Procedure TestOpTickCountByIndex;
    Procedure TestOpTickCountName;
    Procedure TestModuleName;
    Procedure TestBodyComment;
    Procedure TestBodyCommentCount;
    Procedure TestModuleNameLine;
    Procedure TestModuleNameCol;
    Procedure TestFileName;
    Procedure TestModified;
    Procedure TestCompilerConditionStack;
    Procedure TestBytes;
    Procedure TestLines;
  end;

implementation

Uses
  Windows,
  TypInfo;

{ TTestBaseLanguageModule }

function TBaseLanguageModuleHelper.CurrentToken: TTokenInfo;
begin
  Result := Token;
end;

procedure TElementContainerHelper.DeleteDocumentConflicts;

Var
  i : Integer;

begin
  For i := ElementCount DownTo 1 Do
    If Elements[i].AsString(True, False) = strDocumentationConflicts Then
      DeleteElement(i);
end;

function TElementContainerHelper.DocConflict(iConflict : Integer): String;

Var
  E : TElementContainer;

begin
  Result := '(No Documentation Conflicts)';
  E := FindElement(strDocumentationConflicts);
  If (E <> Nil) And (E.ElementCount > 0) Then
    Begin
      E := E.Elements[1];
      If E.ElementCount >= iConflict Then
        Begin
          E := E.Elements[iConflict];
          Result := Format('%d) %s', [iConflict, E.AsString(True, False)]);
        End;
    End;
end;

function TElementContainerHelper.FirstError: String;

Var
  E : TElementContainer;

begin
  Result := '';
  E := FindElement(strErrors);
  If E <> Nil Then
    Result := StringReplace(Format('  [%s]', [E.Elements[1].AsString(True, False)]),
      #13#10, '(line-end)', [rfReplaceAll]);
end;

function TElementContainerHelper.FirstHint: String;

Var
  E : TElementContainer;

begin
  Result := '';
  E := FindElement(strHints);
  If E <> Nil Then
    Result := StringReplace(Format('  [%s]', [E.Elements[1].AsString(True, False)]),
      #13#10, '(line-end)', [rfReplaceAll]);
end;

function TElementContainerHelper.FirstWarning: String;

Var
  E : TElementContainer;

begin
  Result := '';
  E := FindElement(strWarnings);
  If E <> Nil Then
    Result := StringReplace(Format('  [%s]', [E.Elements[1].AsString(True, False)]),
      #13#10, '(line-end)', [rfReplaceAll]);
end;

function TElementContainerHelper.HeadingCount(strHeading : String): Integer;

var
  E: TElementContainer;

begin
  Result := 0;
  E := FindElement(strHeading);
  If E <> Nil Then
    Result := E.ElementCount;
end;

{ TTestBaseLanguageModule }

function TTestBaseLanguageModule.GetComment(CommentPosition : TCommentPosition = cpBeforeCurrentToken) : TComment;
begin
  Result := Nil;
end;

function TTestBaseLanguageModule.ReservedWords: TKeyWords;
begin
end;

function TTestBaseLanguageModule.Directives: TKeyWords;
begin
end;

procedure TTestBaseLanguageModule.ProcessCompilerDirective(var iSkip: Integer);
begin
end;

{ TExtendedTestCase }

Procedure TExtendedTestCase.TestGrammarForErrors(Parser : TBaseLanguageModuleClass;
  strTemplate : String; strInterface, strImplementation: String; TestTypes : TTestTypes;
  Const strCheckValues : Array Of String);

Const
  cDelimiter : Char = '\';

  Function GetElements(Element, ParentElement  : TElementContainer) : String;

  Var
    i : Integer;

  Begin
    Result := '';
    If Element = Nil Then
      Begin
        For i := 1 To ParentElement.ElementCount Do
          Begin
            If Result <> '' Then
              Result := Result + ', ';
            Result := Result + '[' + ParentElement.Elements[i].Identifier + ']';
          End;
      End;
  End;

  Function SearchForElement(Element : TElementContainer; strValue : String) : TElementContainer;

  Begin
    Result := Element.FindElement(strValue);
    If Result = Nil Then
      Result := Element.FindElement(strValue, ftIdentifier);
  End;

Var
  P: TBaseLanguageModule;
  T, U : TElementContainer;
  strValue: String;
  iCheck: Integer;
  strCheckValue: String;
  i : Integer;
  strKey : String;
  strValueScope : String;

Begin
  P := Parser.CreateParser(Format(strTemplate, [strInterface,
    strImplementation]), 'TestSource.pas', False, [moParse]);
  Try
    If ttHints In TestTypes Then
      CheckEquals(0, P.HeadingCount(strHints), 'HINTS: ' + P.FirstHint);
    If ttWarnings In TestTypes Then
      CheckEquals(0, P.HeadingCount(strWarnings), 'WARNINGS: ' + P.FirstWarning);
    If ttErrors In TestTypes Then
      CheckEquals(0, P.HeadingCount(strErrors), 'ERRORS: ' + P.FirstError);
    For iCheck := Low(strCheckValues) to High(strCheckValues) Do
      If strCheckValues[iCheck] <> '' Then
        Begin
         strCheckValue := strCheckValues[iCheck];
          T := P;
          While (Pos(cDelimiter, strCheckValue) > 0) And (Pos(cDelimiter, strCheckValue) < Pos('|', strCheckValue)) Do
            Begin
              strValue := Copy(strCheckValue, 1, Pos(cDelimiter, strCheckValue) - 1);
              Delete(strCheckValue, 1, Pos(cDelimiter, strCheckValue));
              U := SearchForElement(T, strValue);
              Check(U <> Nil, Format('%d.2) %s not found (found %s): %s', [Succ(iCheck), strValue, GetElements(U, T), strCheckValues[iCheck]]));
              T := U;
            End;
          Check(T.ElementCount > 0, Format('%d.3) Element Count: ', [Succ(iCheck), strCheckValues[iCheck]]));
          i := Pos('|', strCheckValue);
          Check(i > 0, Format('%d.4) Cannot find KEY to search for! ', [Succ(iCheck), strCheckValues[iCheck]]));
          strKey := Copy(strCheckvalue, 1, i - 1);
          Delete(strCheckValue, 1, i);
          i := Pos('|', strCheckValue);
          Check(i > 0, Format('%d.5) Cannot get scope: %s', [Succ(iCheck), strCheckvalues[iCheck]]));
          strValueScope := Copy(strCheckValue, i + 1, Length(strCheckValue) - i);
          Delete(strCheckValue, i, Length(strCheckValue) - (i - 1));

          U := SearchForElement(T, strKey);
          Check(U <> Nil, Format('%d.6) Cannot find KEY to check (%s): %s', [Succ(iCheck), GetElements(U, T), strCheckValues[iCheck]]));
          CheckEquals(strCheckValue, U.AsString(True, False), Format('%d.7) Value check failed: ', [Succ(iCheck), strCheckValues[iCheck]]));
          CheckEquals(strValueScope, GetEnumName(TypeInfo(TScope), Ord(U.Scope)), Format('%d.8) Incorrect Scope: %s', [Succ(iCheck), strCheckValues[iCheck]]));
        End Else
          Check(strCheckValue <> '', Format('%d.1) strCheckValue is NULL!', [Succ(iCheck)]));
  Finally
    P.Free;
  End;
End;

procedure TExtendedTestCase.CheckEquals(ttExpected, ttActual: TBADITokenType;
  strMsg: String = '');

begin
  FCheckCalled := True;
  If CompareText(strTokenType[ttExpected], strTokenType[ttActual]) <> 0 Then
    FailNotEquals(strTokenType[ttExpected], strTokenType[ttActual], strMsg,
      ReturnAddress);
end;

procedure TExtendedTestCase.CheckEquals(iiExpected, iiActual: TBADIImageIndex;
  strMsg: String = '');

begin
  FCheckCalled := True;
  If iiExpected <> iiActual Then
    FailNotEquals(BADIImageList[iiExpected].FResourcename,
      BADIImageList[iiActual].FResourcename,
      strMsg, ReturnAddress);
end;

procedure TExtendedTestCase.CheckEquals(scExpected, scActual: TScope;
  strMsg: String);

Const
  strScopes : Array[Low(TScope)..High(TScope)] Of String = (
    'scNone', 'scGlobal', 'scLocal', 'scPrivate', 'scProtected', 'scPublic',
    'scPublished', 'scFriend');

begin
  FCheckCalled := True;
  If CompareText(strScopes[scExpected], strScopes[scActual]) <> 0 Then
    FailNotEquals(strScopes[scExpected], strScopes[scActual], strMsg,
      ReturnAddress);
end;

procedure TExtendedTestCase.CheckEquals(trExpected, trActual: TTokenReference;
  strMsg: String);

Const
  strTokenReference : Array[Low(TTokenReference)..High(TTokenReference)] Of String = (
    'trUnknown', 'trUnresolved', 'trResolved');

begin
  FCheckCalled := True;
  If CompareText(strTokenReference[trExpected], strTokenReference[trActual]) <> 0 Then
    FailNotEquals(strTokenReference[trExpected], strTokenReference[trActual], strMsg,
      ReturnAddress);
end;

procedure TExtendedTestCase.CheckEquals(ctExpected, ctActual: TCommentType;
  strMsg: String);

Const
  strCommentTypes : Array[Low(TCommentType)..High(TCommentType)] Of String = (
    'ctNone', 'ctPascalBlock', 'ctPascalBrace', 'ctCPPBlock', 'ctCPPLine',
    'ctVBLine', 'ctXML');

begin
  FCheckCalled := True;
  If CompareText(strCommentTypes[ctExpected], strCommentTypes[ctActual]) <> 0 Then
    FailNotEquals(strCommentTypes[ctExpected], strCommentTypes[ctActual], strMsg,
      ReturnAddress);
end;

procedure TExtendedTestCase.CheckEquals(iiExpected: TBADIImageIndex;
  iActual: Integer; strMsg: String);

Var
  i : Integer;

begin
  FCheckCalled := True;
  i := Integer(iiExpected) - 1;
  If i <> iActual Then
    FailNotEquals(BADIImageList[iiExpected].FResourcename,
      BADIImageList[TBADIImageIndex(iActual + 1)].FResourcename, strMsg, ReturnAddress);
end;

Procedure TExtendedTestCase.CheckEquals(strExpected, strActual: String;
  strMsg: String);

Var
  i : Integer;
  iPosition : Integer;

Begin
  FCheckCalled := True;
  If CompareText(strExpected, strActual) <> 0 Then
    Begin
      iPosition := 0;
      For i := 1 To Length(strExpected) Do
        If Length(strActual) >= i Then
           If strActual[i] <> strExpected[i] Then
             Begin
               iPosition := i;
               Break;
             End;
      If iPosition = 0 Then
        strMsg := strMsg + ' {Actual too small}'
      Else
        strMsg := strMsg + Format( ' [[Difference @ character %d: %s]]',
          [iPosition, Copy(strActual, 1, iPosition)]);
      FailNotEquals(strExpected, strActual, strMsg, ReturnAddress);
    End;
End;

// Test methods for class TTokenInfo

procedure TestTTokenInfo.SetUp;
begin
  FTokenInfo := TTokenInfo.Create('Hello', 12, 23, 34, 5, ttIdentifier);
end;

procedure TestTTokenInfo.TearDown;
begin
  FTokenInfo.Free;
  FTokenInfo := nil;
end;

procedure TestTTokenInfo.TestAppend;

begin
  FTokenInfo.Append('Dave');
  CheckEquals('HelloDave', FTokenInfo.Token);
  CheckEquals(12, FTokenInfo.BufferPos);
  CheckEquals(23, FTokenInfo.Line);
  CheckEquals(34, FTokenInfo.Column);
  CheckEquals(9, FTokenInfo.Length);
end;

procedure TestTTokenInfo.TestCreate;
begin
  CheckEquals('Hello', FTokenInfo.Token);
  CheckEquals('', FTokenInfo.UToken);
  CheckEquals(12, FTokenInfo.BufferPos);
  CheckEquals(23, FTokenInfo.Line);
  CheckEquals(34, FTokenInfo.Column);
  CheckEquals(5, FTokenInfo.Length);
  CheckEquals(ttIdentifier, FTokenInfo.TokenType);
  CheckEquals(trUnknown, FTokenInfo.Reference);
end;

// Test methods for class TTag

procedure TestTTag.SetUp;
begin
  FTag := TTag.Create('todo', 12, 23);
end;

procedure TestTTag.TearDown;
begin
  FTag.Free;
  FTag := nil;
end;

procedure TestTTag.TestAddToken;

begin
  FTag.AddToken('Hello', ttIdentifier);
  FTag.AddToken('Dave', ttIdentifier);
  FTag.AddToken('.', ttSymbol);
  CheckEquals(3, FTag.TokenCount);
  CheckEquals('Hello', FTag.Tokens[0].Token);
  CheckEquals(ttIdentifier, FTag.Tokens[0].TokenType);
  CheckEquals('Dave', FTag.Tokens[1].Token);
  CheckEquals(ttIdentifier, FTag.Tokens[1].TokenType);
  CheckEquals('.', FTag.Tokens[2].Token);
  CheckEquals(ttSymbol, FTag.Tokens[2].TokenType);
end;

procedure TestTTag.TestAsString;

begin
  FTag.AddToken('Hello', ttIdentifier);
  FTag.AddToken(#32, ttWhiteSpace);
  FTag.AddToken('<b>', ttHTMLStartTag);
  FTag.AddToken('Dave', ttIdentifier);
  FTag.AddToken('</b>', ttHTMLEndTag);
  FTag.AddToken('.', ttSymbol);
  CheckEquals(ttHTMLStartTag, FTag.Tokens[2].TokenType);
  CheckEquals(ttHTMLEndTag, FTag.Tokens[4].TokenType);
  CheckEquals(6, FTag.TokenCount);
  CheckEquals('Hello Dave.', FTag.AsString(80, False));
  CheckEquals('Hello <b>Dave</b>.', FTag.AsString(80, True));
end;

procedure TestTTag.TestCreate;
begin
  CheckEquals('todo', FTag.TagName);
  CheckEquals(12, FTag.Line);
  CheckEquals(23, FTag.Column);
end;

// Test methods for class TComment

procedure TestTComment.SetUp;

Const
  strComment =
    ''#13#10 +
    '  This method does <b>something</b> wonderful.'#13#10 +
    ''#13#10 +
    '  @todo  Requires implementing.'#13#10 +
    '  @see   Something interesting.'#13#10 +
    '';

begin
  FComment := TComment.Create(strComment, 12, 34);
end;

procedure TestTComment.TearDown;
begin
  FComment.Free;
  FComment := nil;
end;

procedure TestTComment.TestCarriageReturns;

var
  C: TComment;

begin
  C := TComment.CreateComment('This is a comment#that has a carriage ' +
    'return#or 2 in it.', 12, 13);
  Try
    CheckEquals('This is a comment'#13#10'that has a carriage ' +
      'return'#13#10'or 2 in it.', C.AsString(80, False));
  Finally
    C.Free;
  End;
end;

procedure TestTComment.TestCreate;
begin
  CheckEquals(12, FComment.TokenCount);
  CheckEquals('This', FComment.Tokens[0].Token);
  CheckEquals('method', FComment.Tokens[2].Token);
  CheckEquals('does', FComment.Tokens[4].Token);
  CheckEquals('<b>', FComment.Tokens[6].Token);
  CheckEquals('something', FComment.Tokens[7].Token);
  CheckEquals('</b>', FComment.Tokens[8].Token);
  CheckEquals('wonderful', FComment.Tokens[10].Token);
  CheckEquals('.', FComment.Tokens[11].Token);
  CheckEquals(ttidentifier, FComment.Tokens[0].TokenType);
  CheckEquals(ttidentifier, FComment.Tokens[2].TokenType);
  CheckEquals(ttidentifier, FComment.Tokens[4].TokenType);
  CheckEquals(ttHTMLStartTag, FComment.Tokens[6].TokenType);
  CheckEquals(ttidentifier, FComment.Tokens[7].TokenType);
  CheckEquals(ttHTMLEndTag, FComment.Tokens[8].TokenType);
  CheckEquals(ttidentifier, FComment.Tokens[10].TokenType);
  CheckEquals(ttSymbol, FComment.Tokens[11].TokenType);
  CheckEquals('todo', FComment.Tag[0].TagName);
  CheckEquals('Requires implementing.', FComment.Tag[0].AsString(80, False));
  CheckEquals('see', FComment.Tag[1].TagName);
  CheckEquals('Something interesting.', FComment.Tag[1].AsString(80, False));
  CheckEquals(2, FComment.TagCount);
  CheckEquals(12, FComment.Line);
  CheckEquals(34, FComment.Column);
end;

procedure TestTComment.TestCreateComment;

Const
  strComment =
    ''#13#10 +
    '  This method does something <b>wonderful</b>.'#13#10 +
    ''#13#10 +
    '  @todo  Requires <e>implementing</e>.'#13#10 +
    '  @see   Something1 interesting.'#13#10 +
    '';

var
  ReturnValue: TComment;

begin
  ReturnValue := FComment.CreateComment(strComment, 12, 23);
  Try
    CheckEquals(12, ReturnValue.TokenCount);
    CheckEquals('This', ReturnValue.Tokens[0].Token);
    CheckEquals('method', ReturnValue.Tokens[2].Token);
    CheckEquals('does', ReturnValue.Tokens[4].Token);
    CheckEquals('something', ReturnValue.Tokens[6].Token);
    CheckEquals('<b>', ReturnValue.Tokens[8].Token);
    CheckEquals('wonderful', ReturnValue.Tokens[9].Token);
    CheckEquals('</b>', ReturnValue.Tokens[10].Token);
    CheckEquals('.', ReturnValue.Tokens[11].Token);
    CheckEquals(ttidentifier, ReturnValue.Tokens[0].TokenType);
    CheckEquals(ttidentifier, ReturnValue.Tokens[2].TokenType);
    CheckEquals(ttidentifier, ReturnValue.Tokens[4].TokenType);
    CheckEquals(ttidentifier, ReturnValue.Tokens[6].TokenType);
    CheckEquals(ttHTMLStartTag, ReturnValue.Tokens[8].TokenType);
    CheckEquals(ttidentifier, ReturnValue.Tokens[9].TokenType);
    CheckEquals(ttHTMLEndTag, ReturnValue.Tokens[10].TokenType);
    CheckEquals(ttSymbol, ReturnValue.Tokens[11].TokenType);
    CheckEquals('todo', ReturnValue.Tag[0].TagName);
    CheckEquals(15, ReturnValue.Tag[0].Line);
    CheckEquals(26, ReturnValue.Tag[0].Column);
    CheckEquals('Requires implementing.', ReturnValue.Tag[0].AsString(80, False));
    CheckEquals('Requires <e>implementing</e>.', ReturnValue.Tag[0].AsString(80, True));
    CheckEquals('see', ReturnValue.Tag[1].TagName);
    CheckEquals(16, ReturnValue.Tag[1].Line);
    CheckEquals(26, ReturnValue.Tag[1].Column);
    CheckEquals('Something1 interesting.', ReturnValue.Tag[1].AsString(80, False));
    CheckEquals(2, ReturnValue.TagCount);
    CheckEquals(12, ReturnValue.Line);
    CheckEquals(23, ReturnValue.Column);
  Finally
    ReturnValue.Free;
  End;
end;

procedure TestTComment.TestDoubleAtSign;

var
  C: TComment;

begin
  C := TComment.CreateComment('This is a test for the @@token.', 12, 23);
  Try
    CheckEquals(14, C.TokenCount);
    Checkequals('This', C.Tokens[0].Token);
    Checkequals('is', C.Tokens[2].Token);
    Checkequals('a', C.Tokens[4].Token);
    Checkequals('test', C.Tokens[6].Token);
    Checkequals('for', C.Tokens[8].Token);
    Checkequals('the', C.Tokens[10].Token);
    Checkequals('@@token', C.Tokens[12].Token);
    CheckEquals('This is a test for the @token.', C.AsString(80, False));
  Finally
    C.Free;
  End;
end;

procedure TestTComment.TestAssign;

var
  srcComment: TComment;

begin
  srcComment := TComment.Create(Nil);
  Try
    srcComment.Assign(FComment);
    CheckEquals(12, srcComment.TokenCount);
    CheckEquals('This', srcComment.Tokens[0].Token);
    CheckEquals('method', srcComment.Tokens[2].Token);
    CheckEquals('does', srcComment.Tokens[4].Token);
    CheckEquals('something', srcComment.Tokens[7].Token);
    CheckEquals('wonderful', srcComment.Tokens[10].Token);
    CheckEquals('.', srcComment.Tokens[11].Token);
    CheckEquals(ttidentifier, srcComment.Tokens[0].TokenType);
    CheckEquals(ttidentifier, srcComment.Tokens[2].TokenType);
    CheckEquals(ttidentifier, srcComment.Tokens[4].TokenType);
    CheckEquals(ttidentifier, srcComment.Tokens[7].TokenType);
    CheckEquals(ttidentifier, srcComment.Tokens[10].TokenType);
    CheckEquals(ttSymbol, srcComment.Tokens[11].TokenType);
    CheckEquals('todo', srcComment.Tag[0].TagName);
    CheckEquals('Requires implementing.', srcComment.Tag[0].AsString(80, False));
    CheckEquals('see', srcComment.Tag[1].TagName);
    CheckEquals('Something interesting.', srcComment.Tag[1].AsString(80, False));
    CheckEquals(2, srcComment.TagCount);
    CheckEquals(12, srcComment.Line);
    CheckEquals(34, srcComment.Column);
  Finally
    srcComment.Free;
  End;
end;

procedure TestTComment.TestAssign1;

Const
  strComment =
    ''#13#10 +
    '  This method does something wonderful.'#13#10 +
    ''#13#10 +
    '  @todo  Requires implementing.'#13#10 +
    '  @see   Something interesting.'#13#10 +
    '';

var
  C : TComment;

begin
  C := TComment.Create(Nil);
  Try
    C.Assign(strComment);
    CheckEquals(10, C.TokenCount);
    CheckEquals('This', C.Tokens[0].Token);
    CheckEquals('method', C.Tokens[2].Token);
    CheckEquals('does', C.Tokens[4].Token);
    CheckEquals('something', C.Tokens[6].Token);
    CheckEquals('wonderful', C.Tokens[8].Token);
    CheckEquals('.', C.Tokens[9].Token);
    CheckEquals(ttidentifier, C.Tokens[0].TokenType);
    CheckEquals(ttidentifier, C.Tokens[2].TokenType);
    CheckEquals(ttidentifier, C.Tokens[4].TokenType);
    CheckEquals(ttidentifier, C.Tokens[6].TokenType);
    CheckEquals(ttidentifier, C.Tokens[8].TokenType);
    CheckEquals(ttSymbol, C.Tokens[9].TokenType);
    CheckEquals('todo', C.Tag[0].TagName);
    CheckEquals('Requires implementing.', C.Tag[0].AsString(80, False));
    CheckEquals('see', C.Tag[1].TagName);
    CheckEquals('Something interesting.', C.Tag[1].AsString(80, False));
    CheckEquals(2, C.TagCount);
    CheckEquals(0, C.Line);
    CheckEquals(0, C.Column);
  Finally
    C.Free;
  End;
end;

procedure TestTComment.TestAsString;

begin
  CheckEquals('This method does something wonderful.', FComment.AsString(80, False));
  CheckEquals('This method does <b>something</b> wonderful.', FComment.AsString(80, True));
end;

procedure TestTComment.TestFailure01;

Var
  C: TComment;

begin
  C := TComment.Create(
    ' This is a comment.'#13#10 +
    ''#13#10 +
    '@todo This is the first todo item.'#13#10 +
    '@todo This is the second todo item.'#13#10 +
    '@todo This is the third todo item.'#13#10, 0, 0);
  Try
    CheckEquals(8, C.TokenCount);
    CheckEquals(3, C.TagCount);
    CheckEquals('This is the first todo item.', C.Tag[0].AsString(80, False));
    CheckEquals('This is the second todo item.', C.Tag[1].AsString(80, False));
    CheckEquals('This is the third todo item.', C.Tag[2].AsString(80, False));
  Finally
    C.Free;
  End;
end;

procedure TestTComment.TestFindTag;

begin
  CheckEquals(-1, FComment.FindTag('hello'));
  CheckEquals(0, FComment.FindTag('todo'));
  CheckEquals(1, FComment.FindTag('see'));
end;

procedure TestTComment.TestWrap;

Var
  C : TComment;

begin
  C := TComment.CreateComment('This is a comment that should get wrap at the ' +
    '80th column of text, so will see if this works.', 12, 13);
  Try
    CheckEquals('This is a comment that should get wrap at the 80th column of ' +
      'text, so will see '#13#10'if this works.', C.AsString(80, False));
  Finally
    C.Free;
  End;
end;

{ TTestElementContainer }

function TTestElementContainer.AsString(boolShowIdentifier, boolForDocumentation : Boolean): String;
begin
  Result := Identifier;
end;

{ TTestIdent }

function TTestIdent.AsString(boolShowIdentifier, boolForDocumentation : Boolean): String;
begin
  result := Identifier;
end;

// Test methods for class TElementContainer

procedure TestTElementContainer.SetUp;
begin
  FComment := TComment.CreateComment('This is a test comment.', 12, 23);
  FElementContainer := TTestElementContainer.Create('TestElement', scPrivate, 12, 23,
    iiPublicConstant, FComment);
end;

procedure TestTElementContainer.TearDown;
begin
  FComment.Free;
  FElementContainer.Free;
  FElementContainer := nil;
end;

procedure TestTElementContainer.TestAdd;

begin
  FElementContainer.Add(TTestElementContainer.Create('Hello', scPrivate, 1, 2, iiUsesItem, Nil));
  CheckEquals(1, FElementContainer.ElementCount);
  CheckEquals('Hello', FElementContainer.Elements[1].Identifier);
end;

procedure TestTElementContainer.TestAdd1;

begin
  FElementContainer.Add('Hello', iiUsesItem, scPrivate, Nil);
  CheckEquals(1, FElementContainer.ElementCount);
  CheckEquals('Hello', FElementContainer.Elements[1].Identifier);
end;

procedure TestTElementContainer.TestAdd2;

Var
  T : TTokenInfo;

begin
  T := TTokenInfo.Create('Hello', 1, 2, 3, 5, ttUnknown);
  Try
    FElementContainer.Add(T, scPrivate, iiUsesItem, Nil);
    CheckEquals(1, FElementContainer.ElementCount);
    CheckEquals('Hello', FElementContainer.Elements[1].Identifier);
  Finally
    T.Free;
  End;
end;

procedure TestTElementContainer.TestAddTokens;

var
  E : TElementContainer;

begin
  E := TTestElementContainer.Create('Tmp', scNone, 0, 0, iiNone, Nil);
  Try
    E.AddToken('Hello');
    E.AddToken('Dave');
    E.AddToken('.');
    FElementContainer.AddTokens(E);
    CheckEquals(3, FElementContainer.TokenCount);
    CheckEquals('Hello', FElementContainer.Tokens[0].Token);
    CheckEquals('Dave', FElementContainer.Tokens[1].Token);
    CheckEquals('.', FElementContainer.Tokens[2].Token);
  Finally
    E.Free;
  End;
end;

procedure TestTElementContainer.TestFindElement;

var
  E : TElementContainer;

begin
  E := TTestElementContainer.Create('Tmp3', scNone, 0, 0, iiNone, Nil);
  FElementContainer.Add(E);
  E := TTestElementContainer.Create('Tmp2', scNone, 0, 0, iiNone, Nil);
  FElementContainer.Add(E);
  E := TTestElementContainer.Create('Tmp1', scNone, 0, 0, iiNone, Nil);
  FElementContainer.Add(E);
  Check(FElementContainer.FindElement('Tmp2') <> Nil, 'FindElement is null');
  Check(FElementContainer.FindElement('Tmp3', ftIdentifier) <> Nil, 'FindElement is null');
end;

procedure TestTElementContainer.TestAssign;

var
  E: TElementContainer;

begin
  E := TTestElementContainer.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    E.Assign(FElementContainer);
    CheckEquals(scPrivate, E.Scope);
    CheckEquals(12, E.Line);
    CheckEquals(23, E.Column);
    Check(E.Comment <> Nil, 'Comment is null');
  Finally
    E.Free;
  End;
end;

procedure TestTElementContainer.TestFindToken;

begin
  FElementContainer.AddToken('Hello');
  FElementContainer.AddToken('Dave');
  FElementContainer.AddToken('.');
  CheckEquals(1, FElementContainer.FindToken('Dave'));
end;

procedure TestTElementContainer.TestImageIndex;
begin
  CheckEquals(iiPublicConstant, FElementContainer.ImageIndex);
end;

procedure TestTElementContainer.TestImageIndexAdjustedForScope;
begin
  CheckEquals(iiPrivateConstant, FElementContainer.ImageIndexAdjustedForScope);
end;

procedure TestTElementContainer.TestParent;
var
  E: TElementContainer;
begin
  Check(FElementContainer.Parent = Nil, 'Parent is not null');
  E := TTestElementContainer.Create('Test', scNone, 1, 2, iiNone, Nil);
  FElementContainer.Add(E);
  Check(E.Parent = FElementContainer, 'Parent is not FElementContainer');
end;

procedure TestTElementContainer.TestDeleteElement;

var
  E : TElementContainer;

begin
  E := TTestElementContainer.Create('Tmp3', scNone, 0, 0, iiNone, Nil);
  FElementContainer.Add(E);
  E := TTestElementContainer.Create('Tmp2', scNone, 0, 0, iiNone, Nil);
  FElementContainer.Add(E);
  E := TTestElementContainer.Create('Tmp1', scNone, 0, 0, iiNone, Nil);
  FElementContainer.Add(E);
  CheckEquals(3, FElementContainer.ElementCount);
  FElementContainer.DeleteElement(2);
  CheckEquals(2, FElementContainer.ElementCount);
  CheckEquals('Tmp1', FElementContainer.Elements[1].Identifier);
  CheckEquals('Tmp3', FElementContainer.Elements[2].Identifier);
end;

procedure TestTElementContainer.TestElementCount;

var
  E : TElementContainer;

begin
  CheckEquals(0, FElementContainer.ElementCount);
  E := TTestElementContainer.Create('Tmp3', scNone, 0, 0, iiNone, Nil);
  FElementContainer.Add(E);
  CheckEquals(1, FElementContainer.ElementCount);
  E := TTestElementContainer.Create('Tmp2', scNone, 0, 0, iiNone, Nil);
  FElementContainer.Add(E);
  CheckEquals(2, FElementContainer.ElementCount);
  E := TTestElementContainer.Create('Tmp1', scNone, 0, 0, iiNone, Nil);
  FElementContainer.Add(E);
  CheckEquals(3, FElementContainer.ElementCount);
end;

procedure TestTElementContainer.TestElements;

var
  E : TElementContainer;

begin
  E := TTestElementContainer.Create('Tmp3', scNone, 0, 0, iiNone, Nil);
  FElementContainer.Add(E);
  E := TTestElementContainer.Create('Tmp2', scNone, 0, 0, iiNone, Nil);
  FElementContainer.Add(E);
  E := TTestElementContainer.Create('Tmp1', scNone, 0, 0, iiNone, Nil);
  FElementContainer.Add(E);
  CheckEquals('Tmp1', FElementContainer.Elements[1].Identifier);
  CheckEquals('Tmp2', FElementContainer.Elements[2].Identifier);
  CheckEquals('Tmp3', FElementContainer.Elements[3].Identifier);
end;

procedure TestTElementContainer.TestCheckDocumentation;

var
  boolCascade: Boolean;

begin
  FElementContainer.CheckDocumentation(boolCascade);
  Checkequals(0, FElementContainer.ElementCount);
end;

procedure TestTElementContainer.TestReferenceSymbol;

var
  AToken: TTokenInfo;

begin
  AToken := TTokenInfo.Create('Hello', 0, 1, 2, 5, ttUnknown);
  Try
    CheckEquals(False, FElementContainer.ReferenceSymbol(AToken));
  Finally
    AToken.Free;
  End;
end;

procedure TestTElementContainer.TestScope;
begin
  CheckEquals(scPrivate, FElementContainer.Scope);
end;

procedure TestTElementContainer.TestSorted;
begin
  CheckEquals(True, FElementContainer.Sorted);
end;

procedure TestTElementContainer.TestAddIssue;

begin
  FElementContainer.AddIssue('This is a warning.', scNone,
    'MyMethod', 1, 2, etWarning);
  CheckEquals(1, FElementContainer.ElementCount);
  CheckEquals('Warnings', FElementContainer.Elements[1].AsString(False, False));
  CheckEquals('This is a warning. [MyMethod]',
    FElementContainer.Elements[1].Elements[1].AsString(False, False));
end;

procedure TestTElementContainer.TestAddDocumentConflict;

Var
  rec : TDocConflictTable;
  DC : TElementContainer;
  strCategory : String;

begin
  strCategory := 'Things';
  rec.FMessage := 'This is a document conflict message (%s, %s).';
  rec.FDescription := 'This is a document conflict description.';
  rec.FConflictType := dciMissing;
  FElementContainer.AddDocumentConflict(['First', 'Second'], 12, 23, Nil,
    strCategory, rec);
  DC := FElementContainer.FindElement(strDocumentationConflicts);
  Check(DC <> Nil, 'DC is null');
  CheckEquals(strDocumentationConflicts, DC.Identifier);
  DC := DC.FindElement('Things');
  Check(DC <> Nil, 'DC is null');
  CheckEquals('Things', DC.Identifier);
  DC := DC.Elements[1];
  Check(DC Is TDocumentConflict, 'DC is not TDocIssue');
  CheckEquals('This is a document conflict message (First, Second).',
    (DC As TDocumentConflict).AsString(True, False));
End;

procedure TestTElementContainer.TestAsString;

begin
  CheckEquals('TestElement', FElementContainer.AsString(true, False));
end;

procedure TestTElementContainer.TestCheckReferences;
begin
  FElementContainer.Referenced := True;
  FElementContainer.CheckReferences;
  CheckEquals(0, FElementContainer.ElementCount);
  FElementContainer.Referenced := False;
  FElementContainer.CheckReferences;
  CheckEquals(1, FElementContainer.ElementCount);
end;

procedure TestTElementContainer.TestComment;
begin
  CheckEquals('This is a test comment.', FElementContainer.Comment.AsString(9999, False));
end;

procedure TestTElementContainer.TestCreate;
begin
  CheckEquals('TestElement', FElementContainer.Identifier);
  CheckEquals(scPrivate, FElementContainer.Scope);
  CheckEquals(12, FElementContainer.Line);
  CheckEquals(23, FElementContainer.Column);
  CheckEquals(iiPrivateConstant, FElementContainer.ImageIndexAdjustedForScope);
  Check(FElementContainer.Comment <> Nil, 'Comment is null');
end;

procedure TestTElementContainer.TestReferenced;
begin
  CheckEquals(False, FElementContainer.Referenced);
  FElementContainer.Referenced := True;
  CheckEquals(True, FElementContainer.Referenced);
end;

procedure TestTElementContainer.TestReferenceSection;

var
  V : TLabelContainer;
  AToken: TTokenInfo;
  T: TElementContainer;

begin
  V := TLabelContainer.Create(strVarsLabel, scNone, 0, 0, iiPublicVariablesLabel, Nil);
  FElementContainer.Add(V);
  T := TTestIdent.Create('Test', scPrivate, 1, 2, iiPublicVariable, Nil);
  V.Add(T);
  AToken := TTokenInfo.Create('Test', 0, 1, 2, 5, ttUnknown);
  Try
    CheckEquals(trUnknown, AToken.Reference);
    CheckEquals(False, T.Referenced);
    Check(FElementContainer.ReferenceSection(AToken, V));
    CheckEquals(trResolved, AToken.Reference);
    CheckEquals(True, T.Referenced);
  Finally
    AToken.Free;
  End;
end;

// Test methods for class TDocIssue

procedure TestTDocIssue.SetUp;
begin
  FDocIssue := TDocIssue.Create('This is a simple message.',
    scNone, 'MyMethod', 1, 2, iiWarning);
end;

procedure TestTDocIssue.TearDown;
begin
  FDocIssue.Free;
  FDocIssue := nil;
end;

procedure TestTDocIssue.TestAsString;

begin
  CheckEquals('This is a simple message. [MyMethod]', FDocIssue.AsString(True, False));
end;

procedure TestTDocIssue.TestCreate;
begin
  CheckEquals('This is a simple message. [MyMethod]', FDocIssue.AsString(True, False));
  CheckEquals(scNone, FDocIssue.Scope);
  CheckEquals(1, FDocIssue.Line);
  CheckEquals(2, FDocIssue.Column);
  CheckEquals(iiWarning, FDocIssue.ImageIndex);
end;

{ TTestGenericTypeDecl }

function TTestGenericTypeDecl.AsString(boolShowIdentifier, boolForDocumentation : Boolean): String;
begin
  Result := BuildStringRepresentation(boolShowIdentifier, boolForDocumentation, '', 9999);
end;

// Test methods for class TGenericTypeDecl;

procedure TestTGenericTypeDecl.SetUp;
begin
  FGenericTypeDecl := TTestGenericTypeDecl.Create('MyType', scProtected, 23, 34,
    iiPublicType, Nil);
end;

procedure TestTGenericTypeDecl.TearDown;
begin
  FGenericTypeDecl.Free;
  FGenericTypeDecl := nil;
end;

procedure TestTGenericTypeDecl.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  FGenericTypeDecl.CheckDocumentation(boolCascade);
  CheckEquals(1, FGenericTypeDecl.ElementCount);
  CheckEquals('1) Type ''MyType'' is undocumented.', FGenericTypeDecl.DocConflict(1));
  FGenericTypeDecl.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment.', 0, 0);
  Try
    FGenericTypeDecl.Comment := C;
    FGenericTypeDecl.CheckDocumentation(boolCascade);
    CheckEquals(0, FGenericTypeDecl.ElementCount, FGenericTypeDecl.DocConflict(1));
  Finally
    C.Free;
  End;
end;

procedure TestTGenericTypeDecl.TestCreate;
begin
  CheckEquals('MyType', FGenericTypeDecl.Identifier);
  CheckEquals(scProtected, FGenericTypeDecl.Scope);
  CheckEquals(23, FGenericTypeDecl.Line);
  CheckEquals(34, FGenericTypeDecl.Column);
  CheckEquals(iiPublicType, FGenericTypeDecl.ImageIndex);
  CheckEquals(iiProtectedType, FGenericTypeDecl.ImageIndexAdjustedForScope);
end;

{ TTestGenericConstant }

function TTestGenericConstant.AsString(boolShowIdentifier, boolForDocumentation : Boolean): String;
begin
  Result := Identifier;
end;

// Test methods for class TGenericConstant

procedure TestTGenericConstant.SetUp;
begin
  FGenericConstant := TTestGenericConstant.Create('MyConstant', scPublished, 23,
    34, iiPublicConstant, Nil);
end;

procedure TestTGenericConstant.TearDown;
begin
  FGenericConstant.Free;
  FGenericConstant := nil;
end;

procedure TestTGenericConstant.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  FGenericConstant.CheckDocumentation(boolCascade);
  CheckEquals(1, FGenericConstant.ElementCount);
  CheckEquals('1) Constant ''MyConstant'' is undocumented.', FGenericConstant.DocConflict(1));
  FGenericConstant.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment.', 0, 0);
  Try
    FGenericConstant.Comment := C;
    FGenericConstant.CheckDocumentation(boolCascade);
    CheckEquals(0, FGenericConstant.ElementCount, FGenericConstant.DocConflict(1));
  Finally
    C.Free;
  End;
end;

procedure TestTGenericConstant.TestCreate;
begin
  CheckEquals('MyConstant', FGenericConstant.Identifier);
  CheckEquals(scPublished, FGenericConstant.Scope);
  CheckEquals(23, FGenericConstant.Line);
  CheckEquals(34, FGenericConstant.Column);
  CheckEquals(iiPublicConstant, FGenericConstant.ImageIndex);
  CheckEquals(iiPublishedConstant, FGenericConstant.ImageIndexAdjustedForScope);
end;

{ TTestGenericVariable }

function TTestGenericVariable.AsString(boolShowIdentifier, boolForDocumentation : Boolean): String;
begin
  Result := Identifier;
end;

// Test methods for class TGenericVariable

procedure TestTGenericVariable.SetUp;
begin
  FGenericVariable := TTestGenericVariable.Create('MyVariable', scPublic, 23,
    34, iiPublicConstant, Nil);
end;

procedure TestTGenericVariable.TearDown;
begin
  FGenericVariable.Free;
  FGenericVariable := nil;
end;

procedure TestTGenericVariable.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  FGenericVariable.CheckDocumentation(boolCascade);
  CheckEquals(1, FGenericVariable.ElementCount);
  CheckEquals('1) Variable ''MyVariable'' is undocumented.', FGenericVariable.DocConflict(1));
  FGenericVariable.DeleteDocumentConflicts;
  C := TComment.Create('This is a comment.', 0, 0);
  Try
    FGenericVariable.Comment := C;
    FGenericVariable.CheckDocumentation(boolCascade);
    CheckEquals(0, FGenericVariable.ElementCount, FGenericVariable.DocConflict(1));
  Finally
    C.Free;
  End;
end;

procedure TestTGenericVariable.TestCreate;
begin
  CheckEquals('MyVariable', FGenericVariable.Identifier);
  CheckEquals(scPublic, FGenericVariable.Scope);
  CheckEquals(23, FGenericVariable.Line);
  CheckEquals(34, FGenericVariable.Column);
  CheckEquals(iiPublicConstant, FGenericVariable.ImageIndex);
  CheckEquals(iiPublicConstant, FGenericVariable.ImageIndexAdjustedForScope);
end;

{ TTestGenericParameter }

function TTestGenericParameter.AsString(boolShowIdentifier,
  boolForDocumentation : Boolean): String;
begin
  Result := Identifier + #32'='#32 + ParamType.AsString(boolShowIdentifier,
    boolForDocumentation);
end;

// Test method for class TGenericParameter

procedure TestTGenericParameter.SetUp;
begin
  FType := TTestGenericTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  FType.AddToken('String');
  FGenericParameter := TTestGenericParameter.Create(pamVar, 'MyParam', True,
    FType, 'Something', scPrivate, 3, 4);
end;

procedure TestTGenericParameter.TearDown;
begin
  FGenericParameter.Free;
  FGenericParameter := nil;
  FType.Free;
end;

procedure TestTGenericParameter.TestArrayOf;
begin
  CheckEquals(True, FGenericParameter.ArrayOf);
end;

procedure TestTGenericParameter.TestCreate;
begin
  CheckEquals('MyParam', FGenericParameter.Identifier);
  CheckEquals(scPrivate, FGenericParameter.Scope);
  CheckEquals(3, FGenericParameter.Line);
  CheckEquals(4, FGenericParameter.Column);
end;

procedure TestTGenericParameter.TestDefaultValue;
begin
  CheckEquals('Something', FGenericParameter.DefaultValue);
end;

procedure TestTGenericParameter.TestParamModifier;

Const
  strPM : Array[Low(TParamModifier)..High(TParamModifier)] Of String = (
    'pamNone', 'pamVar', 'pamConst', 'pamOut');

begin
  CheckEquals(strPM[pamVar], strPM[FGenericParameter.ParamModifier]);
end;

procedure TestTGenericParameter.TestParamType;
begin
  Checkequals('String', FGenericParameter.ParamType.AsString(False, False));
end;

{ TTestGenericMethodDecl }

function TTestGenericMethodDecl.AsString(boolShowIdentifier,
  boolForDocumentation : Boolean): String;
begin
  Result := Identifier;
end;

// Test methods for class TGenericMethodDecl

procedure TestTGenericMethodDecl.SetUp;

Var
  T : TTestGenericTypeDecl;

begin
  FGenericMethodDecl := TTestGenericMethodDecl.Create(mtFunction, 'MyFunction',
    scProtected, 34, 45);
  T := TTestGenericTypeDecl.Create('Boolean', scNone, 0, 0, iiNone, Nil);
  T.AddToken('Boolean');
  FGenericMethodDecl.ReturnType.Add(T);

end;

procedure TestTGenericMethodDecl.TearDown;
begin
  FGenericMethodDecl.Free;
  FGenericMethodDecl := nil;
end;

procedure TestTGenericMethodDecl.TestAddParameter;

var
  P: TGenericParameter;
  AType: TGenericTypeDecl;

begin
  AType := TTestGenericTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('String');
    P := TTestGenericParameter.Create(pamNone, 'Param1', False, AType, '', scNone, 0, 0);
    FGenericMethodDecl.AddParameter(P);
    CheckEquals(1, FGenericMethodDecl.ParameterCount);
    CheckEquals('Param1 = String', FGenericMethodDecl.Parameters[0].AsString(False, False));
  Finally
    AType.Free;
  End;
end;

procedure TestTGenericMethodDecl.TestAlias;
begin
  CheckEquals('', FGenericMethodDecl.Alias);
  FGenericMethodDecl.Alias := 'MyFunctionA';
  CheckEquals('MyFunctionA', FGenericMethodDecl.Alias);
end;

procedure TestTGenericMethodDecl.TestCheckDocumentation;

var
  boolCascade: Boolean;
  AType: TTestGenericTypeDecl;
  P : TTestGenericParameter;
  C: TComment;
  M: TGenericMethodDecl;

begin
  AType := TTestGenericTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('String');
    P := TTestGenericParameter.Create(pamNone, 'Param1', False, AType, '', scNone, 0, 0);
    FGenericMethodDecl.AddParameter(P);
    AType.ClearTokens;
    AType.AddToken('Integer');
    P := TTestGenericParameter.Create(pamVar, 'Param2', True, AType, '0', scNone, 0, 0);
    FGenericMethodDecl.AddParameter(P);
    AType.ClearTokens;
    AType.AddToken('Byte');
    P := TTestGenericParameter.Create(pamConst, 'Param3', False, AType, '', scNone, 0, 0);
    FGenericMethodDecl.AddParameter(P);
    AType.ClearTokens;
    AType.AddToken('Double');
    P := TTestGenericParameter.Create(pamOut, 'Param4', False, AType, '', scNone, 0, 0);
    FGenericMethodDecl.AddParameter(P);
    CheckEquals(4, FGenericMethodDecl.ParameterCount);
    CheckEquals('Param1 = String', FGenericMethodDecl.Parameters[0].AsString(False, False));
    CheckEquals('Param2 = Integer', FGenericMethodDecl.Parameters[1].AsString(False, False));
    CheckEquals('Param3 = Byte', FGenericMethodDecl.Parameters[2].AsString(False, False));
    CheckEquals('Param4 = Double', FGenericMethodDecl.Parameters[3].AsString(False, False));
    FGenericMethodDecl.CheckDocumentation(boolCascade);
    CheckEquals('1) Method ''MyFunction'' has not been documented.', FGenericMethodDecl.DocConflict(1));
    FGenericMethodDecl.DeleteDocumentConflicts;
    C := TComment.Create('', 0, 0);
    Try
      FGenericMethodDecl.Comment := C;
      FGenericMethodDecl.CheckDocumentation(boolCascade);
      CheckEquals('1) Method ''MyFunction'' has no description.', FGenericMethodDecl.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericMethodDecl.DeleteDocumentConflicts;
    C := TComment.Create(
      'This is a description.', 0, 0);
    Try
      FGenericMethodDecl.Comment := C;
      FGenericMethodDecl.CheckDocumentation(boolCascade);
      CheckEquals('1) A pre-condition in Method ''MyFunction'' is not documented.', FGenericMethodDecl.DocConflict(1));
      CheckEquals('2) Method ''MyFunction'' has a different parameter count (4 not 0).', FGenericMethodDecl.DocConflict(2));
      CheckEquals('3) Method ''MyFunction'' has missing pre-condition tags.', FGenericMethodDecl.DocConflict(3));
      CheckEquals('4) Parameter ''Param1'' in Method ''MyFunction'' is not documented.', FGenericMethodDecl.DocConflict(4));
    Finally
      C.Free;
    End;
    FGenericMethodDecl.DeleteDocumentConflicts;
    C := TComment.Create(
      'This is a description.'#13#10 +
      '@precon', 0, 0);
    Try
      FGenericMethodDecl.Comment := C;
      FGenericMethodDecl.CheckDocumentation(boolCascade);
      CheckEquals('1) A pre-condition in Method ''MyFunction'' is not documented.', FGenericMethodDecl.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericMethodDecl.DeleteDocumentConflicts;
    C := TComment.Create(
      'This is a description.'#13#10 +
      '@precon None.', 0, 0);
    Try
      FGenericMethodDecl.Comment := C;
      FGenericMethodDecl.CheckDocumentation(boolCascade);
      CheckEquals('1) Method ''MyFunction'' has a different parameter count (4 not 0).', FGenericMethodDecl.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericMethodDecl.DeleteDocumentConflicts;
    C := TComment.Create(
      'This is a description.'#13#10'@precon None.'#13#10 +
      '@precon None.', 0, 0);
    Try
      FGenericMethodDecl.Comment := C;
      FGenericMethodDecl.CheckDocumentation(boolCascade);
      CheckEquals('2) Method ''MyFunction'' has too many pre-condition tags.', FGenericMethodDecl.DocConflict(2));
    Finally
      C.Free;
    End;
    FGenericMethodDecl.DeleteDocumentConflicts;
    C := TComment.Create(
      'This is a description.'#13#10 +
      '@precon None.'#13#10 +
      '@postcon '#13#10 +
      '@param param1 as an String'#13#10 +
      '@param param2 as an Array of Integer as a reference'#13#10 +
      '@param param3 as an Byte as a constant'#13#10 +
      '@param param4 as a Double as an out parameter'#13#10 +
      '@return a Boolean', 0, 0);
    Try
      FGenericMethodDecl.Comment := C;
      FGenericMethodDecl.CheckDocumentation(boolCascade);
      CheckEquals('1) A post-condition in Method ''MyFunction'' is not documented.', FGenericMethodDecl.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericMethodDecl.DeleteDocumentConflicts;
    C := TComment.Create(
      'This is a description.'#13#10 +
      '@precon None.'#13#10 +
      '@param param1 as an String'#13#10 +
      '@param param2 as an Array of Integer as a reference'#13#10 +
      '@param param3 as an Byte as a constant'#13#10 +
      '@param param4 as a Double as an out parameter'#13#10 +
      '@return a Boolean', 0, 0);
    Try
      FGenericMethodDecl.Comment := C;
      FGenericMethodDecl.CheckDocumentation(boolCascade);
      CheckEquals('1) Method ''MyFunction'' has a missing post-condition tag.', FGenericMethodDecl.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericMethodDecl.DeleteDocumentConflicts;
    C := TComment.Create(
      'This is a description.'#13#10 +
      '@precon None.'#13#10 +
      '@postcon None.'#13#10 +
      '@postcon None.'#13#10 +
      '@param param1 as an String'#13#10 +
      '@param param2 as an Array of Integer as a reference'#13#10 +
      '@param param3 as an Byte as a constant'#13#10 +
      '@param param4 as a Double as an out parameter'#13#10 +
      '@return a Boolean', 0, 0);
    Try
      FGenericMethodDecl.Comment := C;
      FGenericMethodDecl.CheckDocumentation(boolCascade);
      CheckEquals('1) Method ''MyFunction'' has too many post-condition tags.', FGenericMethodDecl.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericMethodDecl.DeleteDocumentConflicts;
    C := TComment.Create(
      'This is a description.'#13#10'@precon None.'#13#10 +
      '@postcon None.'#13#10 +
      '@param param1 as an Integer'#13#10 +
      '@param param2 as an Array of Integer as a reference'#13#10 +
      '@param param3 as an Byte as a constant'#13#10 +
      '@param param4 as a Double as an out parameter', 0, 0);
    Try
      FGenericMethodDecl.Comment := C;
      FGenericMethodDecl.CheckDocumentation(boolCascade);
      CheckEquals('1) The parameter type for ''Param1'' in Method ''MyFunction'' is incorrect (''String'').',
        FGenericMethodDecl.DocConflict(1));
      CheckEquals('2) Method ''MyFunction''`s return type is not documented.',
        FGenericMethodDecl.DocConflict(2));
    Finally
      C.Free;
    End;
    FGenericMethodDecl.DeleteDocumentConflicts;
    C := TComment.Create(
      'This is a description.'#13#10'@precon None.'#13#10 +
      '@postcon None.'#13#10 +
      '@param param1 as an String'#13#10 +
      '@param param2 as an Array of Integer as a reference'#13#10 +
      '@param param3 as an Byte as a constant'#13#10 +
      '@param param4 as a Double as an out parameter'#13#10 +
      '@return a Thingy', 0, 0);
    Try
      FGenericMethodDecl.Comment := C;
      FGenericMethodDecl.CheckDocumentation(boolCascade);
      CheckEquals('1) Method ''MyFunction''`s return type is incorrect (''Boolean'').',
        FGenericMethodDecl.DocConflict(1));
    Finally
      C.Free;
    End;
    M := TTestGenericMethodDecl.Create(mtProcedure, 'MyProcedure', scPrivate, 0, 0);
    Try
      M.DeleteDocumentConflicts;
      C := TComment.Create(
        'This is a description.'#13#10'@precon None.'#13#10 +
        '@postcon None.'#13#10 +
        '@return a Thingy', 0, 0);
      Try
        M.Comment := C;
        M.CheckDocumentation(boolCascade);
        CheckEquals('1) Method ''MyProcedure''`s return type is not required.',
          M.DocConflict(1));
      Finally
        C.Free;
      End;
    Finally
      M.Free;
    End;

    FGenericMethodDecl.DeleteDocumentConflicts;
    C := TComment.Create(
      'This is a description.'#13#10'@precon None.'#13#10 +
      '@postcon None.'#13#10 +
      '@param param1 as an String - a string'#13#10 +
      '@param param2 as an Array of Integer as a reference - an array'#13#10 +
      '@param param3 as an Byte as a constant - a constant'#13#10 +
      '@param param4 as a Double as an out parameter - a double'#13#10 +
      '@return a Boolean - something', 0, 0);
    Try
      FGenericMethodDecl.Comment := C;
      FGenericMethodDecl.CheckDocumentation(boolCascade);
      CheckEquals(0, FGenericMethodDecl.HeadingCount(strDocumentationConflicts),
        FGenericMethodDecl.DocConflict(1));
    Finally
      C.Free;
    End;

  Finally
    AType.Free;
  End;
end;

procedure TestTGenericMethodDecl.TestClassMethod;
begin
  CheckEquals(False, FGenericMethodDecl.ClassMethod);
  FGenericMethodDecl.ClassMethod := True;
  CheckEquals(True, FGenericMethodDecl.ClassMethod);
end;

procedure TestTGenericMethodDecl.TestClassNames;
begin
  CheckEquals(0, FGenericMethodDecl.ClassNames.Count);
  FGenericMethodDecl.ClassNames.Add('THello');
  CheckEquals(1, FGenericMethodDecl.ClassNames.Count);
  CheckEquals('THello', FGenericMethodDecl.ClassNames[0]);
end;

procedure TestTGenericMethodDecl.TestCreate;
begin
  CheckEquals('MyFunction', FGenericMethodDecl.Identifier);
  CheckEquals(scProtected, FGenericMethodDecl.Scope);
  CheckEquals(34, FGenericMethodDecl.Line);
  CheckEquals(45, FGenericMethodDecl.Column);
  CheckEquals(iiPublicFunction, FGenericMethodDecl.ImageIndex);
  CheckEquals(iiProtectedFunction, FGenericMethodDecl.ImageIndexAdjustedForScope);
end;

procedure TestTGenericMethodDecl.TestExt;
begin
  CheckEquals('', FGenericMethodDecl.Ext);
  FGenericMethodDecl.Ext := 'MyFunctionA';
  CheckEquals('MyFunctionA', FGenericMethodDecl.Ext);
end;

procedure TestTGenericMethodDecl.TestForwardDecl;
begin
  CheckEquals(False, FGenericMethodDecl.ForwardDecl);
  FGenericMethodDecl.ForwardDecl := True;
  CheckEquals(True, FGenericMethodDecl.ForwardDecl);
end;

procedure TestTGenericMethodDecl.TestMethodType;

Const
  strMT : Array[Low(TMethodType)..High(TMethodType)] Of String = (
    'mtConstructor', 'mtDestructor', 'mtProcedure', 'mtFunction', 'mtOperator');

begin
  CheckEquals(strMT[mtFunction], strMT[FGenericMethodDecl.MethodType]);
end;

procedure TestTGenericMethodDecl.TestMsg;
begin
  CheckEquals('', FGenericMethodDecl.Msg);
  FGenericMethodDecl.Msg := 'WM_PAINT';
  CheckEquals('WM_PAINT', FGenericMethodDecl.Msg);
end;

procedure TestTGenericMethodDecl.TestParameterCount;
var
  AType: TTestGenericTypeDecl;
  P: TTestGenericParameter;
begin
  AType := TTestGenericTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('String');
    P := TTestGenericParameter.Create(pamNone, 'Param1', False, AType, '', scNone, 0, 0);
    FGenericMethodDecl.AddParameter(P);
    CheckEquals(1, FGenericMethodDecl.ParameterCount);
  Finally
    AType.Free;
  End;
end;

procedure TestTGenericMethodDecl.TestParameters;
var
  AType: TTestGenericTypeDecl;
  P: TTestGenericParameter;
begin
  AType := TTestGenericTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('String');
    P := TTestGenericParameter.Create(pamNone, 'Param1', False, AType, '', scNone, 0, 0);
    FGenericMethodDecl.AddParameter(P);
    CheckEquals('Param1 = String', FGenericMethodDecl.Parameters[0].AsString(False, False));
  Finally
    AType.Free;
  End;
end;

procedure TestTGenericMethodDecl.TestQualifiedName;
begin
  CheckEquals('MyFunction', FGenericMethodDecl.QualifiedName);
  FGenericMethodDecl.ClassNames.Add('THello');
  CheckEquals('THello.MyFunction', FGenericMethodDecl.QualifiedName);
end;

procedure TestTGenericMethodDecl.TestReturnType;
begin
  CheckEquals('Boolean', FGenericMethodDecl.ReturnType.AsString(False, False));
end;

{ TTestGenericProperty }

function TTestGenericProperty.AsString(boolShowIdentifier,
  boolForDocumentation : Boolean): String;
begin
  Result := Identifier;
end;

// Test methods for the class TGenericProperty

procedure TestTGenericProperty.SetUp;

Var
  T : TTestGenericTypeDecl;

begin
  FGenericProperty := TTestGenericProperty.Create('MyProperty', scProtected, 12,
    23, iiPublicProperty, Nil);
  T := TTestGenericTypeDecl.Create('Boolean', scNone, 0, 0, iiNone, Nil);
  T.AddToken('Boolean');
  FGenericProperty.ReturnType.Add(T);
end;

procedure TestTGenericProperty.TearDown;
begin
  FGenericProperty.Free;
  FGenericProperty := nil;
end;

procedure TestTGenericProperty.TestAddParameter;

var
  P: TGenericParameter;
  AType: TTestGenericTypeDecl;

begin
  AType := TTestGenericTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('String');
    P := TTestGenericParameter.Create(pamNone, 'Param1', False, AType, '', scNone, 0, 0);
    FGenericProperty.AddParameter(P);
    CheckEquals(1, FGenericProperty.ParameterCount);
    CheckEquals('Param1 = String', FGenericProperty.Parameters[0].AsString(False, False));
  Finally
    AType.Free;
  End;
end;

procedure TestTGenericProperty.TestCheckDocumentation;

var
  AType: TTestGenericTypeDecl;
  P: TTestGenericParameter;
  C: TComment;
  boolCascade: Boolean;

begin
  AType := TTestGenericTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('String');
    P := TTestGenericParameter.Create(pamNone, 'Param1', False, AType, '', scNone, 0, 0);
    FGenericProperty.AddParameter(P);
    AType.ClearTokens;
    AType.AddToken('Integer');
    P := TTestGenericParameter.Create(pamVar, 'Param2', True, AType, '0', scNone, 0, 0);
    FGenericProperty.AddParameter(P);
    AType.ClearTokens;
    AType.AddToken('Byte');
    P := TTestGenericParameter.Create(pamConst, 'Param3', False, AType, '', scNone, 0, 0);
    FGenericProperty.AddParameter(P);
    AType.ClearTokens;
    AType.AddToken('Double');
    P := TTestGenericParameter.Create(pamOut, 'Param4', False, AType, '', scNone, 0, 0);
    FGenericProperty.AddParameter(P);
    CheckEquals(4, FGenericProperty.ParameterCount);
    CheckEquals('Param1 = String', FGenericProperty.Parameters[0].AsString(False, False));
    CheckEquals('Param2 = Integer', FGenericProperty.Parameters[1].AsString(False, False));
    CheckEquals('Param3 = Byte', FGenericProperty.Parameters[2].AsString(False, False));
    CheckEquals('Param4 = Double', FGenericProperty.Parameters[3].AsString(False, False));
    FGenericProperty.CheckDocumentation(boolCascade);
    CheckEquals('1) Property ''MyProperty'' has not been documented.', FGenericProperty.DocConflict(1));
    FGenericProperty.DeleteDocumentConflicts;
    C := TComment.Create(
      '', 0, 0);
    Try
      FGenericProperty.Comment := C;
      FGenericProperty.CheckDocumentation(boolCascade);
      CheckEquals('1) Property ''MyProperty'' has no description.', FGenericProperty.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericProperty.DeleteDocumentConflicts;
    C := TComment.Create(
      'This is a description.', 0, 0);
    Try
      FGenericProperty.Comment := C;
      FGenericProperty.CheckDocumentation(boolCascade);
      CheckEquals('1) A pre-condition in Property ''MyProperty'' is not documented.', FGenericProperty.DocConflict(1));
      CheckEquals('2) Property ''MyProperty'' has a different parameter count (4 not 0).', FGenericProperty.DocConflict(2));
      CheckEquals('3) Property ''MyProperty'' has missing pre-condition tags.', FGenericProperty.DocConflict(3));
    Finally
      C.Free;
    End;
    FGenericProperty.DeleteDocumentConflicts;
    C := TComment.Create(
      ''#13#10 +
      '  This method does something interesting.'#13#10 +
      '  @precon  None.'#13#10 +
      '  @postcon Does something very interesting.'#13#10 +
      '  @param   Param1 as a Integer'#13#10 +
      '  @param   Param2 as an array of Integer as a reference'#13#10 +
      '  @param   Param3 as a Byte as a constant'#13#10 +
      '  @param   Param4 as a Double as an out parameter'#13#10 +
      '  @return  a Boolean', 0, 0);
    Try
      FGenericProperty.Comment := C;
      FGenericProperty.CheckDocumentation(boolCascade);
      CheckEquals('1) The parameter type for ''Param1'' in Property ''MyProperty'' is incorrect (''String'').', FGenericProperty.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericProperty.DeleteDocumentConflicts;
    C := TComment.Create(
      ''#13#10 +
      '  This method does something interesting.'#13#10 +
      '  @precon  None.'#13#10 +
      '  @postcon Does something very interesting.'#13#10 +
      '  @param   Param1 as a String'#13#10 +
      '  @param   Param2 as an array of Integer as a reference'#13#10 +
      '  @param   Param3 as a Byte as a constant'#13#10 +
      '  @param   Param4 as a Double as an out parameter', 0, 0);
    Try
      FGenericProperty.Comment := C;
      FGenericProperty.CheckDocumentation(boolCascade);
      CheckEquals('1) Property ''MyProperty''`s return type is not documented.', FGenericProperty.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericProperty.DeleteDocumentConflicts;
    C := TComment.Create(
      ''#13#10 +
      '  This method does something interesting.'#13#10 +
      '  @precon  None.'#13#10 +
      '  @postcon Does something very interesting.'#13#10 +
      '  @param   Param1 as a String'#13#10 +
      '  @param   Param2 as an array of Integer as a reference'#13#10 +
      '  @param   Param3 as a Byte as a constant'#13#10 +
      '  @param   Param4 as a Double as an out parameter'#13#10 +
      '  @return  a String', 0, 0);
    Try
      FGenericProperty.Comment := C;
      FGenericProperty.CheckDocumentation(boolCascade);
      CheckEquals('1) Property ''MyProperty''`s return type is incorrect (''Boolean'').', FGenericProperty.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericProperty.DeleteDocumentConflicts;
    C := TComment.Create(
      ''#13#10 +
      '  This method does something interesting.'#13#10 +
      '  @precon '#13#10 +
      '  @param   Param1 as a String'#13#10 +
      '  @param   Param2 as an array of Integer as a reference'#13#10 +
      '  @param   Param3 as a Byte as a constant'#13#10 +
      '  @param   Param4 as a Double as an out parameter'#13#10 +
      '  @return  a Boolean', 0, 0);
    Try
      FGenericProperty.Comment := C;
      FGenericProperty.CheckDocumentation(boolCascade);
      CheckEquals('1) A pre-condition in Property ''MyProperty'' is not documented.', FGenericProperty.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericProperty.DeleteDocumentConflicts;
    C := TComment.Create(
      ''#13#10 +
      '  This method does something interesting.'#13#10 +
      '  @precon None'#13#10 +
      '  @precon None'#13#10 +
      '  @param   Param1 as a String'#13#10 +
      '  @param   Param2 as an array of Integer as a reference'#13#10 +
      '  @param   Param3 as a Byte as a constant'#13#10 +
      '  @param   Param4 as a Double as an out parameter'#13#10 +
      '  @return  a Boolean', 0, 0);
    Try
      FGenericProperty.Comment := C;
      FGenericProperty.CheckDocumentation(boolCascade);
      CheckEquals('1) Property ''MyProperty'' has too many pre-condition tags.', FGenericProperty.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericProperty.DeleteDocumentConflicts;
    C := TComment.Create(
      ''#13#10 +
      '  This method does something interesting.'#13#10 +
      '  @precon None'#13#10 +
      '  @postcon'#13#10 +
      '  @param   Param1 as a String'#13#10 +
      '  @param   Param2 as an array of Integer as a reference'#13#10 +
      '  @param   Param3 as a Byte as a constant'#13#10 +
      '  @param   Param4 as a Double as an out parameter'#13#10 +
      '  @return  a Boolean', 0, 0);
    Try
      FGenericProperty.Comment := C;
      FGenericProperty.CheckDocumentation(boolCascade);
      CheckEquals('1) A post-condition in Property ''MyProperty'' is not documented.', FGenericProperty.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericProperty.DeleteDocumentConflicts;
    C := TComment.Create(
      ''#13#10 +
      '  This method does something interesting.'#13#10 +
      '  @precon None'#13#10 +
      '  @param   Param1 as a String'#13#10 +
      '  @param   Param2 as an array of Integer as a reference'#13#10 +
      '  @param   Param3 as a Byte as a constant'#13#10 +
      '  @param   Param4 as a Double as an out parameter'#13#10 +
      '  @return  a Boolean', 0, 0);
    Try
      FGenericProperty.Comment := C;
      FGenericProperty.CheckDocumentation(boolCascade);
      CheckEquals('1) Property ''MyProperty'' has a missing post-condition tag.', FGenericProperty.DocConflict(1));
    Finally
      C.Free;
    End;
    FGenericProperty.DeleteDocumentConflicts;
    C := TComment.Create(
      ''#13#10 +
      '  This method does something interesting.'#13#10 +
      '  @precon None'#13#10 +
      '  @postcon None'#13#10 +
      '  @postcon None'#13#10 +
      '  @param   Param1 as a String'#13#10 +
      '  @param   Param2 as an array of Integer as a reference'#13#10 +
      '  @param   Param3 as a Byte as a constant'#13#10 +
      '  @param   Param4 as a Double as an out parameter'#13#10 +
      '  @return  a Boolean', 0, 0);
    Try
      FGenericProperty.Comment := C;
      FGenericProperty.CheckDocumentation(boolCascade);
      CheckEquals('1) Property ''MyProperty'' has too many post-condition tags.', FGenericProperty.DocConflict(1));
    Finally
      C.Free;
    End;


    FGenericProperty.DeleteDocumentConflicts;
    C := TComment.Create(
      ''#13#10 +
      '  This method does something interesting.'#13#10 +
      '  @precon  None.'#13#10 +
      '  @postcon Does something very interesting.'#13#10 +
      '  @param   Param1 as a String'#13#10 +
      '  @param   Param2 as an array of Integer as a reference'#13#10 +
      '  @param   Param3 as a Byte as a constant'#13#10 +
      '  @param   Param4 as a Double as an out parameter'#13#10 +
      '  @return  a Boolean', 0, 0);
    Try
      FGenericProperty.Comment := C;
      FGenericProperty.CheckDocumentation(boolCascade);
      CheckEquals(0, FGenericProperty.ElementCount, FGenericProperty.DocConflict(1));
    Finally
      C.Free;
    End;
  Finally
    AType.Free;
  End;
end;

procedure TestTGenericProperty.TestCreate;
begin
  CheckEquals('MyProperty', FGenericProperty.Identifier);
  CheckEquals(scProtected, FGenericProperty.Scope);
  CheckEquals(12, FGenericProperty.Line);
  CheckEquals(23, FGenericProperty.Column);
  CheckEquals(iiPublicProperty, FGenericProperty.ImageIndex);
  CheckEquals(iiProtectedProperty, FGenericProperty.ImageIndexAdjustedForScope);
end;

procedure TestTGenericProperty.TestParameterCount;
var
  AType: TTestGenericTypeDecl;
  P: TTestGenericParameter;
begin
  AType := TTestGenericTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('String');
    P := TTestGenericParameter.Create(pamNone, 'Param1', False, AType, '', scNone, 0, 0);
    FGenericProperty.AddParameter(P);
    CheckEquals(1, FGenericProperty.ParameterCount);
  Finally
    AType.Free;
  End;
end;

procedure TestTGenericProperty.TestParameters;
var
  AType: TTestGenericTypeDecl;
  P: TTestGenericParameter;
begin
  AType := TTestGenericTypeDecl.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    AType.AddToken('String');
    P := TTestGenericParameter.Create(pamNone, 'Param1', False, AType, '', scNone, 0, 0);
    FGenericProperty.AddParameter(P);
    CheckEquals(1, FGenericProperty.ParameterCount);
  Finally
    AType.Free;
  End;
end;

procedure TestTGenericProperty.TestTypeId;
begin
  CheckEquals('Boolean', FGenericProperty.ReturnType.AsString(False, False));
end;

// Test methods for class TDocumentConflict

procedure TestTDocumentConflict.SetUp;
begin
  FDocumentConflict := TDocumentConflict.Create(['First', 'Second'], 12, 23, 34,
    45, 'This is a message with a first parameter (%s) and a second parameter (%s).',
    'This is a description string.', iiDocConflictMissing);
end;

procedure TestTDocumentConflict.TearDown;
begin
  FDocumentConflict.Free;
  FDocumentConflict := nil;
end;

procedure TestTDocumentConflict.TestAsString;

begin
  Checkequals('This is a message with a first parameter (First) and a second ' +
    'parameter (Second).', FDocumentConflict.AsString(True, False));
end;

procedure TestTDocumentConflict.TestCommentColumn;
begin
  CheckEquals(45, FDocumentConflict.CommentColumn);
end;

procedure TestTDocumentConflict.TestCommentLine;
begin
  CheckEquals(34, FDocumentConflict.CommentLine);
end;

procedure TestTDocumentConflict.TestCreate;
begin
  CheckEquals(12, FDocumentConflict.Line);
  CheckEquals(23, FDocumentConflict.Column);
end;

// Test methods for class TLabelContainer

procedure TestTLabelContainer.SetUp;
begin
  FLabelContainer := TLabelContainer.Create(strImplementedMethodsLabel, scNone,
    12, 23, iiImplementedMethods, Nil);
end;

procedure TestTLabelContainer.TearDown;
begin
  FLabelContainer.Free;
  FLabelContainer := nil;
end;

procedure TestTLabelContainer.TestAsString;
begin
  CheckEquals(strImplementedMethodsLabel, FLabelContainer.AsString(True, False));
end;

procedure TestTLabelContainer.TestCreate;
begin
  CheckEquals(strImplementedMethodsLabel, FLabelContainer.Identifier);
  CheckEquals(scNone, FLabelContainer.Scope);
  CheckEquals(12, FLabelContainer.Line);
  CheckEquals(23, FLabelContainer.Column);
  CheckEquals(iiImplementedMethods, FLabelContainer.ImageIndex);
  CheckEquals(iiImplementedMethods, FLabelContainer.ImageIndexAdjustedForScope);
end;

// Test methods for class TBaseLanguageModule

procedure TestTBaseLanguageModule.SetUp;
begin
  FSource := 'This is some text.';
  FBaseLanguageModule := TTestBaseLanguageModule.CreateParser(FSource,
    'D:\Path\TestFile.txt', True, [moParse, moCheckForDocumentConflicts]);
  FBaseLanguageModule.AddToken(TTokenInfo.Create('Hello', 0, 1, 1, 5, ttIdentifier));
  FBaseLanguageModule.AddToken(TTokenInfo.Create('Goodbye', 7, 1, 7, 7, ttIdentifier));
end;

procedure TestTBaseLanguageModule.TearDown;
begin
  FBaseLanguageModule.Free;
  FBaseLanguageModule := nil;
end;

procedure TestTBaseLanguageModule.TestAddDef;
begin
  CheckEquals(0, FBaseLanguageModule.CompilerDefines.Count);
  FBaseLanguageModule.AddDef('Compiler_Def');
  CheckEquals(1, FBaseLanguageModule.CompilerDefines.Count);
end;

procedure TestTBaseLanguageModule.TestAddTickCount;
begin
  CheckEquals(0, FBaseLanguageModule.OpTickCounts);
  FBaseLanguageModule.AddTickCount('Hello');
  CheckEquals(1, FBaseLanguageModule.OpTickCounts);
end;

procedure TestTBaseLanguageModule.TestAddToExpression;
var
  C: TElementContainer;
begin
  C := TTestElementContainer.Create('', scNone, 0, 0, iiNone, Nil);
  Try
    Checkequals(0, C.TokenCount);
    FBaseLanguageModule.AddToExpression(C);
    Checkequals(1, C.TokenCount);
  Finally
    C.Free;
  End;
end;

procedure TestTBaseLanguageModule.TestAsString;
begin
  CheckEquals('TestFile.txt', FBaseLanguageModule.AsString(True, False));
end;

procedure TestTBaseLanguageModule.TestBodyComment;
begin
  FBaseLanguageModule.AddBodyComment(TComment.Create('Hello.', 0, 0));
  CheckEquals('Hello.', FBaseLanguageModule.BodyComment[0].AsString(99, False));
end;

procedure TestTBaseLanguageModule.TestBodyCommentCount;
begin
  CheckEquals(0, FBaseLanguageModule.BodyCommentCount);
  FBaseLanguageModule.AddBodyComment(TComment.Create('Hello.', 0, 0));
  CheckEquals(1, FBaseLanguageModule.BodyCommentCount);
end;

procedure TestTBaseLanguageModule.TestBytes;
begin
  CheckEquals(5 + 1 + 7, FBaseLanguageModule.Bytes);
end;

procedure TestTBaseLanguageModule.TestCheckDocumentation;
var
  boolCascade: Boolean;
  C: TComment;
begin
  FBaseLanguageModule.CheckDocumentation(boolCascade);
  Checkequals('1) This module has no document comment.', FBaseLanguageModule.DocConflict(1));
  FBaseLanguageModule.DeleteDocumentConflicts;
  C := TComment.Create('This is a description.', 0, 0);
  Try
    FBaseLanguageModule.Comment := C;
    FBaseLanguageModule.CheckDocumentation(boolCascade);
    Checkequals('1) This module is missing a documentation date (''' +
      FormatDateTime('dd mmm yyyy', Now) + ''').', FBaseLanguageModule.DocConflict(1));
  Finally
    C.Free;
  End;
  FBaseLanguageModule.DeleteDocumentConflicts;
  C := TComment.Create('This is a description.'#13#10 +
    '@date ' + FormatDateTime('dd mmm yyyy', Now - 7), 0, 0);
  Try
    FBaseLanguageModule.Comment := C;
    FBaseLanguageModule.CheckDocumentation(boolCascade);
    Checkequals('1) The module documentation date ''' +
      FormatDateTime('dd mmm yyyy', Now - 7) + ''' is incorrect (''' +
      FormatDateTime('dd mmm yyyy', Now) + ''').', FBaseLanguageModule.DocConflict(1));
  Finally
    C.Free;
  End;
  FBaseLanguageModule.DeleteDocumentConflicts;
  C := TComment.Create('This is a description.'#13#10 +
    '@date ' + FormatDateTime('dd mmm yyyy', Now), 0, 0);
  Try
    FBaseLanguageModule.Comment := C;
    FBaseLanguageModule.CheckDocumentation(boolCascade);
    Checkequals('1) This module is missing a documentation version.', FBaseLanguageModule.DocConflict(1));
  Finally
    C.Free;
  End;
  FBaseLanguageModule.DeleteDocumentConflicts;
  C := TComment.Create('This is a description.'#13#10 +
    '@date ' + FormatDateTime('dd mmm yyyy', Now) +#13#10+
    '@version 1.0', 0, 0);
  Try
    FBaseLanguageModule.Comment := C;
    FBaseLanguageModule.CheckDocumentation(boolCascade);
    Checkequals('1) This module is missing a documentation author.', FBaseLanguageModule.DocConflict(1));
  Finally
    C.Free;
  End;
  FBaseLanguageModule.DeleteDocumentConflicts;
  C := TComment.Create('This is a description.'#13#10 +
    '@date 32 jan 2008', 0, 0);
  Try
    FBaseLanguageModule.Comment := C;
    FBaseLanguageModule.CheckDocumentation(boolCascade);
    Checkequals('1) The module documentation date ''32 jan 2008'' is not valid (''' +
      FormatDateTime('dd mmm yyyy', Now) + ''').', FBaseLanguageModule.DocConflict(1));
  Finally
    C.Free;
  End;
end;

procedure TestTBaseLanguageModule.TestCompilerConditionStack;
begin
  CheckEquals(0, FBaseLanguageModule.CompilerConditionStack.Count);
  FBaseLanguageModule.CompilerConditionStack.Add(Pointer(1));
  CheckEquals(1, FBaseLanguageModule.CompilerConditionStack.Count);
  FBaseLanguageModule.CompilerConditionStack.Clear;
  CheckEquals(0, FBaseLanguageModule.CompilerConditionStack.Count);
end;

procedure TestTBaseLanguageModule.TestCreate;
begin
  CheckEquals(True, FBaseLanguageModule.Modified);
  CheckEquals('D:\Path\TestFile.txt', FBaseLanguageModule.FileName);
end;

procedure TestTBaseLanguageModule.TestDeleteDef;
begin
  CheckEquals(0, FBaseLanguageModule.CompilerDefines.Count);
  FBaseLanguageModule.AddDef('Hello');
  CheckEquals(1, FBaseLanguageModule.CompilerDefines.Count);
  FBaseLanguageModule.DeleteDef('Hello');
  CheckEquals(0, FBaseLanguageModule.CompilerDefines.Count);
end;

procedure TestTBaseLanguageModule.TestFileName;
begin
  CheckEquals('D:\Path\TestFile.txt', FBaseLanguageModule.FileName);
end;

procedure TestTBaseLanguageModule.TestIfDef;
begin
  CheckEquals(False, FBaseLanguageModule.IfDef('Hello'));
  FBaseLanguageModule.AddDef('Hello');
  CheckEquals(True, FBaseLanguageModule.IfDef('Hello'));
  FBaseLanguageModule.DeleteDef('Hello');
  CheckEquals(False, FBaseLanguageModule.IfDef('Hello'));
end;

procedure TestTBaseLanguageModule.TestIfNotDef;
begin
  CheckEquals(True, FBaseLanguageModule.IfNotDef('Hello'));
  FBaseLanguageModule.AddDef('Hello');
  CheckEquals(False, FBaseLanguageModule.IfNotDef('Hello'));
  FBaseLanguageModule.DeleteDef('Hello');
  CheckEquals(True, FBaseLanguageModule.IfNotDef('Hello'));
end;

procedure TestTBaseLanguageModule.TestIsToken;
begin
  CheckEquals(True, FBaseLanguageModule.IsToken('Hello', Nil));
end;

procedure TestTBaseLanguageModule.TestLines;
begin
  CheckEquals(1, FBaseLanguageModule.Lines);
end;

procedure TestTBaseLanguageModule.TestModified;
begin
  CheckEquals(True, FBaseLanguageModule.Modified);
end;

procedure TestTBaseLanguageModule.TestModuleName;
begin
  CheckEquals('D:\Path\TestFile.txt', FBaseLanguageModule.ModuleName);
  FBaseLanguageModule.ModuleName := 'TestFile.txt';
  CheckEquals('TestFile.txt', FBaseLanguageModule.ModuleName);
end;

procedure TestTBaseLanguageModule.TestModuleNameCol;
begin
  CheckEquals(0, FBaseLanguageModule.ModuleNameCol);
  FBaseLanguageModule.ModuleNameCol := 1;
  CheckEquals(1, FBaseLanguageModule.ModuleNameCol);
end;

procedure TestTBaseLanguageModule.TestModuleNameLine;
begin
  CheckEquals(0, FBaseLanguageModule.ModuleNameLine);
  FBaseLanguageModule.ModuleNameLine := 1;
  CheckEquals(1, FBaseLanguageModule.ModuleNameLine);
end;

procedure TestTBaseLanguageModule.TestOpTickCount;
begin
  FBaseLanguageModule.AddTickCount('Hello');
  FBaseLanguageModule.AddTickCount('Goodbye');
  CheckEquals(0, FBaseLanguageModule.OpTickCount['Hello', 'Goodbye']);
end;

procedure TestTBaseLanguageModule.TestOpTickCountByIndex;
begin
  FBaseLanguageModule.AddTickCount('Hello'); // more than 24 days since last restart.
  //Role over of GetTickCount() due to being put in a 32 Int instead of a 64 bit int
  FBaseLanguageModule.AddTickCount('Goodbye');
  Check(FBaseLanguageModule.OpTickCountByIndex[0] > 0);
  Check(FBaseLanguageModule.OpTickCountByIndex[1] >= FBaseLanguageModule.OpTickCountByIndex[0]);
end;

procedure TestTBaseLanguageModule.TestOpTickCountName;
begin
  FBaseLanguageModule.AddTickCount('Hello');
  FBaseLanguageModule.AddTickCount('Goodbye');
  CheckEquals('Hello', FBaseLanguageModule.OpTickCountName[0]);
  CheckEquals('Goodbye', FBaseLanguageModule.OpTickCountName[1]);
end;

procedure TestTBaseLanguageModule.TestOpTickCounts;
begin
  CheckEquals(0, FBaseLanguageModule.OpTickCounts);
  FBaseLanguageModule.AddTickCount('Hello');
  CheckEquals(1, FBaseLanguageModule.OpTickCounts);
  FBaseLanguageModule.AddTickCount('Goodbye');
  CheckEquals(2, FBaseLanguageModule.OpTickCounts);
end;

initialization
  BrowseAndDocItOptions.Options := [doCustomDrawing..doStrictConstantExpressions];
  // Register any test cases with the test runner
  RegisterTest('BaseLanguageModule Tests', TestTTokenInfo.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTTag.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTComment.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTElementContainer.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTDocIssue.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTGenericTypeDecl.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTGenericConstant.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTGenericVariable.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTGenericParameter.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTGenericMethodDecl.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTGenericProperty.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTDocumentConflict.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTLabelContainer.Suite);
  RegisterTest('BaseLanguageModule Tests', TestTBaseLanguageModule.Suite);
End.

