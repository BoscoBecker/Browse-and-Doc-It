unit TestBaseLanguageModule;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, Graphics, SysUtils, Classes, BaseLanguageModule, Contnrs;

type

  TExtendedTestCase = Class(TTestCase)
  Strict Private
  Public
    Procedure CheckEquals(ttExpected, ttActual : TBADITokenType;
      strMsg : String = ''); Overload;
    Procedure CheckEquals(scExpected, scActual : TScope;
      strMsg : String = ''); Overload;
    Procedure CheckEquals(trExpected, trActual : TTokenReference;
      strMsg : String = ''); Overload;
  Published
  End;

  // Test methods for class TTokenInfo

  TestTTokenInfo = class(TExtendedTestCase)
  strict private
    FTokenInfo: TTokenInfo;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAppend;
  end;

  TestTTag = class(TExtendedTestCase)
  strict private
    FTag: TTag;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestAddToken;
    procedure TestAsString;
  end;

  TestTComment = class(TExtendedTestCase)
  strict private
    FComment: TComment;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    Procedure TestCreate;
    procedure TestCreateComment;
    procedure TestAssign;
    procedure TestAssign1;
    procedure TestAsString;
    procedure TestFindTag;
  end;

implementation

Uses
  Windows;

{ TExtendedTestCase }

procedure TExtendedTestCase.CheckEquals(ttExpected, ttActual: TBADITokenType;
  strMsg: String = '');

begin
  FCheckCalled := True;
  If AnsiCompareText(strTokenType[ttExpected], strTokenType[ttActual]) <> 0 Then
    FailNotEquals(strTokenType[ttExpected], strTokenType[ttActual], strMsg,
      CallerAddr);
end;

procedure TExtendedTestCase.CheckEquals(scExpected, scActual: TScope;
  strMsg: String);

Const
  strScopes : Array[Low(TScope)..High(TScope)] Of String = (
    'scNone', 'scGlobal', 'scLocal', 'scPrivate', 'scProtected', 'scPublic',
    'scPublished', 'scFriend');

begin
  FCheckCalled := True;
  If AnsiCompareText(strScopes[scExpected], strScopes[scActual]) <> 0 Then
    FailNotEquals(strScopes[scExpected], strScopes[scActual], strMsg,
      CallerAddr);
end;

procedure TExtendedTestCase.CheckEquals(trExpected, trActual: TTokenReference;
  strMsg: String);

Const
  strTokenReference : Array[Low(TTokenReference)..High(TTokenReference)] Of String = (
    'trUnknown', 'trUnresolved', 'trResolved');

begin
  FCheckCalled := True;
  If AnsiCompareText(strTokenReference[trExpected], strTokenReference[trActual]) <> 0 Then
    FailNotEquals(strTokenReference[trExpected], strTokenReference[trActual], strMsg,
      CallerAddr);
end;

// Test methods for class TTokenInfo

procedure TestTTokenInfo.SetUp;
begin
  FTokenInfo := TTokenInfo.Create('Hello', 12, 23, 34, 5, ttIdentifier);
end;

procedure TestTTokenInfo.TearDown;
begin
  FTokenInfo.Free;
  FTokenInfo := nil;
end;

procedure TestTTokenInfo.TestAppend;

begin
  FTokenInfo.Append('Dave');
  CheckEquals('HelloDave', FTokenInfo.Token);
  CheckEquals(12, FTokenInfo.BufferPos);
  CheckEquals(23, FTokenInfo.Line);
  CheckEquals(34, FTokenInfo.Column);
  CheckEquals(9, FTokenInfo.Length);
end;

procedure TestTTokenInfo.TestCreate;
begin
  CheckEquals('Hello', FTokenInfo.Token);
  CheckEquals('', FTokenInfo.UToken);
  CheckEquals(12, FTokenInfo.BufferPos);
  CheckEquals(23, FTokenInfo.Line);
  CheckEquals(34, FTokenInfo.Column);
  CheckEquals(5, FTokenInfo.Length);
  CheckEquals(ttIdentifier, FTokenInfo.TokenType);
  CheckEquals(trUnknown, FTokenInfo.Reference);
end;

// Test methods for class TTag

procedure TestTTag.SetUp;
begin
  FTag := TTag.Create('todo', 12, 23);
end;

procedure TestTTag.TearDown;
begin
  FTag.Free;
  FTag := nil;
end;

procedure TestTTag.TestAddToken;

begin
  FTag.AddToken('Hello', ttIdentifier);
  FTag.AddToken('Dave', ttIdentifier);
  FTag.AddToken('.', ttSymbol);
  CheckEquals(3, FTag.TokenCount);
  CheckEquals('Hello', FTag.Tokens[0].Token);
  CheckEquals(ttIdentifier, FTag.Tokens[0].TokenType);
  CheckEquals('Dave', FTag.Tokens[1].Token);
  CheckEquals(ttIdentifier, FTag.Tokens[1].TokenType);
  CheckEquals('.', FTag.Tokens[2].Token);
  CheckEquals(ttSymbol, FTag.Tokens[2].TokenType);
end;

procedure TestTTag.TestAsString;

begin
  FTag.AddToken('Hello', ttIdentifier);
  FTag.AddToken('<b>', ttHTMLStartTag);
  FTag.AddToken('Dave', ttIdentifier);
  FTag.AddToken('</b>', ttHTMLEndTag);
  FTag.AddToken('.', ttSymbol);
  CheckEquals(ttHTMLStartTag, FTag.Tokens[1].TokenType);
  CheckEquals(ttHTMLEndTag, FTag.Tokens[3].TokenType);
  CheckEquals(5, FTag.TokenCount);
  CheckEquals('Hello Dave.', FTag.AsString(False));
  CheckEquals('Hello <b>Dave</b>.', FTag.AsString(True));
end;

procedure TestTTag.TestCreate;
begin
  CheckEquals('todo', FTag.TagName);
  CheckEquals(12, FTag.Line);
  CheckEquals(23, FTag.Column);
end;

// Test methods for class TComment

procedure TestTComment.SetUp;

Const
  strComment =
    ''#13#10 +
    '  This method does something wonderful.'#13#10 +
    ''#13#10 +
    '  @todo  Requires implementing.'#13#10 +
    '  @see   Something interesting.'#13#10 +
    '';

begin
  FComment := TComment.Create(strComment, 12, 34);
end;

procedure TestTComment.TearDown;
begin
  FComment.Free;
  FComment := nil;
end;

procedure TestTComment.TestCreate;
begin
  CheckEquals(6, FComment.TokenCount);
  CheckEquals('This', FComment.Tokens[0].Token);
  CheckEquals('method', FComment.Tokens[1].Token);
  CheckEquals('does', FComment.Tokens[2].Token);
  CheckEquals('something', FComment.Tokens[3].Token);
  CheckEquals('wonderful', FComment.Tokens[4].Token);
  CheckEquals('.', FComment.Tokens[5].Token);
  CheckEquals(ttidentifier, FComment.Tokens[0].TokenType);
  CheckEquals(ttidentifier, FComment.Tokens[1].TokenType);
  CheckEquals(ttidentifier, FComment.Tokens[2].TokenType);
  CheckEquals(ttidentifier, FComment.Tokens[3].TokenType);
  CheckEquals(ttidentifier, FComment.Tokens[4].TokenType);
  CheckEquals(ttSymbol, FComment.Tokens[5].TokenType);
  CheckEquals('todo', FComment.Tag[0].TagName);
  CheckEquals('Requires implementing.', FComment.Tag[0].AsString(False));
  CheckEquals('see', FComment.Tag[1].TagName);
  CheckEquals('Something interesting.', FComment.Tag[1].AsString(False));
  CheckEquals(2, FComment.TagCount);
  CheckEquals(12, FComment.Line);
  CheckEquals(34, FComment.Column);
end;

procedure TestTComment.TestCreateComment;

Const
  strComment =
    ''#13#10 +
    '  This method does something <b>wonderful</b>.'#13#10 +
    ''#13#10 +
    '  @todo  Requires <e>implementing</e>.'#13#10 +
    '  @see   Something interesting.'#13#10 +
    '';

var
  ReturnValue: TComment;

begin
  ReturnValue := FComment.CreateComment(strComment, 12, 23);
  Try
    CheckEquals(8, ReturnValue.TokenCount);
    CheckEquals('This', ReturnValue.Tokens[0].Token);
    CheckEquals('method', ReturnValue.Tokens[1].Token);
    CheckEquals('does', ReturnValue.Tokens[2].Token);
    CheckEquals('something', ReturnValue.Tokens[3].Token);
    CheckEquals('<b>', ReturnValue.Tokens[4].Token);
    CheckEquals('wonderful', ReturnValue.Tokens[5].Token);
    CheckEquals('</b>', ReturnValue.Tokens[6].Token);
    CheckEquals('.', ReturnValue.Tokens[7].Token);
    CheckEquals(ttidentifier, ReturnValue.Tokens[0].TokenType);
    CheckEquals(ttidentifier, ReturnValue.Tokens[1].TokenType);
    CheckEquals(ttidentifier, ReturnValue.Tokens[2].TokenType);
    CheckEquals(ttidentifier, ReturnValue.Tokens[3].TokenType);
    CheckEquals(ttHTMLStartTag, ReturnValue.Tokens[4].TokenType);
    CheckEquals(ttidentifier, ReturnValue.Tokens[5].TokenType);
    CheckEquals(ttHTMLEndTag, ReturnValue.Tokens[6].TokenType);
    CheckEquals(ttSymbol, ReturnValue.Tokens[7].TokenType);
    CheckEquals('todo', ReturnValue.Tag[0].TagName);
    CheckEquals('Requires implementing.', ReturnValue.Tag[0].AsString(False));
    CheckEquals('Requires <e>implementing</e>.', ReturnValue.Tag[0].AsString(True));
    CheckEquals('see', ReturnValue.Tag[1].TagName);
    CheckEquals('Something interesting.', ReturnValue.Tag[1].AsString(False));
    CheckEquals(2, ReturnValue.TagCount);
    CheckEquals(12, ReturnValue.Line);
    CheckEquals(23, ReturnValue.Column);
  Finally
    ReturnValue.Free;
  End;
end;

procedure TestTComment.TestAssign;

var
  srcComment: TComment;

begin
  srcComment := TComment.Create(Nil);
  Try
    srcComment.Assign(FComment);
    CheckEquals(6, srcComment.TokenCount);
    CheckEquals('This', srcComment.Tokens[0].Token);
    CheckEquals('method', srcComment.Tokens[1].Token);
    CheckEquals('does', srcComment.Tokens[2].Token);
    CheckEquals('something', srcComment.Tokens[3].Token);
    CheckEquals('wonderful', srcComment.Tokens[4].Token);
    CheckEquals('.', srcComment.Tokens[5].Token);
    CheckEquals(ttidentifier, srcComment.Tokens[0].TokenType);
    CheckEquals(ttidentifier, srcComment.Tokens[1].TokenType);
    CheckEquals(ttidentifier, srcComment.Tokens[2].TokenType);
    CheckEquals(ttidentifier, srcComment.Tokens[3].TokenType);
    CheckEquals(ttidentifier, srcComment.Tokens[4].TokenType);
    CheckEquals(ttSymbol, srcComment.Tokens[5].TokenType);
    CheckEquals('todo', srcComment.Tag[0].TagName);
    CheckEquals('Requires implementing.', srcComment.Tag[0].AsString(False));
    CheckEquals('see', srcComment.Tag[1].TagName);
    CheckEquals('Something interesting.', srcComment.Tag[1].AsString(False));
    CheckEquals(2, srcComment.TagCount);
    CheckEquals(12, srcComment.Line);
    CheckEquals(34, srcComment.Column);
  Finally
    srcComment.Free;
  End;
end;

procedure TestTComment.TestAssign1;

Const
  strComment =
    ''#13#10 +
    '  This method does something wonderful.'#13#10 +
    ''#13#10 +
    '  @todo  Requires implementing.'#13#10 +
    '  @see   Something interesting.'#13#10 +
    '';

var
  C : TComment;

begin
  C := TComment.Create(Nil);
  Try
    C.Assign(strComment);
    CheckEquals(6, C.TokenCount);
    CheckEquals('This', C.Tokens[0].Token);
    CheckEquals('method', C.Tokens[1].Token);
    CheckEquals('does', C.Tokens[2].Token);
    CheckEquals('something', C.Tokens[3].Token);
    CheckEquals('wonderful', C.Tokens[4].Token);
    CheckEquals('.', C.Tokens[5].Token);
    CheckEquals(ttidentifier, C.Tokens[0].TokenType);
    CheckEquals(ttidentifier, C.Tokens[1].TokenType);
    CheckEquals(ttidentifier, C.Tokens[2].TokenType);
    CheckEquals(ttidentifier, C.Tokens[3].TokenType);
    CheckEquals(ttidentifier, C.Tokens[4].TokenType);
    CheckEquals(ttSymbol, C.Tokens[5].TokenType);
    CheckEquals('todo', C.Tag[0].TagName);
    CheckEquals('Requires implementing.', C.Tag[0].AsString(False));
    CheckEquals('see', C.Tag[1].TagName);
    CheckEquals('Something interesting.', C.Tag[1].AsString(False));
    CheckEquals(2, C.TagCount);
    CheckEquals(0, C.Line);
    CheckEquals(0, C.Column);
  Finally
    C.Free;
  End;
end;

procedure TestTComment.TestAsString;

begin
  CheckEquals('This method does something wonderful.', FComment.AsString(80, False));
  CheckEquals('This method does something wonderful.', FComment.AsString(80, True));
end;

procedure TestTComment.TestFindTag;

begin
  CheckEquals(-1, FComment.FindTag('hello'));
  CheckEquals(0, FComment.FindTag('todo'));
  CheckEquals(1, FComment.FindTag('see'));
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTTokenInfo.Suite);
  RegisterTest(TestTTag.Suite);
  RegisterTest(TestTComment.Suite);
end.

